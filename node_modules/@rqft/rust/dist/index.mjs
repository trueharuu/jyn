var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/std/ascii.ts
var ascii_exports = {};

// src/std/bool.ts
var bool_exports = {};
__export(bool_exports, {
  bool: () => bool
});

// src/tools.ts
function staticify(value) {
  return new Proxy(value, {
    get(target, p) {
      if (p === "static") {
        return target;
      }
      if (p in value) {
        return value[p];
      }
      if (p in value.prototype) {
        if (typeof value.prototype[p] === "function") {
          return (self, ...args) => {
            return self[p](...args);
          };
        }
        return (...args) => {
          return new value(...args)[p];
        };
      }
    },
    apply(target, thisArg, argArray) {
      return new (target.bind(thisArg))(...argArray);
    },
    construct(target, argArray) {
      return target.new(...argArray);
    }
  });
}
var radii = "0123456789abcdefghijklmnopqrstuvwxyz";
function iter_len(t) {
  let i = 0;
  for (const _2 of t) {
    if (i === Infinity) {
      return i;
    }
    i++;
  }
  return i;
}
function is_iter(t) {
  return typeof t === "object" && Symbol.iterator in t;
}

// src/std/cmp.ts
var cmp_exports = {};
__export(cmp_exports, {
  Ordering: () => Ordering,
  default_partial_eq: () => default_partial_eq,
  default_partial_ord: () => default_partial_ord,
  has_derivable_partial_eq: () => has_derivable_partial_eq,
  has_derivable_partial_ord: () => has_derivable_partial_ord,
  is_cmp: () => is_cmp,
  is_eq: () => is_eq,
  max: () => max,
  max_by: () => max_by,
  max_by_key: () => max_by_key,
  min: () => min,
  min_by: () => min_by,
  min_by_key: () => min_by_key
});

// src/std/panic.ts
var panic_exports = {};
__export(panic_exports, {
  Panic: () => Panic,
  panic: () => panic
});
var Panic = class extends Error {
  constructor(message) {
    super(message);
    this.message = message;
    this.name = "Panic";
  }
};
function panic(message) {
  throw new Panic(message);
}

// src/std/cmp.ts
var Ordering = class {
  constructor(value) {
    this.value = value;
  }
  clone() {
    return new Ordering(this.value);
  }
  clone_from(source) {
    return source;
  }
  is_eq() {
    return this.value === 0;
  }
  is_ne() {
    return !this.is_eq();
  }
  is_lt() {
    return this.value === -1;
  }
  is_gt() {
    return this.value === 1;
  }
  is_le() {
    return this.is_eq() || this.is_lt();
  }
  is_ge() {
    return this.is_eq() || this.is_gt();
  }
  reverse() {
    if (this.is_eq()) {
      return this;
    }
    if (this.is_lt()) {
      return Ordering.Greater;
    }
    return Ordering.Less;
  }
  then(other) {
    if (this.is_eq()) {
      return other;
    }
    return this;
  }
  then_with(f) {
    return this.then(f());
  }
};
((Ordering2) => {
  Ordering2.Less = new Ordering2(-1);
  Ordering2.Equal = new Ordering2(0);
  Ordering2.Greater = new Ordering2(1);
})(Ordering || (Ordering = {}));
function max(v1, v2) {
  return v1.max(v2);
}
function max_by(v1, v2, compare) {
  const v = compare(v1, v2);
  if (v.is_gt()) {
    return v1;
  }
  return v2;
}
function max_by_key(v1, v2, f) {
  const k1 = f(v1);
  const k2 = f(v2);
  if (k1.max(k2) === k1) {
    return v1;
  }
  return v2;
}
function min(v1, v2) {
  return v1.min(v2);
}
function min_by(v1, v2, compare) {
  const v = compare(v1, v2);
  if (v.is_le()) {
    return v1;
  }
  return v2;
}
function min_by_key(v1, v2, f) {
  const k1 = f(v1);
  const k2 = f(v2);
  if (k1.min(k2) === k1) {
    return v1;
  }
  return v2;
}
function has_derivable_partial_eq(value) {
  return typeof value === "object" && "eq" in value;
}
function default_partial_eq(value) {
  if (has_derivable_partial_eq(value)) {
    return {
      eq: value.eq,
      ne(other) {
        console.log(value, other, value.eq.toString());
        return !value.eq(other);
      }
    };
  }
  panic("PartialEq cannot be derived without eq method");
}
function has_derivable_partial_ord(value) {
  return has_derivable_partial_eq(value) && "partial_cmp" in value;
}
function default_partial_ord(value) {
  if (has_derivable_partial_ord(value)) {
    return {
      eq: value.eq,
      partial_cmp: value.partial_cmp,
      lt(other) {
        return value.partial_cmp(other).is_lt();
      },
      le(other) {
        return value.partial_cmp(other).is_le();
      },
      gt(other) {
        return value.partial_cmp(other).is_gt();
      },
      ge(other) {
        return value.partial_cmp(other).is_ge();
      },
      ne(other) {
        return !value.eq(other);
      }
    };
  }
  panic("PartialOrd cannot be derived without (eq, partial_cmp) methods");
}
function is_eq(x) {
  return typeof x === "object" && "eq" in x && "ne" in x;
}
function is_cmp(x) {
  return typeof x === "object" && is_eq(x) && ["partial_cmp", "lt", "le", "gt", "ge"].every((p) => p in x);
}

// src/std/option.ts
var option_exports = {};
__export(option_exports, {
  None: () => None,
  Option: () => Option,
  Some: () => Some
});

// src/std/convert.ts
var convert_exports = {};
__export(convert_exports, {
  Ref: () => Ref,
  RefMut: () => RefMut
});
var RefImpl = class {
  constructor(self, value) {
    this.self = self;
    this.value = value;
  }
  static new(self, value) {
    return new this(self, value);
  }
  deref() {
    return Object.freeze(this.value);
  }
};
var Ref = staticify(RefImpl);
var RefMutImpl = class {
  constructor(self, value) {
    this.self = self;
    this.value = value;
  }
  static new(self, value) {
    return new this(self, value);
  }
  deref() {
    return Object.freeze(this.value);
  }
  deref_mut() {
    return this.value;
  }
};
var RefMut = staticify(RefMutImpl);

// src/std/hash.ts
var hash_exports = {};
__export(hash_exports, {
  compare_hash: () => compare_hash
});
function compare_hash(t, u) {
  if ("hash" in t && "hash" in u) {
    return t.hash() === u.hash();
  }
  if ("eq" in t) {
    return t.eq(u);
  }
  return t === u;
}

// src/std/option.ts
var SomeImpl = class {
  constructor(value) {
    this.value = value;
  }
  fmt_debug() {
    return `Some(${this.value.fmt_debug()})`;
  }
  static new(value) {
    return new this(value);
  }
  clone() {
    return Some(this.value);
  }
  some() {
    return this.is_some();
  }
  none() {
    return this.is_none();
  }
  is_some() {
    return true;
  }
  is_some_and(f) {
    return f(this.value);
  }
  is_none() {
    return false;
  }
  as_ref() {
    return new Ref(this, this.value);
  }
  as_mut_ref() {
    return new RefMut(this, this.value);
  }
  expect(message) {
    return this.value;
  }
  unwrap() {
    return this.value;
  }
  unwrap_or(def) {
    return this.value;
  }
  unwrap_or_else(f) {
    return this.value;
  }
  unwrap_or_default() {
    return this.value;
  }
  unwrap_unchecked() {
    return this.value;
  }
  map(f) {
    return SomeImpl.new(f(this.value));
  }
  inspect(f) {
    f(this.value);
    return this;
  }
  map_or(def, f) {
    return this.map(f).unwrap();
  }
  map_or_else(def, f) {
    return this.map(f).unwrap();
  }
  // ok_or, ok_or_else
  // public as_deref(): Option<Ref<this, T>> {
  //   return SomeImpl.new(Ref.new<this, T>(this as never, this.value.deref()));
  // }
  // public as_deref_mut(): Option<RefMut<this, T>> {
  //   if (typeof this.value === 'object' && 'deref_mut' in (this.value as DerefMut<_>))
  //     return SomeImpl.new(
  //       RefMut.new<this, T>(this as never, this.value.deref_mut())
  //     );
  // }
  // iter, iter_mut
  and(optb) {
    return optb;
  }
  and_then(f) {
    return f(this.value);
  }
  filter(predicate) {
    if (!predicate(this.value)) {
      return None;
    }
    return this;
  }
  or(optb) {
    return this;
  }
  or_else(f) {
    return this;
  }
  xor(optb) {
    if (optb.is_some()) {
      return None;
    }
    return this;
  }
  insert(value) {
    this.value = value;
    return RefMut.new(this, value);
  }
  get_or_insert(value) {
    return RefMut.new(this, this.value);
  }
  get_or_insert_default() {
    return RefMut.new(this, this.value);
  }
  get_or_insert_with(f) {
    return RefMut.new(this, this.value);
  }
  take() {
    const old = this.clone();
    Object.assign(this, None);
    return old;
  }
  replace(value) {
    const old = this.clone();
    this.value = value;
    return old;
  }
  contains(x) {
    return compare_hash(this.value, x);
  }
  zip(other) {
    if (other.is_none()) {
      return None;
    }
    return SomeImpl.new([this.value, other.value]);
  }
  zip_with(other, f) {
    if (other.is_none()) {
      return None;
    }
    return SomeImpl.new(f(this.value, other.value));
  }
  // public unzip<Z, U>(): [Option<Z>, Option<U>] {
  //   return [SomeImpl.new(this.value[0]), SomeImpl.new(this.value[1])];
  // }
  // public copied<U>(): Option<U> {
  //   return SomeImpl.new(this.value.deref());
  // }
  // public copied_mut<U>(): Option<U> {
  //   return SomeImpl.new(this.value.deref_mut());
  // }
  // public transpose<P, E>(): Result<Option<P>, E> {
  //   if ('is_ok' in (this.value as Result<P, E>))
  //     if ((this.value as Result<P, E>).is_ok()) {
  //       // @ts-expect-error wtf is this error
  //       return Ok(Some(this.value.value));
  //     }
  //   return this.value as never;
  // }
  // public flatten(): T extends Option<infer U> ? Option<U> : never {
  //   return this.value as never;
  // }
  // partialeq
  eq(other) {
    if (other.is_none()) {
      return false;
    }
    if (has_derivable_partial_eq(this.value)) {
      return this.value.eq(other.value);
    }
    panic(
      "Option<T> is not an impl of PartialEq because bound `T: PartialEq` is not satisfied"
    );
  }
  ne(other) {
    return default_partial_eq(this).ne(other);
  }
  // partialord
  partial_cmp(other) {
    if (other.is_none()) {
      return Ordering.Greater;
    }
    if (has_derivable_partial_ord(this.value)) {
      return this.value.partial_cmp(other.value);
    }
    panic(
      "Option<T> is not an impl of PartialOrd because bound `T: PartialOrd` is not satisified"
    );
  }
  ge(other) {
    return default_partial_ord(this).ge(other);
  }
  gt(other) {
    return default_partial_ord(this).gt(other);
  }
  le(other) {
    return default_partial_ord(this).le(other);
  }
  lt(other) {
    return default_partial_ord(this).lt(other);
  }
};
var NoneImpl = class {
  value = void 0;
  static new() {
    return new this();
  }
  fmt_debug() {
    return "None";
  }
  some() {
    return this.is_some();
  }
  none() {
    return this.is_none();
  }
  clone() {
    return None;
  }
  is_some() {
    return false;
  }
  is_some_and(f) {
    return false;
  }
  is_none() {
    return true;
  }
  as_ref() {
    return Ref.new(this, this.value);
  }
  as_mut_ref() {
    return RefMut.new(this, this.value);
  }
  expect(message) {
    panic(message);
  }
  unwrap() {
    this.expect("called unwrap() on None");
  }
  unwrap_or(def) {
    return def;
  }
  unwrap_or_else(f) {
    return f();
  }
  unwrap_or_default() {
    panic("unwrap_or_default not implemented");
  }
  unwrap_unchecked() {
    return this.value;
  }
  map(f) {
    return NoneImpl.new();
  }
  inspect(f) {
  }
  map_or(def, f) {
    return def;
  }
  map_or_else(def, f) {
    return def();
  }
  // ok_or, ok_or_else
  // public as_deref<U>(): Option<Readonly<U>> {
  //   return NoneImpl.new<Readonly<U>>();
  // }
  // public as_deref_mut<U>(): Option<U> {
  //   return NoneImpl.new<U>();
  // }
  // iter, iter_mut
  and(optb) {
    return None;
  }
  and_then(f) {
    return None;
  }
  filter(predicate) {
    return this;
  }
  or(optb) {
    return optb;
  }
  or_else(f) {
    return f();
  }
  xor(optb) {
    if (optb.is_none()) {
      return this;
    }
    return optb;
  }
  insert(value) {
    Object.assign(this, Some(value));
    return RefMut.new(this, value);
  }
  get_or_insert(value) {
    return this.insert(value);
  }
  get_or_insert_default() {
    panic("get_or_insert_default not implemented for None");
  }
  get_or_insert_with(f) {
    return this.insert(f());
  }
  take() {
    return this;
  }
  replace(value) {
    Object.assign(this, Some(value));
    return this;
  }
  contains(x) {
    return false;
  }
  zip(other) {
    return None;
  }
  zip_with(other, f) {
    return None;
  }
  // public unzip<Z, U>(): [None<Z>, None<U>] {
  //   return [None, None];
  // }
  // public copied<U>(): Option<U> {
  //   return None;
  // }
  // public copied_mut<U>(): Option<U> {
  //   return None;
  // }
  // public transpose<P, E>(): Result<Option<P>, E> {
  //   return Ok(None);
  // }
  // public flatten(): T extends Option<infer U> ? Option<U> : never {
  //   return None as never;
  // }
  // partialeq
  eq(other) {
    return other.is_none();
  }
  ne(other) {
    return default_partial_eq(this).ne(other);
  }
  // partialord
  partial_cmp(other) {
    if (other.is_none()) {
      return Ordering.Equal;
    }
    return Ordering.Less;
  }
  ge(other) {
    return default_partial_ord(this).ge(other);
  }
  gt(other) {
    return default_partial_ord(this).gt(other);
  }
  le(other) {
    return default_partial_ord(this).le(other);
  }
  lt(other) {
    return default_partial_ord(this).lt(other);
  }
};
var Option = {
  is_some(value) {
    return value.is_some();
  },
  is_none(value) {
    return value.is_none();
  },
  some(T) {
    return Some(T);
  },
  none(T) {
    return None;
  }
};
var Some = staticify(SomeImpl);
var None = new NoneImpl();

// src/std/bool.ts
var _BoolImpl = class {
  value;
  // ToBool<T>
  constructor(value) {
    this.value = value.valueOf();
  }
  static new(value) {
    return new this(value);
  }
  fmt_debug() {
    return String(this.value);
  }
  fmt_display() {
    return String(this.value);
  }
  as_primitive() {
    return !!this.value;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  valueOf() {
    return !!this.value;
  }
  then_some(t) {
    if (this.value) {
      return Some(t);
    }
    return None;
  }
  then(f) {
    if (this.value) {
      return Some(f());
    }
    return None;
  }
  bitand(other) {
    return bool(this.value && other.valueOf());
  }
  bitand_assign(other) {
    this.value = this.bitand(other).value;
    return this;
  }
  bitor(other) {
    return bool(this.value.valueOf() || other.valueOf());
  }
  bitor_assign(other) {
    this.value = this.bitor(other).value;
    return this;
  }
  bitxor(other) {
    return bool(!!(+this.value ^ +other));
  }
  bitxor_assign(other) {
    this.value = this.bitxor(other).value;
    return this;
  }
  not() {
    return new _BoolImpl(!this.value);
  }
  clone() {
    return new _BoolImpl(this.value);
  }
  default() {
    return _BoolImpl.false;
  }
  eq(other) {
    return this.bitxor(other).not();
  }
  ne(other) {
    return this.bitxor(other);
  }
  partial_cmp(other) {
    if (this.eq(other).valueOf()) {
      return Ordering.Equal;
    }
    if (this.eq(true).valueOf()) {
      return Ordering.Greater;
    }
    return Ordering.Less;
  }
  ge(other) {
    return new _BoolImpl(this.partial_cmp(other).is_ge());
  }
  gt(other) {
    return new _BoolImpl(this.partial_cmp(other).is_gt());
  }
  le(other) {
    return new _BoolImpl(this.partial_cmp(other).is_le());
  }
  lt(other) {
    return new _BoolImpl(this.partial_cmp(other).is_lt());
  }
};
var BoolImpl = _BoolImpl;
__publicField(BoolImpl, "true", new _BoolImpl(true));
__publicField(BoolImpl, "false", new _BoolImpl(false));
var bool = staticify(BoolImpl);

// src/std/char/index.ts
var char_exports = {};
__export(char_exports, {
  DecodeUtf16: () => DecodeUtf16,
  DecodeUtf16Error: () => DecodeUtf16Error,
  EscapeDebug: () => EscapeDebug,
  EscapeDefault: () => EscapeDefault,
  EscapeUnicode: () => EscapeUnicode,
  Types: () => types_exports,
  char: () => char
});

// src/std/result.ts
var result_exports = {};
__export(result_exports, {
  Err: () => Err,
  Ok: () => Ok,
  result_from: () => result_from
});
var OkImpl = class {
  constructor(value = void 0) {
    this.value = value;
  }
  fmt_debug() {
    return `Ok(${this.value.fmt_debug()})`;
  }
  as_ref() {
    return Ref(this, this.value);
  }
  as_mut_ref() {
    return RefMut(this, this.value);
  }
  is_ok() {
    return true;
  }
  is_ok_and(f) {
    return f(this.unwrap());
  }
  is_err() {
    return false;
  }
  is_err_and(f) {
    return false;
  }
  ok() {
    return Some(this.unwrap());
  }
  err() {
    return None;
  }
  map(f) {
    return Ok(f(this.unwrap()));
  }
  map_or(other, f) {
    return f(this.unwrap());
  }
  map_or_else(other, f) {
    return f(this.unwrap());
  }
  map_err(f) {
    return this;
  }
  inspect(f) {
    f(this.unwrap());
    return this;
  }
  inspect_err(f) {
    return this;
  }
  expect(message) {
    return this.unwrap();
  }
  unwrap() {
    return this.value;
  }
  expect_err(message) {
    throw `${message}: ${this.unwrap()}`;
  }
  unwrap_err() {
    return this.expect_err("Called unwrap_err() on Ok");
  }
  into_ok() {
    return this.unwrap();
  }
  into_err() {
    return void 0;
  }
  and(other) {
    return other;
  }
  and_then(f) {
    return f(this.unwrap());
  }
  or(other) {
    return this;
  }
  or_else(f) {
    return this;
  }
  unwrap_or(other) {
    return this.unwrap();
  }
  unwrap_or_else(f) {
    return this.unwrap();
  }
  unwrap_unchecked() {
    return this.unwrap();
  }
  unwrap_err_unchecked() {
    return void 0;
  }
  contains(value) {
    return this.unwrap() === value;
  }
  contains_err(error) {
    return false;
  }
  static new(value = void 0) {
    return new this(value);
  }
  eq(other) {
    if (other.is_err()) {
      return false;
    }
    if (has_derivable_partial_eq(this.value)) {
      return this.value.eq(other.unwrap());
    }
    panic(
      "Ok(T) is not an impl of PartialEq because bound `T: PartialEq` is not satisfied"
    );
  }
  ne(other) {
    return default_partial_eq(this).ne(other);
  }
  partial_cmp(other) {
    if (other.is_err()) {
      return Ordering.Greater;
    }
    if (has_derivable_partial_ord(this.value)) {
      return this.value.partial_cmp(other.unwrap());
    }
    panic(
      "Ok(T) is not an impl of PartialOrd because bound `T: PartialOrd` is not satisified"
    );
  }
  ge(other) {
    return default_partial_ord(this).ge(other);
  }
  gt(other) {
    return default_partial_ord(this).gt(other);
  }
  le(other) {
    return default_partial_ord(this).le(other);
  }
  lt(other) {
    return default_partial_ord(this).lt(other);
  }
};
var ErrImpl = class {
  constructor(value = void 0) {
    this.value = value;
  }
  fmt_debug() {
    return `Err(${this.value.fmt_debug()})`;
  }
  as_ref() {
    return Ref(this, this.value);
  }
  as_mut_ref() {
    return RefMut(this, this.value);
  }
  is_ok() {
    return false;
  }
  is_ok_and(f) {
    return false;
  }
  is_err() {
    return true;
  }
  is_err_and(f) {
    return f(this.unwrap_err());
  }
  ok() {
    return None;
  }
  err() {
    return Some(this.unwrap_err());
  }
  map(f) {
    return this;
  }
  map_or(other, f) {
    return other;
  }
  map_or_else(other, f) {
    return other(this.unwrap_err());
  }
  map_err(f) {
    return Err(f(this.unwrap_err()));
  }
  inspect(f) {
    return this;
  }
  inspect_err(f) {
    f(this.unwrap_err());
    return this;
  }
  expect(message) {
    throw `${message}: ${this.unwrap_err()}`;
  }
  unwrap() {
    return this.expect("Called unwrap() on Err");
  }
  expect_err(message) {
    return this.unwrap_err();
  }
  unwrap_err() {
    return this.value;
  }
  into_ok() {
    return void 0;
  }
  into_err() {
    return this.unwrap_err();
  }
  and(other) {
    return this;
  }
  and_then(f) {
    return this;
  }
  or(other) {
    return other;
  }
  or_else(f) {
    return f(this.unwrap_err());
  }
  unwrap_or(other) {
    return other;
  }
  unwrap_or_else(f) {
    return f(this.unwrap_err());
  }
  unwrap_unchecked() {
    return void 0;
  }
  unwrap_err_unchecked() {
    return this.unwrap_err();
  }
  contains(value) {
    return false;
  }
  contains_err(error) {
    return this.unwrap_err() === error;
  }
  static new(value = void 0) {
    return new this(value);
  }
  eq(other) {
    if (other.is_ok()) {
      return false;
    }
    if (has_derivable_partial_eq(this.value)) {
      return this.value.eq(other.unwrap_err());
    }
    panic(
      "Err(E) is not an impl of PartialEq because bound `E: PartialEq` is not satisfied"
    );
  }
  ne(other) {
    return default_partial_eq(this).ne(other);
  }
  partial_cmp(other) {
    if (other.is_err()) {
      return Ordering.Greater;
    }
    if (has_derivable_partial_ord(this.value)) {
      return this.value.partial_cmp(other.unwrap_err());
    }
    panic(
      "Ok(T) is not an impl of PartialOrd because bound `T: PartialOrd` is not satisified"
    );
  }
  ge(other) {
    return default_partial_ord(this).ge(other);
  }
  gt(other) {
    return default_partial_ord(this).gt(other);
  }
  le(other) {
    return default_partial_ord(this).le(other);
  }
  lt(other) {
    return default_partial_ord(this).lt(other);
  }
};
var Ok = staticify(OkImpl);
var Err = staticify(ErrImpl);
function result_from(f) {
  try {
    return Ok(f());
  } catch (e) {
    return Err(e);
  }
}

// src/std/number/parse_int_error.ts
var ParseIntErrorImpl = class extends Error {
  constructor(k) {
    super(`Parsing integer failed: ${k}`);
    this.k = k;
  }
  kind() {
    return this.k;
  }
  static new(k) {
    return new this(k);
  }
};
var ParseIntError = staticify(ParseIntErrorImpl);

// src/std/number/size.ts
var SizeImpl = class {
  // From
  value;
  constructor(value) {
    if (value instanceof SizeImpl) {
      value = value.value;
    }
    this.value = BigInt(value);
  }
  assign(other) {
    other = size(other);
    this.value = other.valueOf();
    return this;
  }
  fmt_binary() {
    return this.value.toString(2);
  }
  fmt_debug() {
    return this.value.toString();
  }
  fmt_display() {
    return this.value.toLocaleString();
  }
  fmt_lower_exp() {
    return this.into(Number).toExponential();
  }
  fmt_lower_hex() {
    return this.value.toString(16);
  }
  fmt_octal() {
    return this.value.toString(8);
  }
  fmt_precision(precision) {
    return this.into(Number).toPrecision(precision);
  }
  fmt_signed() {
    return this.value >= 0 ? "+" : "-";
  }
  fmt_upper_exp() {
    return this.fmt_lower_exp().toUpperCase();
  }
  fmt_upper_hex() {
    return this.fmt_lower_hex().toUpperCase();
  }
  cast() {
    return this;
  }
  static new(value) {
    return new this(value);
  }
  as_primitive() {
    return this.value;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  valueOf() {
    return this.value;
  }
  static from_str(src) {
    if (src.length === 0) {
      return Err(ParseIntError.new("Empty" /* Empty */));
    }
    try {
      return Ok(new this(src));
    } catch {
      return Err(ParseIntError.new("InvalidDigit" /* InvalidDigit */));
    }
  }
  count_ones(lim = 32) {
    lim = size(lim);
    let count = 0n;
    for (let i = 0n; i < lim.value; i++) {
      count += (this.value & 1n << i) >> i;
    }
    return size(count);
  }
  count_zeros(lim = 32) {
    lim = size(lim);
    let count = 0n;
    for (let i = 0n; i < lim.value; i++) {
      if ((this.value & 1n << i) === 0n) {
        count++;
      }
    }
    return size(count);
  }
  leading_zeros(lim = 32) {
    lim = size(lim);
    let count = 0n;
    for (let i = lim.value - 1n; i >= 0n; i--) {
      if ((this.value & 1n << i) !== 0n) {
        break;
      }
      count++;
    }
    return size(count);
  }
  trailing_zeros(lim = 32) {
    lim = size(lim);
    let count = 0n;
    for (let i = 0n; i < lim.value; i++) {
      if ((this.value & 1n << i) !== 0n) {
        break;
      }
      count++;
    }
    return size(count);
  }
  leading_ones(lim = 32) {
    lim = size(lim);
    let count = 0n;
    for (let i = lim.value - 1n; i >= 0n; i--) {
      if ((this.value & 1n << i) !== 1n) {
        break;
      }
      count++;
    }
    return size(count);
  }
  trailing_ones(lim = 32) {
    lim = size(lim);
    let count = 0n;
    for (let i = 0n; i < lim.value; i++) {
      if ((this.value & 1n << i) !== 1n) {
        break;
      }
      count++;
    }
    return size(count);
  }
  n_bit_mask(n) {
    n = size(n);
    return size((1n << n.value) - 1n);
  }
  rotate_left(n = 1, lim = 32) {
    n = size(n);
    lim = size(lim);
    const raw = this.value & this.n_bit_mask(lim).value;
    return size(raw << n.value | raw >> lim.value - n.value);
  }
  rotate_right(n = 1, lim = 32) {
    n = size(n);
    lim = size(lim);
    const raw = this.value & this.n_bit_mask(lim).value;
    return size(raw >> n.value | raw << lim.value - n.value);
  }
  swap_bytes(lim = 32) {
    lim = size(lim);
    let raw = this.value & this.n_bit_mask(lim).value;
    let bytes = [];
    const byte = this.n_bit_mask(8n).value;
    for (let i = 0n; i < lim.value; i += 8n) {
      bytes.push(raw & byte);
      raw >>= 8n;
    }
    let bits = 0n;
    bytes = bytes.reverse();
    for (let i = 0; i < bytes.length; i++) {
      bits |= (bytes[i] || 0n) << 8n * BigInt(i);
    }
    return size(bits);
  }
  reverse_bits(lim = 32) {
    lim = size(lim);
    const raw = this.value & this.n_bit_mask(lim).value;
    let bits = 0n;
    for (let i = 0n; i < lim.value; i++) {
      if (raw & 1n << i) {
        bits |= 1n << lim.value - i;
      }
    }
    return size(bits);
  }
  // from_be, from_le, to_be, to_le
  unchecked_op(rhs, x) {
    return size(x(this.value, size(rhs).value));
  }
  checked(value, [min2, max2] = [-(1n << 32n), (1n << 32n) - 1n]) {
    [min2, max2] = [size(min2), size(max2)];
    if (value.value < min2.value || value.value > max2.value) {
      return None;
    }
    return Some(value);
  }
  checked_op(rhs, x, lim) {
    const value = this.unchecked_op(rhs, x);
    return this.checked(value, lim);
  }
  unchecked_add(rhs) {
    return this.unchecked_op(rhs, (self, rhs2) => self + rhs2);
  }
  checked_add(rhs, lim) {
    return this.checked_op(rhs, (self, rhs2) => self + rhs2, lim);
  }
  unchecked_sub(rhs) {
    return this.unchecked_op(rhs, (self, rhs2) => self - rhs2);
  }
  checked_sub(rhs, lim) {
    return this.checked_op(rhs, (self, rhs2) => self - rhs2, lim);
  }
  unchecked_mul(rhs) {
    return this.unchecked_op(rhs, (self, rhs2) => self * rhs2);
  }
  checked_mul(rhs, lim) {
    return this.checked_op(rhs, (self, rhs2) => self * rhs2, lim);
  }
  checked_div(rhs, lim) {
    rhs = size(rhs);
    if (rhs.value === 0n) {
      return None;
    }
    return this.checked_op(rhs, (self, rhs2) => self / rhs2, lim);
  }
  // checked_div_euclid
  checked_rem(rhs, lim) {
    rhs = size(rhs);
    if (rhs.value === 0n) {
      return None;
    }
    return this.checked_op(rhs, (self, rhs2) => self % rhs2, lim);
  }
  // checked_rem_euclid
  unchecked_neg() {
    return this.unchecked_op(0n, (self) => -self);
  }
  checked_neg(lim) {
    return this.checked(this.unchecked_neg(), lim);
  }
  unchecked_shl(rhs) {
    return this.unchecked_op(rhs, (self, rhs2) => self << rhs2);
  }
  checked_shl(rhs, bits = 32) {
    rhs = size(rhs);
    bits = size(bits);
    if (rhs.value >= bits.value) {
      return None;
    }
    return Some(
      size(this.n_bit_mask(bits).value & this.unchecked_shl(rhs.value).value)
    );
  }
  unchecked_shr(rhs) {
    return this.unchecked_op(rhs, (self, rhs2) => self >> rhs2);
  }
  checked_shr(rhs, bits = 32) {
    rhs = size(rhs);
    bits = size(bits);
    if (rhs.value >= bits.value) {
      return None;
    }
    return Some(
      size(this.n_bit_mask(bits).value & this.unchecked_shr(rhs.value).value)
    );
  }
  unchecked_abs() {
    if (this.value < 0n) {
      return size(-this.value);
    }
    return this;
  }
  checked_abs([min2, max2] = [-(1n << 32n), (1n << 32n) - 1n]) {
    min2 = size(min2);
    max2 = size(max2);
    if (this.value === min2.value) {
      return None;
    }
    if (this.value < 0n) {
      return this.checked_neg([min2, max2]);
    }
    return Some(this);
  }
  unchecked_pow(rhs) {
    return this.unchecked_op(rhs, (self, rhs2) => self ** rhs2);
  }
  checked_pow(rhs, lim) {
    return this.checked(this.unchecked_pow(rhs), lim);
  }
  saturate(value, [min2, max2] = [-(1n << 32n), (1n << 32n) - 1n]) {
    [min2, max2] = [size(min2), size(max2)];
    if (value.value < min2.value) {
      return min2;
    }
    if (value.value > max2.value) {
      return min2;
    }
    return value;
  }
  saturating_op(rhs, x, lim) {
    return this.saturate(this.unchecked_op(rhs, x), lim);
  }
  saturating_add(rhs, lim) {
    return this.saturate(this.unchecked_add(rhs), lim);
  }
  saturating_sub(rhs, lim) {
    return this.saturate(this.unchecked_sub(rhs), lim);
  }
  saturating_neg(lim) {
    return this.saturate(this.unchecked_neg(), lim);
  }
  saturating_mul(rhs, lim) {
    return this.saturate(this.unchecked_mul(rhs), lim);
  }
  saturating_div(rhs, lim) {
    return this.saturating_op(rhs, (self, rhs2) => self / rhs2, lim);
  }
  saturating_pow(exp, lim) {
    return this.saturate(this.unchecked_pow(exp), lim);
  }
  wrapping(value, [min2, max2] = [-(1n << 32n), (1n << 32n) - 1n]) {
    let p = value.value;
    while (p > size(max2).value) {
      p = size(min2).value + (size(max2).value - p);
    }
    while (p < size(min2).value) {
      p = size(max2).value - (size(min2).value + p);
    }
    return size(p);
  }
  wrapping_op(rhs, x, lim) {
    return this.wrapping(this.unchecked_op(rhs, x), lim);
  }
  wrapping_add(rhs, lim) {
    return this.wrapping(this.unchecked_add(rhs), lim);
  }
  wrapping_sub(rhs, lim) {
    return this.wrapping(this.unchecked_sub(rhs), lim);
  }
  wrapping_mul(rhs, lim) {
    return this.wrapping(this.unchecked_mul(rhs), lim);
  }
  wrapping_div(rhs, lim) {
    return this.wrapping_op(rhs, (x, rhs2) => x / rhs2, lim);
  }
  // wrapping_div_euclid
  wrapping_rem(rhs, lim) {
    return this.wrapping_op(rhs, (x, rhs2) => x % rhs2, lim);
  }
  // wrapping_rem_euclid
  wrapping_neg(lim) {
    return this.wrapping(this.unchecked_neg(), lim);
  }
  // wrapping_shl, wrapping_shr
  wrapping_abs(lim) {
    return this.wrapping(this.unchecked_abs(), lim);
  }
  wrapping_pow(rhs, lim) {
    return this.wrapping(this.unchecked_pow(rhs), lim);
  }
  overflowing(value, lim) {
    const wrapped = this.wrapping(value, lim);
    if (wrapped.value !== value.value) {
      return [wrapped, true];
    }
    return [value, false];
  }
  overflowing_op(rhs, x, lim) {
    return this.overflowing(this.unchecked_op(rhs, x), lim);
  }
  overflowing_add(rhs, lim) {
    return this.overflowing(this.unchecked_add(rhs), lim);
  }
  overflowing_sub(rhs, lim) {
    return this.overflowing(this.unchecked_sub(rhs), lim);
  }
  overflowing_mul(rhs, lim) {
    return this.overflowing(this.unchecked_mul(rhs), lim);
  }
  overflowing_div(rhs, lim) {
    return this.overflowing_op(rhs, (self, rhs2) => self / rhs2, lim);
  }
  // overflowing_div_euclid
  overflowing_rem(rhs, lim) {
    return this.overflowing_op(rhs, (self, rhs2) => self % rhs2, lim);
  }
  // overflowing_rem_euclid
  overflowing_neg(lim) {
    return this.overflowing(this.unchecked_neg(), lim);
  }
  // overflowing_shl, overflowing_shr
  overflowing_abs(lim) {
    return this.overflowing(this.unchecked_abs(), lim);
  }
  overflowing_pow(exp, lim) {
    return this.overflowing(this.unchecked_pow(exp), lim);
  }
  // raw
  pow(exp, lim) {
    return this.checked_pow(exp, lim).unwrap();
  }
  // div_euclid
  // rem_euclid, div_floor, div_ceil
  next_multiple_of(rhs, lim) {
    rhs = size(rhs);
    if (rhs.value === 0n) {
      panic("parameter rhs in fn `next_multiple_of` cannot be 0");
    }
    for (let i = this.value; ; i++) {
      if (rhs.value % i === 0n) {
        return size(0n).wrapping(size(i), lim);
      }
    }
  }
  checked_next_multiple_of(rhs, lim) {
    rhs = size(rhs);
    if (rhs.value === 0n) {
      return None;
    }
    for (let i = this.value; ; i++) {
      if (rhs.value % i === 0n) {
        return size(0n).checked(size(i), lim);
      }
    }
  }
  // ilog, ilog2, ilog10, checked_ilog, checked_ilog2, checked_ilog10
  abs(max2 = 1n << 31n - 1n) {
    if (this.value < 0n) {
      const abs = -this.value;
      if (abs > size(max2).value) {
        panic("method `abs` overflowed past the maximum");
      }
      return size(abs);
    }
    return this;
  }
  abs_diff(other, max2) {
    return this.unchecked_sub(other).abs(max2);
  }
  signum() {
    if (this.value === 0n) {
      return this;
    }
    if (this.value < 0n) {
      return size(-1);
    }
    return size(1);
  }
  is_positive() {
    return this.value > 0;
  }
  is_negative() {
    return this.value < 0;
  }
  map(f) {
    this.value = f(this.value);
    return this;
  }
  into(f) {
    return f(this.value);
  }
  // std::ops
  add(other) {
    return size(this.valueOf() + size(other).valueOf());
  }
  add_assign(other) {
    return this.map(() => this.add(other).valueOf());
  }
  clone() {
    return size(this);
  }
  static default() {
    return size(0);
  }
  div(other) {
    return size(this.valueOf() / size(other).valueOf());
  }
  div_assign(other) {
    return this.map(() => this.div(other).valueOf());
  }
  mul(other) {
    return size(this.valueOf() * size(other).valueOf());
  }
  mul_assign(other) {
    return this.map(() => this.mul(other).valueOf());
  }
  neg() {
    return this.map((x) => -x);
  }
  rem(other) {
    return size(this.valueOf() % size(other).valueOf());
  }
  rem_assign(other) {
    return this.map(() => this.rem(other).valueOf());
  }
  sub(other) {
    return size(this.valueOf() - size(other).valueOf());
  }
  sub_assign(other) {
    return this.map(() => this.sub(other).valueOf());
  }
  bitand(other) {
    return size(this.valueOf() & size(other).valueOf());
  }
  bitand_assign(other) {
    return this.map(() => this.bitand(other).valueOf());
  }
  bitor(other) {
    return size(this.valueOf() | size(other).valueOf());
  }
  bitor_assign(other) {
    return this.map(() => this.bitor(other).valueOf());
  }
  bitxor(other) {
    return size(this.valueOf() ^ size(other).valueOf());
  }
  bitxor_assign(other) {
    return this.map(() => this.bitxor(other).valueOf());
  }
  shl(other) {
    return size(this.valueOf() << size(other).valueOf());
  }
  shl_assign(other) {
    return this.map(() => this.shl(other).valueOf());
  }
  shr(other) {
    return size(this.valueOf() >> size(other).valueOf());
  }
  shr_assign(other) {
    return this.map(() => this.shr(other).valueOf());
  }
  eq(other) {
    return this.value === size(other).value;
  }
  ne(other) {
    return !this.eq(other);
  }
  not() {
    return this.map((x) => ~x);
  }
  partial_cmp(other) {
    other = size(other);
    if (this.eq(other)) {
      return Ordering.Equal;
    }
    if (this.value > other.value) {
      return Ordering.Greater;
    }
    return Ordering.Less;
  }
  ge(other) {
    return default_partial_ord(this).ge(other);
  }
  gt(other) {
    return default_partial_ord(this).gt(other);
  }
  le(other) {
    return default_partial_ord(this).le(other);
  }
  lt(other) {
    return default_partial_ord(this).gt(other);
  }
  clamp(min2, max2) {
    [min2, max2] = [size(min2), size(max2)];
    if (this.lt(min2)) {
      return min2;
    }
    if (this.gt(max2)) {
      return max2;
    }
    return this;
  }
  cmp(other) {
    return this.partial_cmp(other);
  }
  max(other) {
    if (this.lt(other)) {
      return other;
    }
    return this;
  }
  min(other) {
    if (this.gt(other)) {
      return other;
    }
    return this;
  }
};
var size = staticify(SizeImpl);

// src/std/number/index.ts
var number_exports = {};
__export(number_exports, {
  consts: () => consts,
  f64: () => f64,
  i128: () => i128,
  i16: () => i16,
  i32: () => i32,
  i64: () => i64,
  i8: () => i8,
  isize: () => isize,
  u128: () => u128,
  u16: () => u16,
  u32: () => u32,
  u64: () => u64,
  u8: () => u8,
  usize: () => usize
});

// src/std/number/f64.ts
var _F64Impl = class {
  value;
  constructor(value) {
    this.value = Number(value);
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  valueOf() {
    return this.value;
  }
  static new(value) {
    return new this(value);
  }
  fmt_debug() {
    if (this.value % 1 === this.value) {
      return this.fmt_display() + ".0";
    }
    return String(this.value);
  }
  fmt_display() {
    return String(this.value);
  }
  fmt_lower_exp() {
    return this.value.toExponential();
  }
  fmt_upper_exp() {
    return this.value.toExponential().toUpperCase();
  }
  fmt_signed() {
    return this.value >= 0 ? "+" : "-";
  }
  fmt_precision(precision) {
    return this.value.toPrecision(precision);
  }
  map(f) {
    this.value = f(this.value);
    return this;
  }
  floor() {
    return this.map(Math.floor);
  }
  ceil() {
    return this.map(Math.ceil);
  }
  round() {
    return this.map(Math.round);
  }
  trunc() {
    return this.map(Math.trunc);
  }
  fract() {
    return this.map((x) => x - +this.trunc());
  }
  abs() {
    return this.map(Math.abs);
  }
  signum() {
    if (+this < 0) {
      return new f64(-1);
    }
    if (+this === 0) {
      return new f64(0);
    }
    return new f64(1);
  }
  copysign(sign) {
    sign = f64(sign);
    if (this.signum() === sign.signum()) {
      return this;
    }
    this.value = -this.value;
    return this;
  }
  mul_add(a, b) {
    a = f64(a);
    b = f64(b);
    return this.map((x) => x * +a + +b);
  }
  div_euclid(rhs) {
    rhs = f64(rhs);
    const q = f64(+this / +rhs).trunc();
    if (+this % +rhs < 0) {
      if (+rhs > 0) {
        return q.map((x) => x - 1);
      }
      return q.map((x) => x + 1);
    }
    return q;
  }
  rem_euclid(rhs) {
    rhs = f64(rhs);
    const r = this.value % rhs.value;
    if (r < 0) {
      return f64(r).map((x) => x + +rhs.abs());
    }
    return f64(r);
  }
  powi(n) {
    n = f64(n).trunc();
    return this.powf(n);
  }
  powf(n) {
    n = f64(n);
    return this.map((x) => Math.pow(x, +n));
  }
  sqrt() {
    if (this.value < 0) {
      return this.map(() => NaN);
    }
    return this.map(Math.sqrt);
  }
  exp() {
    return this.map(Math.exp);
  }
  exp2() {
    return f64(2).powf(this);
  }
  ln() {
    return this.map(Math.log);
  }
  log(base) {
    base = f64(base);
    return f64(+this.ln() / +base.ln());
  }
  log2() {
    return this.log(2);
  }
  log10() {
    return this.log(10);
  }
  cbrt() {
    return this.powf(1 / 3);
  }
  hypot(other) {
    other = f64(other);
    return this.map((x) => Math.hypot(x, +other));
  }
  sin() {
    return this.map(Math.sin);
  }
  cos() {
    return this.map(Math.cos);
  }
  tan() {
    return this.map(Math.tan);
  }
  asin() {
    return this.map(Math.asin);
  }
  acos() {
    return this.map(Math.acos);
  }
  atan() {
    return this.map(Math.atan);
  }
  atan2(other) {
    other = f64(other);
    return this.map((x) => Math.atan2(+other, x));
  }
  sincos() {
    return [this.sin(), this.cos()];
  }
  exp_m1() {
    return this.map(Math.expm1);
  }
  ln1p() {
    return this.map(Math.log1p);
  }
  sinh() {
    return this.map(Math.sinh);
  }
  cosh() {
    return this.map(Math.cosh);
  }
  tanh() {
    return this.map(Math.tanh);
  }
  asinh() {
    return this.map(Math.asinh);
  }
  acosh() {
    return this.map(Math.acosh);
  }
  atanh() {
    return this.map(Math.atanh);
  }
  is_nan() {
    return +this != +this;
  }
  is_infinity() {
    return +this === Infinity || +this === -Infinity;
  }
  is_finite() {
    return this.is_nan() || !this.is_infinity();
  }
  // is_subnormal
  is_normal() {
    return this.is_finite() && this.value !== 0;
  }
  // classify
  is_sign_positive() {
    return this.value > 0;
  }
  is_sign_negative() {
    return this.value < 0;
  }
  // next_up, next_down
  recip() {
    return this.map((x) => 1 / x);
  }
  to_degrees() {
    return this.map((x) => x * (180 / +consts.pi));
  }
  to_radians() {
    return this.map((x) => x * (+consts.pi / 180));
  }
  maximum(other) {
    other = f64(other);
    if (this.is_nan() || other.is_nan().valueOf()) {
      return _F64Impl.nan;
    }
    return this.max(other);
  }
  minimum(other) {
    other = f64(other);
    if (this.is_nan() || other.is_nan().valueOf()) {
      return _F64Impl.nan;
    }
    return this.min(other);
  }
  total_cmp(other) {
    other = f64(other);
    if (this.is_sign_negative()) {
      if (this.is_nan()) {
        if (other.is_sign_negative() && this.is_nan()) {
          return Ordering.Equal;
        }
        return Ordering.Less;
      }
      if (this.is_infinity()) {
        if (other.is_sign_negative() && this.is_infinity()) {
          return Ordering.Equal;
        }
        return Ordering.Less;
      }
      if (other.is_sign_negative()) {
        return this.cmp(other);
      }
    }
    if (this.eq(0)) {
      if (other.eq(0)) {
        return Ordering.Equal;
      }
      return Ordering.Less;
    }
    if (other.is_infinity()) {
      if (this.is_infinity()) {
        return Ordering.Equal;
      }
      return Ordering.Less;
    }
    if (other.is_nan()) {
      if (this.is_nan()) {
        return Ordering.Equal;
      }
      return Ordering.Less;
    }
    return this.partial_cmp(other);
  }
  // PartialEq
  eq(other) {
    other = f64(other);
    return +this === +other;
  }
  ne(other) {
    return default_partial_eq(this).ne(other);
  }
  // PartialOrd
  partial_cmp(other) {
    other = f64(other);
    if (this.eq(other)) {
      return Ordering.Equal;
    }
    if (+this > +other) {
      return Ordering.Greater;
    }
    return Ordering.Less;
  }
  ge(other) {
    return default_partial_ord(this).ge(other);
  }
  gt(other) {
    return default_partial_ord(this).gt(other);
  }
  le(other) {
    return default_partial_ord(this).le(other);
  }
  lt(other) {
    return default_partial_ord(this).lt(other);
  }
  // Ord
  clamp(min2, max2) {
    if (this.lt(min2)) {
      return f64(min2);
    }
    if (this.gt(max2)) {
      return f64(max2);
    }
    return this;
  }
  cmp(other) {
    return this.partial_cmp(other);
  }
  max(other) {
    if (this.lt(other)) {
      return f64(other);
    }
    return this;
  }
  min(other) {
    if (this.gt(other)) {
      return f64(other);
    }
    return this;
  }
  // std::ops
  add(other) {
    return f64(+this + +f64(other));
  }
  add_assign(other) {
    return this.map(() => +this.add(other));
  }
  clone() {
    return f64(this);
  }
  static default() {
    return f64(0);
  }
  div(other) {
    return f64(+this / +f64(other));
  }
  div_assign(other) {
    return this.map(() => +this.div(other));
  }
  mul(other) {
    return f64(+this * +f64(other));
  }
  mul_assign(other) {
    return this.map(() => +this.mul(other));
  }
  neg() {
    return this.map((x) => -x);
  }
  rem(other) {
    return f64(+this % +f64(other));
  }
  rem_assign(other) {
    return this.map(() => +this.rem(other));
  }
  sub(other) {
    return f64(+this - +f64(other));
  }
  sub_assign(other) {
    return this.map(() => +this.sub(other));
  }
};
var F64Impl = _F64Impl;
__publicField(F64Impl, "radix", 2n);
__publicField(F64Impl, "mantissa_digits", 53n);
__publicField(F64Impl, "digits", 15n);
__publicField(F64Impl, "epsilon", new _F64Impl(2220446049250313e-31));
__publicField(F64Impl, "min", new _F64Impl(-17976931348623157e292));
__publicField(F64Impl, "min_positive", new _F64Impl(22250738585072014e-324));
__publicField(F64Impl, "max", new _F64Impl(17976931348623157e292));
__publicField(F64Impl, "min_exp", -1021n);
__publicField(F64Impl, "max_exp", 1024n);
__publicField(F64Impl, "min_10_exp", -307n);
__publicField(F64Impl, "max_10_exp", 308n);
__publicField(F64Impl, "nan", new _F64Impl(NaN));
__publicField(F64Impl, "infinity", new _F64Impl(Infinity));
__publicField(F64Impl, "neg_infinity", new _F64Impl(-Infinity));
var f64 = staticify(F64Impl);
var consts;
((consts2) => {
  consts2.pi = f64(3.141592653589793);
  consts2.tau = f64(6.283185307179586);
  consts2.frac_pi_2 = f64(1.570796326794896);
  consts2.frac_pi_3 = f64(1.047197551196597);
  consts2.frac_pi_4 = f64(0.7853981633974483);
  consts2.frac_pi_6 = f64(0.523598775598298);
  consts2.frac_pi_8 = f64(0.392699081698724);
  consts2.frac_1_pi = f64(0.3183098861837906);
  consts2.frac_2_pi = f64(0.6366197723675813);
  consts2.frac_2_sqrt_pi = f64(1.128379167095512);
  consts2.sqrt_2 = f64(1.414213562373095);
  consts2.frac_1_sqrt_2 = f64(0.7071067811865475);
  consts2.e = f64(2.71828182845904);
  consts2.log2_10 = f64(3.321928094887362);
  consts2.log2_e = f64(1.442695040888963);
  consts2.log10_2 = f64(0.3010299956639811);
  consts2.log10_e = f64(0.4342944819032518);
  consts2.ln_2 = f64(0.6931471805599453);
  consts2.ln_10 = f64(2.302585092994045);
})(consts || (consts = {}));

// src/std/number/int_sized.ts
var IntSizedImpl = class extends SizeImpl {
  constructor(value, bits, unsigned) {
    super(value);
    this.bits = bits;
    this.unsigned = unsigned;
    if (unsigned) {
      this.umin = 0n;
      this.umax = (1n << bits) - 1n;
    } else {
      this.umin = -(1n << bits);
      this.umax = (1n << bits) - 1n;
    }
    const n = unsigned ? "u" : "i";
    if (this.valueOf() < this.umin || this.valueOf() > this.umax) {
      panic(
        `the literal \`${value}${n}${bits}\` does not fit into the type \`${n}${bits}\` whose range is \`${this.umin}..=${this.umax}\``
      );
    }
  }
  umin;
  umax;
  get bound() {
    return [this.umin, this.umax];
  }
  static new(value, bits, unsigned) {
    return new this(value, bits, unsigned);
  }
  fit(v) {
    return new IntSizedImpl(v, this.bits, this.unsigned);
  }
  abs() {
    return this.fit(super.abs(this.umax));
  }
  abs_diff(other) {
    return this.fit(super.abs_diff(other, this.umax));
  }
  add(other) {
    return this.fit(super.add(other));
  }
  add_assign(other) {
    return this.fit(super.add_assign(other));
  }
  as_primitive() {
    return super.as_primitive();
  }
  bitand(other) {
    return this.fit(super.bitand(other));
  }
  bitand_assign(other) {
    return this.fit(super.bitand_assign(other));
  }
  bitor(other) {
    return this.fit(super.bitor(other));
  }
  bitor_assign(other) {
    return this.fit(super.bitor_assign(other));
  }
  bitxor(other) {
    return this.fit(super.bitxor(other));
  }
  bitxor_assign(other) {
    return this.fit(super.bitxor_assign(other));
  }
  clamp(min2, max2) {
    return this.fit(super.clamp(min2, max2));
  }
  clone() {
    return new IntSizedImpl(this.value, this.bits, this.unsigned);
  }
  count_ones() {
    return this.fit(super.count_ones(this.bits));
  }
  count_zeros() {
    return this.fit(super.count_zeros(this.bits));
  }
  div(other) {
    return this.fit(super.div(other));
  }
  div_assign(other) {
    return this.fit(super.div_assign(other));
  }
  eq(other) {
    return super.eq(other);
  }
  ge(other) {
    return super.ge(other);
  }
  gt(other) {
    return super.gt(other);
  }
  le(other) {
    return super.le(other);
  }
  lt(other) {
    return super.lt(other);
  }
  leading_ones() {
    return this.fit(super.leading_ones(this.bits));
  }
  leading_zeros() {
    return this.fit(super.leading_zeros(this.bits));
  }
  trailing_ones() {
    return this.fit(super.trailing_ones(this.bits));
  }
  trailing_zeros() {
    return this.fit(super.trailing_zeros(this.bits));
  }
  map(f) {
    return super.map(f);
  }
  max(other) {
    return this.fit(super.max(other));
  }
  min(other) {
    return this.fit(super.max(other));
  }
  mul(other) {
    return this.fit(super.mul(other));
  }
  mul_assign(other) {
    return this.fit(super.mul_assign(other));
  }
  n_bit_mask(n) {
    return this.fit(super.n_bit_mask(n));
  }
  ne(other) {
    return super.ne(other);
  }
  neg() {
    return this.fit(super.neg());
  }
  next_multiple_of(rhs) {
    return this.fit(super.next_multiple_of(rhs, [this.umin, this.umax]));
  }
  not() {
    return this.fit(super.not());
  }
  pow(exp) {
    return this.fit(super.pow(exp, this.bound));
  }
  rem(other) {
    return this.fit(super.rem(other));
  }
  rem_assign(other) {
    return this.fit(super.rem_assign(other));
  }
  reverse_bits() {
    return this.fit(super.reverse_bits(this.bits));
  }
  rotate_left(n) {
    return this.fit(super.rotate_left(n, this.bits));
  }
  rotate_right(n) {
    return this.fit(super.rotate_right(n, this.bits));
  }
  saturate(value) {
    return this.fit(super.saturate(value, this.bound));
  }
  saturating_add(rhs) {
    return this.fit(super.saturating_add(rhs, this.bound));
  }
  saturating_div(rhs) {
    return this.fit(super.saturating_add(rhs, this.bound));
  }
  saturating_mul(rhs) {
    return this.fit(super.saturating_add(rhs, this.bound));
  }
  saturating_neg() {
    return this.fit(super.saturating_neg(this.bound));
  }
  saturating_op(rhs, x) {
    return this.fit(super.saturating_op(rhs, x, this.bound));
  }
  saturating_pow(rhs) {
    return this.fit(super.saturating_pow(rhs, this.bound));
  }
  saturating_sub(rhs) {
    return this.fit(super.saturating_sub(rhs, this.bound));
  }
  shl(other) {
    return this.fit(super.shl(other));
  }
  shl_assign(other) {
    return this.fit(super.shl_assign(other));
  }
  shr(other) {
    return this.fit(super.shr(other));
  }
  shr_assign(other) {
    return this.fit(super.shr_assign(other));
  }
  signum() {
    return this.fit(super.signum());
  }
  sub(other) {
    return this.fit(super.sub(other));
  }
  sub_assign(other) {
    return this.fit(super.sub_assign(other));
  }
  swap_bytes() {
    return this.fit(super.swap_bytes(this.bits));
  }
  unchecked_abs() {
    return super.unchecked_abs();
  }
  unchecked_add(rhs) {
    return super.unchecked_add(rhs);
  }
  unchecked_mul(rhs) {
    return super.unchecked_mul(rhs);
  }
  unchecked_neg() {
    return super.unchecked_neg();
  }
  unchecked_op(rhs, x) {
    return super.unchecked_op(rhs, x);
  }
  unchecked_pow(rhs) {
    return super.unchecked_pow(rhs);
  }
  unchecked_shl(rhs) {
    return super.unchecked_shl(rhs);
  }
  unchecked_shr(rhs) {
    return super.unchecked_shr(rhs);
  }
  unchecked_sub(rhs) {
    return super.unchecked_sub(rhs);
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  valueOf() {
    return this.value;
  }
  wrapping(value) {
    return this.fit(super.wrapping(value, this.bound));
  }
  wrapping_abs() {
    return this.fit(super.wrapping_abs(this.bound));
  }
  wrapping_add(rhs) {
    return this.fit(super.wrapping_add(rhs, this.bound));
  }
  wrapping_div(rhs) {
    return this.fit(super.wrapping_div(rhs, this.bound));
  }
  wrapping_mul(rhs) {
    return this.fit(super.wrapping_mul(rhs, this.bound));
  }
  wrapping_neg() {
    return this.fit(super.wrapping_neg(this.bound));
  }
  wrapping_op(rhs, x) {
    return this.fit(super.wrapping_op(rhs, x, this.bound));
  }
  wrapping_pow(rhs) {
    return this.fit(super.wrapping_pow(rhs, this.bound));
  }
  wrapping_rem(rhs) {
    return this.fit(super.wrapping_rem(rhs, this.bound));
  }
  wrapping_sub(rhs) {
    return this.fit(super.wrapping_sub(rhs, this.bound));
  }
  checked(value) {
    return super.checked(value, this.bound).map((x) => this.fit(x));
  }
  checked_abs() {
    return super.checked_abs().map((x) => this.fit(x));
  }
  checked_add(rhs) {
    return super.checked_add(rhs).map((x) => this.fit(x));
  }
  checked_div(rhs) {
    return super.checked_div(rhs).map((x) => this.fit(x));
  }
  checked_mul(rhs) {
    return super.checked_mul(rhs).map((x) => this.fit(x));
  }
  checked_neg() {
    return super.checked_neg().map((x) => this.fit(x));
  }
  checked_next_multiple_of(rhs) {
    return super.checked_next_multiple_of(rhs, this.bound).map((x) => this.fit(x));
  }
  checked_op(rhs, x) {
    return super.checked_op(rhs, x, this.bound).map((x2) => this.fit(x2));
  }
  checked_pow(rhs) {
    return super.checked_pow(rhs, this.bound).map((x) => this.fit(x));
  }
  checked_rem(rhs) {
    return super.checked_rem(rhs, this.bound).map((x) => this.fit(x));
  }
  checked_shl(rhs) {
    return super.checked_shl(rhs, this.bits).map((x) => this.fit(x));
  }
  checked_shr(rhs) {
    return super.checked_shr(rhs, this.bits).map((x) => this.fit(x));
  }
  checked_sub(rhs) {
    return super.checked_sub(rhs, this.bound).map((x) => this.fit(x));
  }
  cmp(other) {
    return super.cmp(other);
  }
  partial_cmp(other) {
    return super.partial_cmp(other);
  }
  is_negative() {
    return super.is_negative();
  }
  is_positive() {
    return super.is_positive();
  }
  overflowing(value) {
    const [p, b] = super.overflowing(value, this.bound);
    return [this.fit(p), b];
  }
  fix_overflow(v) {
    return [this.fit(v[0]), v[1]];
  }
  overflowing_abs() {
    return this.fix_overflow(super.overflowing_abs(this.bound));
  }
  overflowing_add(rhs) {
    return this.fix_overflow(super.overflowing_add(rhs, this.bound));
  }
  overflowing_div(rhs) {
    return this.fix_overflow(super.overflowing_add(rhs, this.bound));
  }
  overflowing_mul(rhs) {
    return this.fix_overflow(super.overflowing_add(rhs, this.bound));
  }
  overflowing_neg() {
    return this.fix_overflow(super.overflowing_neg(this.bound));
  }
  overflowing_op(rhs, x) {
    return this.fix_overflow(super.overflowing_op(rhs, x, this.bound));
  }
  overflowing_pow(rhs) {
    return this.fix_overflow(super.overflowing_pow(rhs, this.bound));
  }
  overflowing_rem(rhs) {
    return this.fix_overflow(super.overflowing_rem(rhs, this.bound));
  }
  overflowing_sub(rhs) {
    return this.fix_overflow(super.overflowing_sub(rhs, this.bound));
  }
};
staticify(IntSizedImpl);

// src/std/number/i128.ts
var I128 = class extends IntSizedImpl {
  constructor(value) {
    super(value, 128n, false);
  }
  static new(value) {
    return new this(value);
  }
};
var i128 = staticify(I128);

// src/std/number/i16.ts
var I16 = class extends IntSizedImpl {
  constructor(value) {
    super(value, 16n, false);
  }
  static new(value) {
    return new this(value);
  }
};
var i16 = staticify(I16);

// src/std/number/i32.ts
var I32 = class extends IntSizedImpl {
  constructor(value) {
    super(value, 32n, false);
  }
  static new(value) {
    return new this(value);
  }
};
var i32 = staticify(I32);

// src/std/number/i64.ts
var I64 = class extends IntSizedImpl {
  constructor(value) {
    super(value, 64n, false);
  }
  static new(value) {
    return new this(value);
  }
};
var i64 = staticify(I64);

// src/std/number/i8.ts
var I8 = class extends IntSizedImpl {
  constructor(value) {
    super(value, 8n, false);
  }
  static new(value) {
    return new this(value);
  }
};
var i8 = staticify(I8);

// src/std/number/isize.ts
var ISize = class extends IntSizedImpl {
  constructor(value) {
    super(value, 64n, false);
  }
  static new(value) {
    return new this(value);
  }
};
var isize = staticify(ISize);

// src/std/number/u128.ts
var U128 = class extends IntSizedImpl {
  constructor(value) {
    super(value, 128n, true);
  }
  static new(value) {
    return new this(value);
  }
};
var u128 = staticify(U128);

// src/std/number/u16.ts
var U16 = class extends IntSizedImpl {
  constructor(value) {
    super(value, 16n, true);
  }
  static new(value) {
    return new this(value);
  }
};
var u16 = staticify(U16);

// src/std/number/u32.ts
var U32 = class extends IntSizedImpl {
  constructor(value) {
    super(value, 32n, true);
  }
  static new(value) {
    return new this(value);
  }
};
var u32 = staticify(U32);

// src/std/number/u64.ts
var U64 = class extends IntSizedImpl {
  constructor(value) {
    super(value, 64n, true);
  }
  static new(value) {
    return new this(value);
  }
};
var u64 = staticify(U64);

// src/std/number/u8.ts
var U8 = class extends IntSizedImpl {
  constructor(value) {
    super(value, 8n, true);
  }
  static new(value) {
    return new this(value);
  }
  is_utf8_char_boundary() {
    return this.lt(128) || this.ge(192);
  }
};
var u8 = staticify(U8);

// src/std/number/usize.ts
var USize = class extends IntSizedImpl {
  constructor(value) {
    super(value, 64n, true);
  }
  static new(value) {
    return new this(value);
  }
};
var usize = staticify(USize);

// src/std/iter/iterator.ts
var IteratorImpl = class {
  constructor(iter = []) {
    this.dyn = iter[Symbol.iterator]();
  }
  *[Symbol.iterator]() {
    let p = this.next();
    while (p.is_some()) {
      yield p.unwrap();
      p = this.next();
    }
  }
  static new(iter) {
    return new this(iter);
  }
  iter() {
    return this;
  }
  dyn;
  picker = 0;
  next() {
    this.picker++;
    const { value, done } = this.dyn.next();
    if (done) {
      return None;
    }
    return Some(value);
  }
  next_chunk(count) {
    const chunk = [];
    for (let i = 0; i < count; i++) {
      const value = this.next();
      if (value.is_none()) {
        return Err(this);
      }
      chunk.push(value.unwrap());
    }
    return Ok(chunk);
  }
  size_hint() {
    return [this.picker, Some(this.count())];
  }
  count() {
    let count = 0;
    while (this.next().is_some()) {
      count++;
    }
    return count;
  }
  last() {
    let c = None;
    let p = this.next();
    while (p.is_some()) {
      c = p;
      p = this.next();
    }
    return c;
  }
  advance_by(n) {
    for (let i = 0; i < n; i++) {
      const v = this.next();
      if (v.is_none()) {
        return Err(i);
      }
    }
    return Ok();
  }
  nth(n) {
    let c = None;
    for (let i = 0; i < n; i++) {
      c = this.next();
    }
    return c;
  }
  step_by(step) {
    return StepBy(step, this);
  }
  chain(iter) {
    return Chain(this, iter);
  }
  zip(iter) {
    return Zip(this, iter);
  }
  intersperse(separator) {
    return Intersperse(this, separator);
  }
  intersperse_with(separator) {
    return IntersperseWith(this, separator);
  }
  map(f) {
    return Map2(this, f);
  }
  for_each(f) {
    for (const value of this) {
      f(value);
    }
    return this;
  }
  filter(f) {
    return Filter(this, f);
  }
  filter_map(f) {
    return FilterMap(this, f);
  }
  enumerate() {
    return Enumerate(this);
  }
  peekable() {
    return Peekable(this);
  }
  skip_while(p) {
    return SkipWhile(this, p);
  }
  take_while(p) {
    return TakeWhile(this, p);
  }
  map_while(p) {
    return MapWhile(this, p);
  }
  skip(n) {
    return Skip(this, n);
  }
  take(n) {
    return Take(this, n);
  }
  scan(initial_state, f) {
    return Scan(this, initial_state, f);
  }
  flat_map(f) {
    return FlatMap(this, f);
  }
  flatten() {
    return Flatten(this);
  }
  fuse() {
    return Fuse(this);
  }
  inspect(f) {
    return Inspect(this, f);
  }
  // collect
  collect_into(into) {
    return into.from_iter(this);
  }
  fold(init, f) {
    for (const value of this) {
      init = f(init, value);
    }
    return init;
  }
  reduce(f) {
    const next = this.next();
    if (next.is_none()) {
      return None;
    }
    return Some(this.fold(next.unwrap(), f));
  }
  all(f) {
    for (const value of this) {
      if (!f(value)) {
        return false;
      }
    }
    return true;
  }
  any(f) {
    for (const value of this) {
      if (f(value)) {
        return true;
      }
    }
    return false;
  }
  find(predicate) {
    for (const value of this) {
      if (predicate(value)) {
        return Some(value);
      }
    }
    return None;
  }
  find_map(f) {
    return this.filter_map(f).next();
  }
  position(predicate) {
    let index = 0;
    for (const value of this) {
      if (predicate(value)) {
        return Some(index);
      }
      index++;
    }
    return None;
  }
  cycle() {
    return Cycle(this);
  }
  array_chunks(size2) {
    return ArrayChunks(this, size2);
  }
  sum() {
    return this.reduce((t, u) => {
      if ("add" in t) {
        return t.add(u);
      }
    });
  }
  product() {
    return this.reduce((t, u) => {
      if ("mul" in t) {
        return t.mul(u);
      }
    });
  }
};
var Iterator = staticify(IteratorImpl);
var ArrayChunksImpl = class extends IteratorImpl {
  constructor(iter, size2) {
    if (size2 <= 0) {
      panic("ArrayChunks<T, N> failed due to unmet bound: N > 0");
    }
    super(
      function* () {
        let o = [];
        for (const value of iter) {
          if (o.length > size2) {
            yield Iterator(o);
            o = [];
          }
          o.push(value);
        }
        yield Iterator(o);
      }()
    );
  }
  static new(iter, size2) {
    return new this(iter, size2);
  }
};
var ArrayChunks = staticify(ArrayChunksImpl);
var ChainImpl = class extends IteratorImpl {
  constructor(start, end) {
    super(
      function* () {
        for (const p of start) {
          yield p;
        }
        for (const p of end) {
          yield p;
        }
      }()
    );
  }
  next() {
    return super.next();
  }
  static new(start, end) {
    return new this(start, end);
  }
};
var Chain = staticify(ChainImpl);
var CycleImpl = class extends IteratorImpl {
  constructor(iter) {
    super(
      function* () {
        while (1 / 1) {
          for (const value of Object.assign({}, iter)) {
            yield value;
          }
        }
      }()
    );
  }
  static new(iter) {
    return new this(iter);
  }
};
var Cycle = staticify(CycleImpl);
var DoubleEndedIteratorImpl = class extends IteratorImpl {
  constructor(iter) {
    super(iter);
  }
  rev() {
    return new DoubleEndedIteratorImpl(
      Array.from(this).reverse()
    );
  }
  next_back() {
    return this.rev().next();
  }
  advance_back_by(n) {
    return this.rev().advance_by(n);
  }
  nth_back(n) {
    return this.rev().nth(n);
  }
  rfold(init, f) {
    return this.rev().fold(init, f);
  }
  rfind(predicate) {
    return this.rev().find(predicate);
  }
  rposition(predicate) {
    return this.rev().position(predicate);
  }
  static new(iter) {
    return new this(iter);
  }
};
var DoubleEndedIterator = staticify(DoubleEndedIteratorImpl);
var EmptyImpl = class extends IteratorImpl {
  constructor() {
    super();
  }
  static new() {
    return new this();
  }
};
var Empty = staticify(EmptyImpl);
var EnumerateImpl = class extends IteratorImpl {
  constructor(iter) {
    let i = 0;
    super(
      function* () {
        for (const value of iter) {
          yield [i++, value];
        }
      }()
    );
  }
  static new(iter) {
    return new this(iter);
  }
};
var Enumerate = staticify(EnumerateImpl);
var ExactSizeIteratorImpl = class extends IteratorImpl {
  constructor(iter, size2) {
    super(
      function* () {
        let i = 0;
        for (const value of iter) {
          if (i++ <= size2) {
            yield value;
          }
        }
      }()
    );
    this.size = size2;
  }
  len() {
    return this.size;
  }
  is_empty() {
    return this.size === 0;
  }
  static new(iter, size2) {
    return new this(iter, size2);
  }
};
var ExactSizeIterator = staticify(ExactSizeIteratorImpl);
var FilterMapImpl = class extends IteratorImpl {
  constructor(iter, f) {
    const p = iter[Symbol.iterator]();
    super(
      function* () {
        const item = p.next();
        if (!item.done) {
          const output = f(item.value);
          if (output.is_some()) {
            yield output.unwrap();
          }
        }
      }()
    );
  }
  static new(iter, f) {
    return new this(iter, f);
  }
};
var FilterMap = staticify(FilterMapImpl);
var FilterImpl = class extends IteratorImpl {
  constructor(iter, f) {
    const p = iter[Symbol.iterator]();
    super(
      function* () {
        const item = p.next();
        if (f(item.value)) {
          yield item.value;
        }
      }()
    );
  }
  static new(iter, f) {
    return new this(iter, f);
  }
};
var Filter = staticify(FilterImpl);
var FlatMapImpl = class extends IteratorImpl {
  constructor(iter, f) {
    super(
      function* () {
        for (const item of iter) {
          for (const value of f(item)) {
            yield value;
          }
        }
      }()
    );
  }
  static new(iter, f) {
    return new this(iter, f);
  }
};
var FlatMap = staticify(FlatMapImpl);
var FlattenImpl = class extends IteratorImpl {
  constructor(iter) {
    super(
      function* () {
        for (const value of iter) {
          if (typeof value === "object" && Symbol.iterator in value) {
            for (const item of value) {
              yield item;
            }
            continue;
          }
          yield value;
        }
      }()
    );
  }
  static new(iter) {
    return new this(iter);
  }
};
var Flatten = staticify(FlattenImpl);
function empty() {
  return Empty();
}
function from_fn(F) {
  return FromFn(F);
}
function once(T) {
  return Once(T);
}
function once_with(F) {
  return OnceWith(F);
}
function repeat(T) {
  return Repeat(T);
}
function repeat_with(F) {
  return RepeatWith(F);
}
function successors(first, F) {
  return Successors(first, F);
}
function zip(A, B) {
  return Zip(A, B);
}
var FromFnImpl = class extends IteratorImpl {
  constructor(fn) {
    super(
      function* () {
        while (1 / 1) {
          const value = fn();
          if (value.is_none()) {
            break;
          }
          yield value.unwrap();
        }
      }()
    );
  }
  static new(fn) {
    return new this(fn);
  }
};
var FromFn = staticify(FromFnImpl);
var FuseImpl = class extends IteratorImpl {
  constructor(iter) {
    super(iter);
  }
  hit_none = false;
  next() {
    if (this.hit_none) {
      return None;
    }
    const raw = super.next();
    if (raw.is_none()) {
      this.hit_none = true;
    }
    return raw;
  }
  static new(iter) {
    return new this(iter);
  }
};
var Fuse = staticify(FuseImpl);
var InspectImpl = class extends IteratorImpl {
  constructor(iter, f) {
    super(
      function* () {
        for (const value of iter) {
          f(value);
          yield value;
        }
      }()
    );
  }
  static new(iter, f) {
    return new this(iter, f);
  }
};
var Inspect = staticify(InspectImpl);
var IntersperseWithImpl = class extends IteratorImpl {
  constructor(iter, separator) {
    const p = iter[Symbol.iterator]();
    super(
      function* () {
        const item = p.next();
        yield item.value;
        if (!item.done) {
          yield separator();
        }
      }()
    );
  }
  static new(iter, separator) {
    return new this(iter, separator);
  }
};
var IntersperseWith = staticify(IntersperseWithImpl);
var IntersperseImpl = class extends IteratorImpl {
  constructor(iter, separator) {
    const p = iter[Symbol.iterator]();
    super(
      function* () {
        const item = p.next();
        yield item.value;
        if (!item.done) {
          yield separator;
        }
      }()
    );
  }
  static new(iter, separator) {
    return new this(iter, separator);
  }
};
var Intersperse = staticify(IntersperseImpl);
var MapWhileImpl = class extends IteratorImpl {
  constructor(iter, predicate) {
    super(
      Iterator(iter).map((p) => predicate(p)).take_while((x) => x.is_some()).map((x) => x.unwrap())
    );
  }
  static new(iter, predicate) {
    return new this(iter, predicate);
  }
};
var MapWhile = staticify(MapWhileImpl);
var MapImpl = class extends IteratorImpl {
  constructor(iter, f) {
    const p = iter[Symbol.iterator]();
    super(
      function* () {
        const item = p.next();
        yield f(item.value);
      }()
    );
  }
  static new(iter, f) {
    return new this(iter, f);
  }
};
var Map2 = staticify(MapImpl);
var OnceImpl = class extends IteratorImpl {
  constructor(value) {
    super(
      function* () {
        yield value;
      }()
    );
  }
  static new(value) {
    return new this(value);
  }
};
var Once = staticify(OnceImpl);
var OnceWithImpl = class extends OnceImpl {
  constructor(fn) {
    super(fn());
  }
  static new(fn) {
    return new this(fn);
  }
};
var OnceWith = staticify(OnceWithImpl);
var PeekableImpl = class extends IteratorImpl {
  constructor(iter) {
    super(iter);
  }
  peek() {
    const clone = Object.assign({}, this[Symbol.iterator]());
    const item = clone.next();
    if (item.done) {
      return None;
    }
    return Some(item.value);
  }
  static new(iter) {
    return new this(iter);
  }
};
var Peekable = staticify(PeekableImpl);
var RepeatImpl = class extends IteratorImpl {
  constructor(value) {
    super(
      function* () {
        while (1 / 1) {
          yield value;
        }
      }()
    );
  }
  static new(value) {
    return new this(value);
  }
};
var Repeat = staticify(RepeatImpl);
var RepeatWithImpl = class extends RepeatImpl {
  constructor(fn) {
    super(fn());
  }
  static new(fn) {
    return new this(fn);
  }
};
var RepeatWith = staticify(RepeatWithImpl);
var ScanImpl = class extends IteratorImpl {
  constructor(iter, state, f) {
    super();
    this.state = state;
    this.f = f;
    this.i = iter[Symbol.iterator]();
  }
  i;
  next() {
    const input = this.i.next();
    if (input.done) {
      return None;
    }
    const [state, output] = this.f(this.state, input.value);
    this.state = state;
    if (output.is_none()) {
      return None;
    }
    return Some([state, output.unwrap()]);
  }
  static new(iter, initial_state, f) {
    return new this(iter, initial_state, f);
  }
};
var Scan = staticify(ScanImpl);
var SkipWhileImpl = class extends IteratorImpl {
  constructor(iter, predicate) {
    super(iter);
    this.predicate = predicate;
  }
  hit_true = false;
  next() {
    if (this.hit_true) {
      return None;
    }
    let value = super.next();
    while (value.is_some()) {
      if (this.predicate(value.unwrap())) {
        value = super.next();
      }
    }
    return value;
  }
  static new(iter, predicate) {
    return new this(iter, predicate);
  }
};
var SkipWhile = staticify(SkipWhileImpl);
var SkipImpl = class extends IteratorImpl {
  constructor(iter, n) {
    let i = 0;
    super(
      function* () {
        for (const item of iter) {
          if (i++ >= n) {
            yield item;
          }
        }
      }()
    );
  }
  static new(iter, n) {
    return new this(iter, n);
  }
};
var Skip = staticify(SkipImpl);
var StepByImpl = class extends IteratorImpl {
  constructor(step, iter) {
    super(iter);
    this.step = step;
  }
  next() {
    let c = super.next();
    for (let i = 1; i < this.step; i++) {
      c = super.next();
    }
    return c;
  }
  static new(step, iter) {
    return new this(step, iter);
  }
};
var StepBy = staticify(StepByImpl);
var SuccessorsImpl = class extends IteratorImpl {
  constructor(first, fn) {
    super(
      function* () {
        while (first.is_some()) {
          yield first.unwrap();
          first = fn(first.unwrap());
        }
      }()
    );
  }
  static new(first, fn) {
    return new this(first, fn);
  }
};
var Successors = staticify(SuccessorsImpl);
var TakeWhileImpl = class extends IteratorImpl {
  constructor(iter, predicate) {
    super(iter);
    this.predicate = predicate;
  }
  hit_false = false;
  next() {
    if (this.hit_false) {
      return None;
    }
    const value = super.next();
    if (value.is_some_and(this.predicate)) {
      return value;
    }
    return None;
  }
  static new(iter, predicate) {
    return new this(iter, predicate);
  }
};
var TakeWhile = staticify(TakeWhileImpl);
var TakeImpl = class extends IteratorImpl {
  constructor(iter, n) {
    let i = 0;
    super(
      function* () {
        for (const item of iter) {
          if (i++ <= n) {
            yield item;
          }
          break;
        }
      }()
    );
  }
  static new(iter, n) {
    return new this(iter, n);
  }
};
var Take = staticify(TakeImpl);
var ZipImpl = class extends IteratorImpl {
  t;
  u;
  constructor(T, U) {
    super([]);
    this.t = Iterator(T);
    this.u = Iterator(U);
  }
  next() {
    const p = this.t.next();
    const q = this.u.next();
    if (p.is_none() || q.is_none()) {
      return None;
    }
    return Some([p, q]);
  }
  unzip() {
    return [this.t, this.u];
  }
  static new(start, end) {
    return new this(start, end);
  }
};
var Zip = staticify(ZipImpl);

// src/std/char/decode_utf16_error.ts
var DecodeUtf16ErrorImpl = class extends Error {
  constructor(surrogate) {
    super(
      `Decoding UTF-16 string failed: unpaired surrogate \\u{${surrogate}}`
    );
    this.surrogate = surrogate;
  }
  unpaired_surrogate() {
    return this.surrogate;
  }
  static new(surrogate) {
    return new this(surrogate);
  }
};
var DecodeUtf16Error = staticify(DecodeUtf16ErrorImpl);

// src/std/char/decode_utf16.ts
var DecodeUtf16Impl = class extends IteratorImpl {
  constructor(iter) {
    super(
      function* () {
        for (let u of iter) {
          u = u16(u);
          try {
            yield Ok(char(String.fromCodePoint(Number(u))));
          } catch {
            yield Err(DecodeUtf16Error(u));
          }
        }
      }()
    );
  }
  static new(iter) {
    return new this(iter);
  }
};
var DecodeUtf16 = staticify(DecodeUtf16Impl);

// src/std/char/escape_debug.ts
var EscapeDebugImpl = class extends IteratorImpl {
  constructor(value) {
    const val = value.as_primitive();
    super(
      function* () {
        switch (val) {
          case "	":
            yield char("\\");
            yield char("t");
            break;
          case "\r":
            yield char("\\");
            yield char("r");
            break;
          case "\n":
            yield char("\\");
            yield char("n");
            break;
          case "'":
            yield char("\\");
            yield char("'");
            break;
          case '"':
            yield char("\\");
            yield char('"');
            break;
          case "\\":
            yield char("\\");
            yield char("\\");
            break;
          default:
            yield value;
            break;
        }
      }()
    );
  }
  static new(value) {
    return new this(value);
  }
};
var EscapeDebug = staticify(EscapeDebugImpl);

// src/std/char/escape_default.ts
var EscapeDefaultImpl = class extends IteratorImpl {
  constructor(value) {
    const point = value.codepoint();
    super(
      function* () {
        if (point >= 32 && point <= 126) {
          yield* value.escape_debug();
        }
        yield* value.escape_unicode();
      }()
    );
  }
  static new(value) {
    return new this(value);
  }
};
var EscapeDefault = staticify(EscapeDefaultImpl);

// src/std/char/escape_unicode.ts
var EscapeUnicodeImpl = class extends IteratorImpl {
  constructor(value) {
    const codepoint = value.codepoint().toString().padStart(4);
    super(
      function* () {
        yield char("\\");
        yield char("u");
        yield char("{");
        for (const digit of codepoint) {
          yield char(digit);
        }
        yield char("}");
      }()
    );
  }
  static new(value) {
    return new this(value);
  }
};
var EscapeUnicode = staticify(EscapeUnicodeImpl);

// src/std/char/char.ts
var _CharImpl = class {
  value;
  constructor(value) {
    if (typeof value === "number" || typeof value === "bigint") {
      value = size(value);
    }
    if (value instanceof SizeImpl) {
      value = String.fromCodePoint(value.into(Number));
    }
    this.value = value;
  }
  fmt_debug() {
    return `'${this.value}'`;
  }
  fmt_display() {
    return this.value;
  }
  static new(value) {
    return new this(value);
  }
  static decode_utf16(iter) {
    return DecodeUtf16(iter);
  }
  static from_u32(u322) {
    if (u322 < 0 || u322 > 2 ** 32) {
      panic("Invalid u32 value");
    }
    try {
      return Some(new this(String.fromCodePoint(u322)));
    } catch {
      return None;
    }
  }
  static from_u32_unchecked(u322) {
    return new this(String.fromCodePoint(u322));
  }
  static from_digit(u322, radix) {
    if (u322 < 0 || u322 > radix) {
      return None;
    }
    return Some(char(radii[u322]));
  }
  // ord
  clamp(min2, max2) {
    if (this.codepoint() < min2.codepoint()) {
      return min2;
    }
    if (this.codepoint() > max2.codepoint()) {
      return max2;
    }
    return this;
  }
  eq(other) {
    return this.codepoint() === other.codepoint();
  }
  ne(other) {
    return !this.eq(other);
  }
  partial_cmp(other) {
    if (this.eq(other)) {
      return Ordering.Equal;
    }
    if (this.codepoint() > other.codepoint()) {
      return Ordering.Greater;
    }
    return Ordering.Less;
  }
  cmp(other) {
    return this.partial_cmp(other);
  }
  ge(other) {
    return default_partial_ord(this).ge(other);
  }
  gt(other) {
    return default_partial_ord(this).gt(other);
  }
  le(other) {
    return default_partial_ord(this).le(other);
  }
  lt(other) {
    return default_partial_ord(this).lt(other);
  }
  max(other) {
    if (this.ge(other)) {
      return this;
    }
    return other;
  }
  min(other) {
    if (this.le(other)) {
      return this;
    }
    return other;
  }
  is_digit(radix) {
    const idx = radii.indexOf(this.value.toLowerCase());
    return idx > 0 && idx <= radix;
  }
  to_digit(radix) {
    if (this.is_digit(radix)) {
      return Some(radii.indexOf(this.value.toLowerCase()));
    }
    return None;
  }
  codepoint() {
    return this.value.codePointAt(0) || _CharImpl.replacement_char.codepoint();
  }
  as_primitive() {
    return this.value;
  }
  escape_unicode() {
    return EscapeUnicode(this);
  }
  escape_debug() {
    return EscapeDebug(this);
  }
  escape_default() {
    return EscapeDefault(this);
  }
  len_utf8() {
    return this.encode_utf8().length;
  }
  len_utf16() {
    return this.value.length;
  }
  encode_utf8() {
    const code = this.codepoint();
    if (code < 128) {
      return [u8(code)];
    }
    if (code < 2048) {
      return [u8(192 | code >> 6), u8(128 | code & 63)];
    }
    if (code < 55296 || code >= 57344) {
      return [
        u8(224 | code >> 12),
        u8(128 | code >> 6 & 63),
        u8(128 | code & 63)
      ];
    }
    const p = 65536 + ((code & 1023) << 10 | this.value.charCodeAt(1) & 1023);
    return [
      u8(240 | p << 18),
      u8(128 | p >> 12 & 63),
      u8(128 | code >> 6 & 63),
      u8(128 | code & 63)
    ];
  }
  encode_utf16() {
    return this.value.split("").map(
      (x) => u16(x.codePointAt(0) || _CharImpl.replacement_char.codepoint())
    );
  }
  is_category(...cats) {
    let p = false;
    for (const value of cats) {
      p = p || new RegExp(`\\p{${value}}`, "u").test(this.value);
    }
    return p;
  }
  is_alphabetic() {
    return this.is_category("Alphabetic");
  }
  is_lowercase() {
    return this.is_category("Lowercase");
  }
  is_uppercase() {
    return this.is_category("Uppercase");
  }
  is_whitespace() {
    return /\s/u.test(this.value);
  }
  is_alphanumeric() {
    return this.is_alphabetic() || this.is_numeric();
  }
  is_control() {
    return this.is_category("Cc");
  }
  is_numeric() {
    return this.is_category("Nd", "Nl", "No");
  }
  to_lowercase() {
    return new _CharImpl(this.value.toLowerCase());
  }
  to_uppercase() {
    return new _CharImpl(this.value.toUpperCase());
  }
  is_ascii() {
    return this.codepoint() < 255;
  }
  to_ascii_uppercase() {
    if (this.is_ascii().valueOf()) {
      return this.to_uppercase();
    }
    return this;
  }
  to_ascii_lowercase() {
    if (this.is_ascii().valueOf()) {
      return this.to_lowercase();
    }
    return this;
  }
  eq_ignore_ascii_case(other) {
    return this.to_ascii_lowercase().eq(other.to_ascii_lowercase());
  }
  make_ascii_uppercase() {
    this.value = this.to_ascii_uppercase().value;
    return this;
  }
  make_ascii_lowercase() {
    this.value = this.to_ascii_lowercase().value;
    return this;
  }
  is_ascii_alphabetic() {
    return this.is_ascii() && this.is_alphabetic();
  }
  is_ascii_uppercase() {
    return this.is_ascii() && this.is_uppercase();
  }
  is_ascii_lowercase() {
    return this.is_ascii() && this.is_lowercase();
  }
  is_ascii_digit() {
    return this.is_ascii() && this.is_numeric();
  }
  is_ascii_alphanumeric() {
    return this.is_ascii_alphabetic().valueOf() || this.is_ascii_digit().valueOf();
  }
  is_ascii_hexdigit() {
    return this.is_ascii_digit() || /[a-f]/i.test(this.value);
  }
  is_ascii_punctuation() {
    return this.is_ascii() && this.is_category("Punctuation");
  }
  is_ascii_graphic() {
    return this.is_ascii().valueOf() && this.clamp(char("!"), char("~")).eq(this);
  }
  is_ascii_whitespace() {
    return this.is_ascii() && this.is_whitespace();
  }
  is_ascii_control() {
    return this.is_ascii() && this.is_control();
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  toString() {
    return this.as_primitive();
  }
};
var CharImpl = _CharImpl;
__publicField(CharImpl, "max", new _CharImpl("\u{10FFFF}"));
__publicField(CharImpl, "replacement_char", new _CharImpl(
  "\uFFFD"
));
var char = staticify(CharImpl);

// src/std/char/types.ts
var types_exports = {};

// src/std/clone.ts
var clone_exports = {};

// src/std/collections/index.ts
var collections_exports = {};
__export(collections_exports, {
  HashMap: () => HashMap,
  HashSet: () => HashSet
});

// src/std/fmt.ts
var fmt_exports = {};
__export(fmt_exports, {
  Alignment: () => Alignment,
  DebugList: () => DebugList,
  DebugMap: () => DebugMap,
  DebugSet: () => DebugSet,
  DebugStruct: () => DebugStruct,
  DebugTuple: () => DebugTuple,
  Error: () => Error2,
  Formatter: () => Formatter
});

// src/std/macros.ts
var macros_exports = {};
__export(macros_exports, {
  assert: () => assert,
  assert_eq: () => assert_eq,
  assert_ne: () => assert_ne,
  cfg: () => cfg,
  column: () => column,
  compile_error: () => compile_error,
  concat: () => concat,
  dbg: () => dbg,
  debug_assert: () => debug_assert,
  debug_assert_eq: () => debug_assert_eq,
  debug_assert_ne: () => debug_assert_ne,
  env: () => env,
  eprint: () => eprint,
  eprintln: () => eprintln,
  file: () => file,
  format: () => format,
  format_args: () => format_args,
  include: () => include,
  is_node: () => is_node,
  is_x86_feature_detected: () => is_x86_feature_detected,
  line: () => line,
  module_path: () => module_path,
  option_env: () => option_env,
  panic: () => panic,
  print: () => print,
  println: () => println,
  stringify: () => stringify,
  todo: () => todo,
  unimplemented: () => unimplemented,
  unreachable: () => unreachable,
  vec: () => vec
});

// src/std/iter/index.ts
var iter_exports = {};
__export(iter_exports, {
  ArrayChunks: () => ArrayChunks,
  Chain: () => Chain,
  Cycle: () => Cycle,
  DoubleEndedIterator: () => DoubleEndedIterator,
  Empty: () => Empty,
  Enumerate: () => Enumerate,
  ExactSizeIterator: () => ExactSizeIterator,
  Filter: () => Filter,
  FilterMap: () => FilterMap,
  FlatMap: () => FlatMap,
  Flatten: () => Flatten,
  FromFn: () => FromFn,
  Fuse: () => Fuse,
  Inspect: () => Inspect,
  Intersperse: () => Intersperse,
  IntersperseWith: () => IntersperseWith,
  Iterator: () => Iterator,
  IteratorImpl: () => IteratorImpl,
  Map: () => Map2,
  MapWhile: () => MapWhile,
  Once: () => Once,
  OnceWith: () => OnceWith,
  Peekable: () => Peekable,
  Repeat: () => Repeat,
  RepeatWith: () => RepeatWith,
  Scan: () => Scan,
  Skip: () => Skip,
  SkipWhile: () => SkipWhile,
  StepBy: () => StepBy,
  Successors: () => Successors,
  Take: () => Take,
  TakeWhile: () => TakeWhile,
  Zip: () => Zip,
  empty: () => empty,
  from_fn: () => from_fn,
  once: () => once,
  once_with: () => once_with,
  repeat: () => repeat,
  repeat_with: () => repeat_with,
  successors: () => successors,
  zip: () => zip
});

// src/std/vec/into_iter.ts
var IntoIterImpl = class extends IteratorImpl {
  constructor(value) {
    super(value);
  }
  static new(vec2) {
    return new this(vec2);
  }
};
var IntoIter = staticify(IntoIterImpl);

// src/std/slice/chunks.ts
var ChunksImpl = class extends IteratorImpl {
  constructor(n, v) {
    const p = Number(size(n));
    super(
      function* () {
        if (p > v.ptr.length) {
          return;
        }
        for (let i = 0; i < v.ptr.length; i += p) {
          const slice2 = v.get_slice(i, i + p);
          if (slice2.is_some()) {
            yield Iterator(slice2.unwrap());
          }
        }
      }()
    );
  }
  static new(n, ptr) {
    return new this(n, ptr);
  }
};
var Chunks = staticify(ChunksImpl);

// src/std/slice/chunks_exact.ts
var ChunksExactImpl = class extends IteratorImpl {
  constructor(n, v) {
    const p = Number(size(n));
    super(
      function* () {
        if (p > v.ptr.length) {
          return;
        }
        for (let i = 0; i < v.ptr.length; i += p) {
          const slice2 = v.get_slice(i, i + p);
          if (slice2.is_some()) {
            const mut = slice2.unwrap();
            if (mut.len() === usize(p)) {
              yield Iterator(slice2.unwrap());
            }
          }
        }
      }()
    );
  }
  static new(n, ptr) {
    return new this(n, ptr);
  }
};
var ChunksExact = staticify(ChunksExactImpl);

// src/std/slice/rchunks.ts
var RChunksImpl = class extends IteratorImpl {
  constructor(n, v) {
    super(v.reverse().chunks(n));
  }
  static new(n, ptr) {
    return new this(n, ptr);
  }
};
var RChunks = staticify(RChunksImpl);

// src/std/slice/rchunks_exact.ts
var RChunksExactImpl = class extends IteratorImpl {
  constructor(n, v) {
    super(v.reverse().chunks_exact(n));
  }
  static new(n, ptr) {
    return new this(n, ptr);
  }
};
var RChunksExact = staticify(RChunksExactImpl);

// src/std/slice/rsplit.ts
var RSplitImpl = class extends IteratorImpl {
  constructor(v, f) {
    super(v.reverse().split(f));
  }
  static new(ptr, f) {
    return new this(ptr, f);
  }
};
var RSplit = staticify(RSplitImpl);

// src/std/slice/rsplitn.ts
var RSplitNImpl = class extends IteratorImpl {
  constructor(v, n, f) {
    super(v.reverse().splitn(n, f));
  }
  static new(ptr, n, f) {
    return new this(ptr, n, f);
  }
};
var RSplitN = staticify(RSplitNImpl);

// src/std/slice/rsplit_inclusive.ts
var RSplitInclusiveImpl = class extends IteratorImpl {
  constructor(v, f) {
    super(v.reverse().split_inclusive(f));
  }
  static new(ptr, f) {
    return new this(ptr, f);
  }
};
var RSplitInclusive = staticify(RSplitInclusiveImpl);

// src/std/slice/split.ts
var SplitImpl = class extends IteratorImpl {
  constructor(v, f) {
    super(
      function* () {
        const out = [];
        for (const value of v) {
          if (f(value)) {
            yield Iterator(out);
          }
          out.push(value);
        }
      }()
    );
  }
  static new(ptr, f) {
    return new this(ptr, f);
  }
};
var Split = staticify(SplitImpl);

// src/std/slice/split_inclusive.ts
var SplitInclusiveImpl = class extends IteratorImpl {
  constructor(v, f) {
    super(
      function* () {
        const out = [];
        for (const value of v) {
          out.push(value);
          if (f(value)) {
            yield Iterator(out);
          }
        }
      }()
    );
  }
  static new(ptr, f) {
    return new this(ptr, f);
  }
};
var SplitInclusive = staticify(SplitInclusiveImpl);

// src/std/slice/splitn.ts
var SplitNImpl = class extends IteratorImpl {
  constructor(v, n, f) {
    super(
      function* () {
        let x = 0n;
        const out = [];
        for (const value of v) {
          if (f(value) && size(n).gt(x++)) {
            yield Iterator(out);
          }
          out.push(value);
        }
        yield Iterator(out);
      }()
    );
  }
  static new(ptr, n, f) {
    return new this(ptr, n, f);
  }
};
var SplitN = staticify(SplitNImpl);

// src/std/slice/windows.ts
var WindowsImpl = class extends IteratorImpl {
  constructor(n, v) {
    const p = Number(size(n));
    super(
      function* () {
        if (p > v.ptr.length) {
          return;
        }
        for (let i = 0; i < v.ptr.length; i++) {
          const slice2 = v.get_slice(i, i + p);
          if (slice2.is_some()) {
            yield Iterator(slice2.unwrap());
          }
        }
      }()
    );
  }
  static new(n, ptr) {
    return new this(n, ptr);
  }
};
var Windows = staticify(WindowsImpl);

// src/std/slice/slice.ts
var SliceImpl = class {
  ptr;
  constructor(slice2) {
    this.ptr = Array.from(slice2);
  }
  static default() {
    return new this([]);
  }
  static new(slice2) {
    return new this(slice2);
  }
  len() {
    return usize(this.ptr.length);
  }
  is_empty() {
    return this.len().eq(0);
  }
  first() {
    if (this.is_empty()) {
      return None;
    }
    return Some(this.ptr[0]);
  }
  split_first() {
    if (this.is_empty()) {
      return None;
    }
    const first = this.ptr[0];
    const rest = slice(this.ptr.slice(1));
    return Some([first, rest]);
  }
  last() {
    if (this.is_empty()) {
      return None;
    }
    return Some(this.ptr[this.ptr.length - 1]);
  }
  split_last() {
    if (this.is_empty()) {
      return None;
    }
    const last = this.ptr[this.ptr.length - 1];
    const rest = slice(this.ptr.slice(0, this.ptr.length - 1));
    return Some([last, rest]);
  }
  get(index) {
    index = Number(size(index).as_primitive());
    if (index < 0 || index > this.ptr.length) {
      return None;
    }
    return Some(this.get_unchecked(index));
  }
  get_unchecked(index) {
    return this.ptr[Number(size(index).as_primitive())];
  }
  get_slice(start, end) {
    [start, end] = [Number(size(start)), Number(size(end))];
    if (start < 0 || end > this.ptr.length) {
      return None;
    }
    return Some(slice(this.get_slice_unchecked(start, end)));
  }
  get_slice_unchecked(start, end) {
    return slice(this.ptr.slice(Number(size(start)), Number(size(end))));
  }
  swap(a, b) {
    [a, b] = [Number(size(a)), Number(size(b))];
    if (a < 0 || a > this.ptr.length || b < 0 || b > this.ptr.length) {
      panic("tried to swap with out-of-bounds indices");
    }
    return this.swap_unchecked(a, b);
  }
  swap_unchecked(a, b) {
    [a, b] = [Number(size(a)), Number(size(b))];
    [this.ptr[a], this.ptr[b]] = [this.ptr[b], this.ptr[a]];
    return this;
  }
  reverse() {
    this.ptr.reverse();
    return this;
  }
  *[Symbol.iterator]() {
    for (const value of this.ptr) {
      yield value;
    }
  }
  iter() {
    return Iterator(this);
  }
  windows(n) {
    return Windows(n, this);
  }
  chunks(n) {
    return Chunks(n, this);
  }
  chunks_exact(n) {
    return ChunksExact(n, this);
  }
  rchunks(n) {
    return RChunks(n, this);
  }
  rchunks_exact(n) {
    return RChunksExact(n, this);
  }
  split_at(n) {
    if (size(n).gt(this.len())) {
      panic("cannot split outside of slice");
    }
    return [
      this.get_slice(0, n).unwrap(),
      this.get_slice(n, this.len()).unwrap()
    ];
  }
  split_at_unchecked(n) {
    return [
      this.get_slice_unchecked(0, n),
      this.get_slice_unchecked(n, this.len())
    ];
  }
  split(p) {
    return Split(this, p);
  }
  split_inclusive(p) {
    return SplitInclusive(this, p);
  }
  rsplit(p) {
    return RSplit(this, p);
  }
  rsplit_inclusive(p) {
    return RSplitInclusive(this, p);
  }
  splitn(n, f) {
    return SplitN(this, n, f);
  }
  rsplitn(n, f) {
    return RSplitN(this, n, f);
  }
  contains(x) {
    if (this.is_empty()) {
      return false;
    }
    if (typeof x === "object" && "eq" in x) {
      try {
        return this.ptr.findIndex((value) => value.eq(x)) !== -1;
      } catch {
      }
    }
    return this.ptr.includes(x);
  }
  starts_with(needle) {
    if (this.is_empty()) {
      return false;
    }
    let i = 0;
    for (const value of needle) {
      const compare = this.ptr[i++];
      if (is_eq(value)) {
        if (value.ne(compare)) {
          return false;
        }
      }
      if (value !== compare) {
        return false;
      }
    }
    return true;
  }
  ends_with(needle) {
    if (this.is_empty()) {
      return false;
    }
    let i = Number(this.len().as_primitive());
    for (const value of needle) {
      const compare = this.ptr[--i];
      if (is_eq(value)) {
        if (value.ne(compare)) {
          return false;
        }
      }
      if (value !== compare) {
        return false;
      }
    }
    return true;
  }
  strip_prefix(prefix) {
    const l = iter_len(prefix);
    if (l === 0) {
      return Some(this);
    }
    if (this.starts_with(prefix)) {
      return this.get_slice(0, iter_len(prefix));
    }
    return None;
  }
  strip_suffix(suffix) {
    const l = iter_len(suffix);
    if (l === 0) {
      return Some(this);
    }
    if (this.ends_with(suffix)) {
      return this.get_slice(iter_len(suffix), Infinity);
    }
    return None;
  }
  // binary_search, binary_search_by, binary_search_by_key
  sort() {
    this.ptr.sort();
    return this;
  }
  sort_by(compare) {
    this.ptr.sort((a, b) => compare(a, b).value);
    return this;
  }
  // to_vec, into_vec, repeat
  concat(i) {
    for (const value of i) {
      this.ptr.push(value);
    }
    return this;
  }
  rotate_left(mid) {
    if (this.len().lt(mid)) {
      panic("Cannot rotate outside of pointer bounds");
    }
    if (this.len().eq(mid)) {
      return this;
    }
    this.ptr = this.get_slice(mid, this.len()).unwrap().concat(this.get_slice(0, mid).unwrap()).ptr;
    return this;
  }
  rotate_right(mid) {
    if (this.len().lt(mid)) {
      panic("Cannot rotate outside of pointer bounds");
    }
    if (this.len().eq(mid)) {
      return this;
    }
    this.ptr = this.get_slice(0, mid).unwrap().concat(this.get_slice(mid, this.len()).unwrap()).ptr;
    return this;
  }
  fill(value) {
    this.ptr.fill(value, 0, Number(this.len().as_primitive()));
    return this;
  }
  fill_with(f) {
    let i = 0;
    while (i++ < Number(this.len().as_primitive())) {
      this.ptr[i] = f();
    }
    return this;
  }
  // join
  eq(other) {
    return iter_len(other) === Number(this.len().as_primitive()) && this.starts_with(other);
  }
  ne(other) {
    return default_partial_eq(this).ne(other);
  }
  partial_cmp(other) {
    if (this.eq(other)) {
      return Ordering.Equal;
    }
    let i = 0;
    for (const value of other) {
      const self = this.ptr[i++];
      if (value === self) {
        continue;
      }
      if (is_cmp(value)) {
        return value.partial_cmp(self).reverse();
      }
    }
    return Ordering.Less;
  }
  lt(other) {
    return default_partial_ord(this).lt(other);
  }
  le(other) {
    return default_partial_ord(this).le(other);
  }
  gt(other) {
    return default_partial_ord(this).gt(other);
  }
  ge(other) {
    return default_partial_ord(this).lt(other);
  }
};
var slice = staticify(SliceImpl);

// src/std/vec/vec.ts
var VecImpl = class {
  alloc = [];
  static new() {
    return new this();
  }
  static with_capacity(capacity) {
    const owned = this.new();
    return owned.reserve(capacity);
  }
  *[Symbol.iterator]() {
    while (1 / 1) {
      const pop = this.pop();
      if (pop.is_none()) {
        break;
      }
      yield pop.unwrap();
    }
  }
  capacity() {
    return usize(this.alloc.length);
  }
  capacity_extension() {
    const lock = this.capacity().valueOf();
    for (let i = 0n; i < lock; i++) {
      this.alloc.push(None);
    }
    return this;
  }
  reserve(additional) {
    while (this.capacity().lt(additional)) {
      this.capacity_extension();
    }
    return this;
  }
  reserve_exact(additional) {
    while (this.capacity().lt(additional)) {
      this.alloc.push(None);
    }
    return this;
  }
  has_none_tail() {
    const last = this.alloc.pop();
    if (last === void 0) {
      return false;
    }
    this.alloc.push(last);
    return last.is_none();
  }
  shrink_to_fit() {
    while (this.has_none_tail()) {
      this.alloc.pop();
    }
    return this;
  }
  shrink_to(to) {
    while (this.capacity().gt(to) && this.has_none_tail()) {
      this.alloc.pop();
    }
    return this;
  }
  len() {
    let c = 0n;
    let i = 0;
    while (this.alloc[i++]?.is_some()) {
      c++;
    }
    return usize(c);
  }
  truncate(len) {
    while (this.len().gt(len)) {
      this.alloc[this.len().sub(1).into(Number)] = None;
    }
    return this;
  }
  as_slice() {
    return slice(
      this.alloc.slice(0, this.len().into(Number)).map((x) => x.unwrap())
    );
  }
  get(index) {
    return this.alloc[usize(index).into(Number)] || None;
  }
  last() {
    return this.get(this.len().sub(1));
  }
  oob(index) {
    throw `index ${index.valueOf()} does not fit in vec[${this.len()}; ${this.capacity()}]`;
  }
  swap_remove(index) {
    const value = this.alloc[index];
    if (value === None || value === void 0) {
      throw this.oob(index);
    }
    this.alloc[index] = this.last();
    this.alloc[this.len().sub(1).into(Number)] = None;
    return value;
  }
  insert(index, element) {
    if (this.len().le(index)) {
      throw this.oob(index);
    }
    this.alloc.splice(usize(index).into(Number), 0, Some(element));
    return this;
  }
  remove(index) {
    if (index > this.len()) {
      throw this.oob(index);
    }
    return this.alloc.splice(usize(index).into(Number), 1)[0] || None;
  }
  // dedup_by_key, dedup_by
  retain(f) {
    let i = 0n;
    while (this.len().gt(i)) {
      if (!f(this.get(i).unwrap())) {
        this.remove(i);
      }
      i++;
    }
    return this;
  }
  push(element) {
    if (this.has_none_tail()) {
      this.alloc[this.alloc.indexOf(None)] = Some.new(element);
    } else {
      this.capacity_extension();
      this.alloc.push(Some.new(element));
    }
    return this;
  }
  push_within_capacity(element) {
    if (this.len() >= this.capacity()) {
      return Err(element);
    }
    this.push(element);
    return Ok(null);
  }
  pop() {
    if (this.len().eq(0)) {
      return None;
    }
    const i = this.get(this.len().sub(1));
    this.remove(this.len().sub(1));
    return i;
  }
  append(other) {
    for (const value of other) {
      this.push(value);
    }
    return this;
  }
  drain([range_min, range_max]) {
    if (usize(range_min).gt(range_max)) {
      throw "starting point cannot be larger than the ending point";
    }
    if (range_min > this.len()) {
      throw "ending point cannot be larger than this vec's length";
    }
    const n = Vec.with_capacity(usize(range_max).sub(range_min));
    for (let i = usize(range_min).valueOf(); i <= usize(range_max).valueOf(); i++) {
      n.push(this.remove(i).unwrap());
    }
    return n;
  }
  clear() {
    this.drain([0, this.len()]);
    return this;
  }
  is_empty() {
    return this.len().eq(0);
  }
  split_off(at) {
    if (this.len().lt(at)) {
      throw this.oob(at);
    }
    const p = Vec.with_capacity(this.len().sub(at));
    for (let i = usize(at).valueOf(); this.len().gt(i); i++) {
      p.push(this.get(i).unwrap());
    }
    this.truncate(usize(at).sub(1));
    return p;
  }
  resize_with(new_len, f) {
    if (this.len().gt(new_len)) {
      return this.truncate(new_len);
    }
    while (this.len().lt(new_len)) {
      this.push(f());
    }
    return this;
  }
  resize(newLen, t) {
    return this.resize_with(newLen, () => t);
  }
  extend(iter) {
    for (const value of iter) {
      this.push(value);
    }
    return this;
  }
  join(str2) {
    return this.alloc.filter((x) => x.is_some()).map((x) => x.unwrap()).join(str2);
  }
  into_iter() {
    return IntoIter(this);
  }
  iter() {
    return Iterator(
      this.alloc.filter((x) => x.is_some()).map((x) => x.unwrap_unchecked())
    );
  }
  clone() {
    const raw = this.alloc.filter((x) => x.is_some()).map((x) => x.unwrap());
    const into = Vec();
    for (const value of raw) {
      into.push(value);
    }
    return into;
  }
  static from_iter(i) {
    const out = this.new();
    for (const value of i) {
      out.push(value);
    }
    return out;
  }
  index_of(value) {
    return usize(this.alloc.findIndex((x) => x.contains(value)));
  }
};
var Vec = staticify(VecImpl);

// src/std/macros.ts
function assert(x, label = String(x)) {
  if (!x) {
    panic(`assertion failed: ${label}`);
  }
}
function assert_eq(x, y, label_x = String(x), label_y = String(x)) {
  const wrap_ne = "ne" in x && typeof x.ne === "function";
  if (wrap_ne && x.ne(y) && x != y) {
    console.log(x, y);
    panic(`assertion failed: ${label_x} == ${label_y}`);
  }
}
function assert_ne(x, y, label_x = String(x), label_y = String(y)) {
  const wrap_eq = "eq" in x && typeof x.eq === "function";
  if (wrap_eq && x.eq(y) || x == y) {
    console.log(x, y);
    panic(`assertion failed: ${label_x} != ${label_y}`);
  }
}
function is_node() {
  if (typeof process === "object") {
    if (typeof process.versions === "object") {
      if (typeof process.versions.node !== "undefined") {
        return true;
      }
    }
  }
  return false;
}
function cfg(flag) {
  assert(is_node());
  return !!process.config.variables[flag];
}
function column() {
  unimplemented("column");
}
function compile_error(msg) {
  unimplemented("compile_error");
}
function concat(...values) {
  return values.join("");
}
function dbg(value) {
  console.debug(value);
}
function debug_assert(x, label = String(x)) {
  if (!x) {
    panic(`debug assertion failed: ${label}`);
  }
}
function debug_assert_eq(x, y, label_x = String(x), label_y = String(x)) {
  const wrap_ne = "ne" in x && typeof x.ne === "function";
  if (wrap_ne && x.ne(y) && x != y) {
    console.log(x, y);
    panic(`debug assertion failed: ${label_x} == ${label_y}`);
  }
}
function debug_assert_ne(x, y, label_x = String(x), label_y = String(y)) {
  const wrap_eq = "eq" in x && typeof x.eq === "function";
  if (wrap_eq && x.eq(y) || x == y) {
    console.log(x, y);
    panic(`debug assertion failed: ${label_x} != ${label_y}`);
  }
}
function env(variable, message) {
  assert(is_node(), message);
  const value = process.env[variable];
  assert(value, message);
  return value;
}
function eprint(msg) {
  assert(is_node());
  process.stderr.write(msg);
}
function eprintln(msg) {
  assert(is_node());
  process.stderr.write(msg + "\n");
}
function file() {
  unimplemented("file");
}
function format(literal, ...argv) {
  unimplemented("format");
}
function format_args(literal, ...argv) {
  unimplemented("format_args");
}
function include(path) {
  assert(is_node());
  return __require(path);
}
function is_x86_feature_detected(feature) {
  unimplemented(`is_x86_feature_detected(${feature})`);
}
function line() {
  unimplemented();
}
function module_path() {
  assert(is_node());
  return process.cwd();
}
function option_env(variable, message) {
  assert(is_node(), message);
  const value = process.env[variable];
  if (value === void 0) {
    return None;
  }
  return Some(value);
}
function print(msg) {
  assert(is_node());
  process.stdout.write(msg);
}
function println(msg) {
  assert(is_node());
  process.stdout.write(msg + "\n");
}
function stringify(x) {
  return String(x);
}
function todo(message = "todo") {
  throw new Error("todo: " + message);
}
function unimplemented(message = "unimplemented") {
  throw new Error("unimplemented: " + message);
}
function unreachable(message = "unreachable") {
  throw new Error("unreachable: " + message);
}
function vec(...argv) {
  return Vec.from_iter(argv);
}

// src/std/tuple.ts
var TupleImpl = class {
  constructor(alloc) {
    this.alloc = alloc;
  }
  static new(alloc) {
    return new this(alloc);
  }
  // only support raw
  get(index) {
    return this.alloc[size(index).into(Number)];
  }
  into(f) {
    return f(this.alloc);
  }
  as_primitive() {
    return this.alloc;
  }
  *[Symbol.iterator]() {
    yield* this.alloc;
  }
};
var tuple = staticify(TupleImpl);
var UnitImpl = class extends TupleImpl {
  constructor() {
    super([]);
  }
  static new() {
    return new this();
  }
  get(index) {
    return void 0;
  }
};
var unit = staticify(UnitImpl);

// src/std/fmt.ts
var Error2 = class {
  constructor(message) {
    this.message = message;
  }
};
var Alignment = /* @__PURE__ */ ((Alignment2) => {
  Alignment2["Left"] = "<";
  Alignment2["Right"] = ">";
  Alignment2["Center"] = "^";
  Alignment2["Unknown"] = "";
  return Alignment2;
})(Alignment || {});
var Formatter = class {
  r_buf;
  argv = {};
  result = Ok(unit());
  constructor(buf) {
    this.r_buf = buf;
  }
  with(argv) {
    Object.assign(this.argv, argv);
    return this;
  }
  write_fmt(str2, ...args) {
    let ctr = 0;
    const fmt_r = /\{{2}|\}{2}|\{(.*?)(?::(#)?((?:x|X|e|E|)(?:\?)|b|o|p)?(?:(.?)(\^|<|>)(\d+))?)?(?:\.(\d+))?(?:(\+|0\d+|-))?\}/g;
    try {
      return this.write(
        str2.replace(
          fmt_r,
          ($, $tag, $alternate, $modifier, $align_char, $align_type, $align_count, $precision, $sign) => {
            if ($ === "{{") {
              return "{";
            }
            if ($ === "}}") {
              return "}";
            }
            const alternate = $alternate === "#";
            let obj;
            if ($tag === "") {
              obj = args[ctr++];
            } else if (Number($tag) in args) {
              obj = args[Number($tag)];
            } else if ($tag in this.argv) {
              obj = this.argv[$tag];
            }
            if (obj === void 0) {
              throw new Error2("unknown format tag");
            }
            if (alternate && $modifier === "") {
              throw new Error2("no implementation for `Alternate & Display`");
            }
            let out = "";
            if ($modifier === "" || $modifier === void 0) {
              try {
                assert_has(obj, ["fmt_display"], "Display");
                out += obj.fmt_display();
              } catch {
                out += String(obj);
              }
            } else if ($modifier === "?") {
              if (alternate) {
                assert_has(
                  obj,
                  ["fmt_debug_alternate"],
                  "DebugAlternate"
                );
                out += obj.fmt_debug_alternate();
              } else {
                assert_has(obj, ["fmt_debug"], "Debug");
                out += obj.fmt_debug();
              }
            } else if ($modifier === "x" || $modifier === "x?") {
              assert_has(obj, ["fmt_lower_hex"], "LowerHex");
              if (alternate) {
                out += "0x";
              }
              out += obj.fmt_lower_hex();
            } else if ($modifier === "X" || $modifier === "X?") {
              assert_has(obj, ["fmt_upper_hex"], "UpperHex");
              if (alternate) {
                out += "0x";
              }
              out += obj.fmt_upper_hex();
            } else if ($modifier === "e" || $modifier === "e?") {
              assert_has(obj, ["fmt_lower_exp"], "LowerExp");
              out += obj.fmt_lower_exp();
            } else if ($modifier === "E" || $modifier === "E?") {
              assert_has(obj, ["fmt_upper_exp"], "UpperExp");
              out += obj.fmt_upper_exp();
            } else if ($modifier === "b") {
              assert_has(obj, ["fmt_binary"], "Binary");
              if (alternate) {
                out += "0b";
              }
              out += obj.fmt_binary();
            } else if ($modifier === "o") {
              assert_has(obj, ["fmt_octal"], "Octal");
              if (alternate) {
                out += "0o";
              }
              out += obj.fmt_octal();
            } else if ($modifier === "p") {
              assert_has(obj, ["fmt_pointer"], "Pointer");
              out += obj.fmt_pointer();
            } else if (!Number.isNaN(Number($precision))) {
              assert_has(obj, ["fmt_precision"], "Precision");
              out += obj.fmt_precision(Number($precision));
            }
            if ($sign === "+") {
              assert_has(obj, ["fmt_signed"], "Signed");
              out = obj.fmt_signed() + out;
            }
            if ($align_count !== void 0 && $align_type !== void 0) {
              $align_char ||= " ";
              const count = Number($align_count);
              if (Number.isNaN(count)) {
                throw new Error2("invalid alignment count");
              }
              if ($align_type === "<" /* Left */) {
                while (out.length < count) {
                  out += $align_char;
                }
              } else if ($align_type === "^" /* Center */) {
                while (out.length < count) {
                  if (count - out.length === 1) {
                    out += $align_char;
                    break;
                  }
                  out = $align_char + out + $align_char;
                }
              } else if ($align_type === ">" /* Right */) {
                while (out.length < count) {
                  out = $align_char + count;
                }
              }
            }
            return out;
          }
        )
      );
    } catch (e) {
      return this.result = Err(e);
    }
  }
  write(str2) {
    this.r_buf += str2;
    return Ok(unit());
  }
  finish() {
    if (this.result.is_err()) {
      return Err(this.result.unwrap_err());
    }
    return Ok(this.r_buf);
  }
};
function assert_has(u, keys, name) {
  for (const key of keys) {
    assert(u, `\`${name}\` cannot be implemented for undefined`);
    assert(u[key], `object does not implement \`${name}\``);
  }
}
var DebugList = class {
  parts = [];
  entry(entry) {
    this.parts.push(entry);
    return this;
  }
  entries(entries) {
    for (const entry of entries) {
      this.entry(entry);
    }
    return this;
  }
  finish() {
    return `[${this.parts.map((x) => x.fmt_debug()).join(", ")}]`;
  }
};
var DebugMap = class {
  dangling;
  parts = /* @__PURE__ */ new Map();
  key(key) {
    this.dangling = key;
    return this;
  }
  value(value) {
    if (this.dangling === void 0) {
      panic("cannot add dangling values without key");
    }
    this.parts.set(this.dangling, value);
    return this;
  }
  entry(key, value) {
    if (this.dangling !== void 0) {
      panic(
        "cannot add entry with dangling key `" + this.dangling.fmt_debug() + "`"
      );
    }
    this.parts.set(key, value);
    return this;
  }
  entries(entries) {
    for (const [k, v] of entries) {
      this.entry(k, v);
    }
    return this;
  }
  finish() {
    if (this.dangling !== void 0) {
      return Err(new Error2("cannot finish DebugMap with a dangling key"));
    }
    let out = "";
    out += "{";
    let had_before = false;
    for (const [k, v] of this.parts) {
      out += had_before ? "," : "";
      out += k;
      out += v;
      had_before = true;
    }
    out += "}";
    return Ok(out);
  }
};
var DebugSet = class {
  parts = [];
  entry(entry) {
    this.parts.push(entry);
    return this;
  }
  entries(entries) {
    for (const entry of entries) {
      this.entry(entry);
    }
    return this;
  }
  finish() {
    return `{${this.parts.map((x) => x.fmt_debug()).join(", ")}}`;
  }
};
var DebugStruct = class {
  constructor(name) {
    this.name = name;
  }
  fields = {};
  field(name, value) {
    this.fields[name] = value;
    return this;
  }
  finish_non_exhaustive() {
    const set = new DebugSet().entries(
      Object.entries(this.fields).map(([k, v]) => ({
        fmt_debug() {
          return `${k}: ${v.fmt_debug()}`;
        }
      }))
    ).entry({
      fmt_debug() {
        return "..";
      }
    }).finish();
    return `${this.name} ${set}`;
  }
  finish() {
    const set = new DebugSet().entries(
      Object.entries(this.fields).map(([k, v]) => ({
        fmt_debug() {
          return `${k}: ${v.fmt_debug()}`;
        }
      }))
    ).finish();
    return `${this.name} ${set}`;
  }
};
var DebugTuple = class {
  constructor(name = "") {
    this.name = name;
  }
  fields = [];
  field(value) {
    this.fields.push(value);
    return this;
  }
  finish() {
    return `${this.name}(${this.fields.map((x) => x.fmt_debug()).join(", ")})`;
  }
};

// src/std/collections/hash_map/into_iter.ts
var IntoIterImpl2 = class extends IteratorImpl {
  constructor(source) {
    super(
      function* () {
        for (const tuple2 of source.vec) {
          yield tuple2;
        }
      }()
    );
  }
  static new(source) {
    return new this(source);
  }
};
var IntoIter2 = staticify(IntoIterImpl2);

// src/std/collections/hash_map/into_keys.ts
var IntoKeysImpl = class extends IteratorImpl {
  constructor(source) {
    super(
      function* () {
        for (const [key] of source.vec) {
          yield key;
        }
      }()
    );
  }
  static new(source) {
    return new this(source);
  }
};
var IntoKeys = staticify(IntoKeysImpl);

// src/std/collections/hash_map/into_values.ts
var IntoValuesImpl = class extends IteratorImpl {
  constructor(source) {
    super(
      function* () {
        for (const [, value] of source.vec) {
          yield value;
        }
      }()
    );
  }
  static new(source) {
    return new this(source);
  }
};
var IntoValues = staticify(IntoValuesImpl);

// src/std/collections/hash_map/iter.ts
var IterImpl = class extends IteratorImpl {
  constructor(source) {
    super(
      function* () {
        for (const tuple2 of source.vec.clone()) {
          yield tuple2;
        }
      }()
    );
  }
  static new(source) {
    return new this(source);
  }
};
var Iter = staticify(IterImpl);

// src/std/collections/hash_map/keys.ts
var KeysImpl = class extends IteratorImpl {
  constructor(source) {
    super(
      function* () {
        for (const [key] of source.vec.clone()) {
          yield key;
        }
      }()
    );
  }
  static new(source) {
    return new this(source);
  }
};
var Keys = staticify(KeysImpl);

// src/std/collections/hash_map/values.ts
var ValuesImpl = class extends IteratorImpl {
  constructor(source) {
    super(
      function* () {
        for (const [, value] of source.vec.clone()) {
          yield value;
        }
      }()
    );
  }
  static new(source) {
    return new this(source);
  }
};
var Values = staticify(ValuesImpl);

// src/std/collections/hash_map/hash_map.ts
var HashMapImpl = class {
  vec = Vec();
  fmt_debug() {
    const map = new DebugMap();
    for (const [k, v] of this.vec.clone()) {
      map.entry(k, v);
    }
    return map.finish().unwrap();
  }
  static new() {
    return new this();
  }
  static with_capacity(capacity) {
    const raw = this.new();
    raw.vec = Vec.with_capacity(capacity);
    return raw;
  }
  capacity() {
    return this.vec.capacity();
  }
  keys() {
    return Keys(this);
  }
  into_keys() {
    return IntoKeys(this);
  }
  values() {
    return Values(this);
  }
  into_values() {
    return IntoValues(this);
  }
  iter() {
    return Iter(this);
  }
  into_iter() {
    return IntoIter2(this);
  }
  len() {
    return this.vec.len();
  }
  is_empty() {
    return this.vec.is_empty();
  }
  drain() {
    return this.into_iter();
  }
  // drain_filter
  retain(f) {
    this.vec.retain((x) => f(...x));
    return this;
  }
  clear() {
    this.vec.clear();
    return this;
  }
  // comparison
  reserve(additional) {
    this.vec.reserve(additional);
    return this;
  }
  shrink_to_fit() {
    this.vec.shrink_to_fit();
    return this;
  }
  shrink_to(min_capacity) {
    this.vec.shrink_to(min_capacity);
    return this;
  }
  entry(key) {
    return this.vec.clone().into_iter().find(([k]) => compare_hash(key, k));
  }
  entry_index(key) {
    const raw = this.entry(key);
    if (raw.is_some()) {
      return Some(usize(this.vec.alloc.indexOf(raw)));
    }
    return None;
  }
  get(k) {
    return this.entry(k).map(([, v]) => v);
  }
  get_key_value(k) {
    return this.entry(k);
  }
  get_many(keys) {
    const out = [];
    for (const key of keys) {
      const value = this.get(key);
      if (value.is_none()) {
        return None;
      }
      out.push(value.unwrap());
    }
    return Some(Vec.from_iter(out));
  }
  contains_key(k) {
    return this.entry(k).is_some();
  }
  insert(k, v) {
    const old = this.get(k);
    if (old.is_some()) {
      this.vec.remove(this.entry_index(k).unwrap());
      this.vec.push([k, v]);
      return old;
    }
    return None;
  }
  remove(k) {
    const old = this.get(k);
    if (old.is_some()) {
      this.vec.remove(this.entry_index(k).unwrap());
      return old;
    }
    return None;
  }
  remove_entry(k) {
    return this.remove(k).map((v) => [k, v]);
  }
  static from_iter(i) {
    const self = this.new();
    for (const [key, value] of i) {
      self.insert(key, value);
    }
    return self;
  }
};
var HashMap = staticify(HashMapImpl);

// src/std/collections/hash_set/difference.ts
var DifferenceImpl = class extends IteratorImpl {
  constructor(source, target) {
    super(
      function* () {
        for (const tuple2 of source.vec.clone()) {
          if (target.contains(tuple2)) {
            continue;
          }
          yield tuple2;
        }
      }()
    );
  }
  static new(source, target) {
    return new this(source, target);
  }
};
var Difference = staticify(DifferenceImpl);

// src/std/collections/hash_set/intersection.ts
var IntersectionImpl = class extends IteratorImpl {
  constructor(source, target) {
    super(
      function* () {
        for (const value of source.vec.clone()) {
          if (target.contains(value)) {
            yield value;
          }
        }
      }()
    );
  }
  static new(source, target) {
    return new this(source, target);
  }
};
var Intersection = staticify(IntersectionImpl);

// src/std/collections/hash_set/into_iter.ts
var IntoIterImpl3 = class extends IteratorImpl {
  constructor(source) {
    super(
      function* () {
        for (const tuple2 of source.vec) {
          yield tuple2;
        }
      }()
    );
  }
  static new(source) {
    return new this(source);
  }
};
var IntoIter3 = staticify(IntoIterImpl3);

// src/std/collections/hash_set/iter.ts
var IterImpl2 = class extends IteratorImpl {
  constructor(source) {
    super(
      function* () {
        for (const tuple2 of source.vec.clone()) {
          yield tuple2;
        }
      }()
    );
  }
  static new(source) {
    return new this(source);
  }
};
var Iter2 = staticify(IterImpl2);

// src/std/collections/hash_set/symmetric_difference.ts
var SymmetricDifferenceImpl = class extends IteratorImpl {
  constructor(source, target) {
    super(source.difference(target).chain(target.difference(source)));
  }
  static new(source, target) {
    return new this(source, target);
  }
};
var SymmetricDifference = staticify(SymmetricDifferenceImpl);

// src/std/collections/hash_set/union.ts
var UnionImpl = class extends IteratorImpl {
  constructor(source, target) {
    super(
      function* () {
        const visited = [];
        for (const value of source.vec.clone()) {
          if (!visited.find((x) => compare_hash(value, x))) {
            visited.push(value);
          }
        }
        for (const value of target.vec.clone()) {
          if (!visited.find((x) => compare_hash(value, x))) {
            visited.push(value);
          }
        }
        yield* visited;
      }()
    );
  }
  static new(source, target) {
    return new this(source, target);
  }
};
var Union = staticify(UnionImpl);

// src/std/collections/hash_set/hash_set.ts
var HashSetImpl = class {
  vec = Vec();
  static new() {
    return new this();
  }
  static with_capacity(capacity) {
    const raw = this.new();
    raw.vec = Vec.with_capacity(capacity);
    return raw;
  }
  iter() {
    return Iter2(this);
  }
  len() {
    return this.vec.len();
  }
  is_empty() {
    return this.vec.is_empty();
  }
  // drain, drain_filter
  retain(f) {
    this.vec.retain(f);
    return this;
  }
  clear() {
    this.vec.clear();
    return this;
  }
  // comparison
  reserve(additional) {
    this.vec.reserve(additional);
    return this;
  }
  // public reserve_exact(additional: io<usize>): this {
  //   this.vec.reserve_exact(additional);
  //   return this;
  // }
  shrink_to_fit() {
    this.vec.shrink_to_fit();
    return this;
  }
  shrink_to(min_capacity) {
    this.vec.shrink_to(min_capacity);
    return this;
  }
  // difference, symmetric_difference, intersection, union
  difference(other) {
    return Difference(this, other);
  }
  symmetric_difference(other) {
    return SymmetricDifference(this, other);
  }
  intersection(other) {
    return Intersection(this, other);
  }
  union(other) {
    return Union(this, other);
  }
  get(key) {
    return this.vec.clone().into_iter().find((k) => compare_hash(key, k));
  }
  contains(key) {
    return this.get(key).is_some();
  }
  get_or_insert(value) {
    if (this.contains(value)) {
      return this.get(value).unwrap();
    }
    this.vec.push(value);
    return value;
  }
  get_or_insert_with(value, f) {
    if (this.contains(value)) {
      return this.get(value).unwrap();
    }
    const output = f(value);
    void this.get_or_insert(output);
    return output;
  }
  is_disjoint(other) {
    if (this.len().le(other.len())) {
      return this.iter().all((v) => !other.contains(v));
    } else {
      return other.iter().all((v) => !this.contains(v));
    }
  }
  is_subset(other) {
    if (this.len().le(other.len())) {
      return this.iter().all((v) => other.contains(v));
    } else {
      return false;
    }
  }
  is_superset(other) {
    return other.is_subset(this);
  }
  insert(value) {
    if (this.contains(value)) {
      return this;
    }
    this.vec.push(value);
    return this;
  }
  replace(value) {
    return this;
  }
  remove(T) {
    this.vec.remove(this.vec.index_of(T));
    return this;
  }
  take(T) {
    if (this.contains(T)) {
      this.remove(T);
      return Some(T);
    }
    return None;
  }
  into_iter() {
    return IntoIter3(this);
  }
  static from_iter(iter) {
    const raw = this.new();
    for (const value of iter) {
      raw.insert(value);
    }
    return raw;
  }
};
var HashSet = staticify(HashSetImpl);

// src/std/core/index.ts
var core_exports = {};
__export(core_exports, {
  Array: () => Array2,
  ArrayChunks: () => ArrayChunks,
  Chain: () => Chain,
  Chunks: () => Chunks,
  ChunksExact: () => ChunksExact,
  Cycle: () => Cycle,
  DecodeUtf16: () => DecodeUtf16,
  DecodeUtf16Error: () => DecodeUtf16Error,
  DoubleEndedIterator: () => DoubleEndedIterator,
  Empty: () => Empty,
  Enumerate: () => Enumerate,
  Err: () => Err,
  EscapeDebug: () => EscapeDebug,
  EscapeDefault: () => EscapeDefault,
  EscapeUnicode: () => EscapeUnicode,
  ExactSizeIterator: () => ExactSizeIterator,
  Filter: () => Filter,
  FilterMap: () => FilterMap,
  FlatMap: () => FlatMap,
  Flatten: () => Flatten,
  FromFn: () => FromFn,
  Fuse: () => Fuse,
  HashMap: () => HashMap,
  HashSet: () => HashSet,
  Inspect: () => Inspect,
  Intersperse: () => Intersperse,
  IntersperseWith: () => IntersperseWith,
  IntoIter: () => IntoIter,
  Iterator: () => Iterator,
  IteratorImpl: () => IteratorImpl,
  Map: () => Map2,
  MapWhile: () => MapWhile,
  None: () => None,
  Ok: () => Ok,
  Once: () => Once,
  OnceWith: () => OnceWith,
  Option: () => Option,
  Peekable: () => Peekable,
  RChunks: () => RChunks,
  RChunksExact: () => RChunksExact,
  RSplit: () => RSplit,
  RSplitInclusive: () => RSplitInclusive,
  RSplitN: () => RSplitN,
  Repeat: () => Repeat,
  RepeatWith: () => RepeatWith,
  Scan: () => Scan,
  Skip: () => Skip,
  SkipWhile: () => SkipWhile,
  Some: () => Some,
  Split: () => Split,
  SplitInclusive: () => SplitInclusive,
  SplitN: () => SplitN,
  StepBy: () => StepBy,
  Successors: () => Successors,
  Take: () => Take,
  TakeWhile: () => TakeWhile,
  Types: () => types_exports,
  Vec: () => Vec,
  Windows: () => Windows,
  Zip: () => Zip,
  _: () => _,
  assert: () => assert,
  assert_eq: () => assert_eq,
  assert_ne: () => assert_ne,
  bool: () => bool,
  cfg: () => cfg,
  char: () => char,
  column: () => column,
  compile_error: () => compile_error,
  concat: () => concat,
  consts: () => consts,
  dbg: () => dbg,
  debug_assert: () => debug_assert,
  debug_assert_eq: () => debug_assert_eq,
  debug_assert_ne: () => debug_assert_ne,
  empty: () => empty,
  env: () => env,
  eprint: () => eprint,
  eprintln: () => eprintln,
  f64: () => f64,
  file: () => file,
  format: () => format,
  format_args: () => format_args,
  from_fn: () => from_fn,
  i128: () => i128,
  i16: () => i16,
  i32: () => i32,
  i64: () => i64,
  i8: () => i8,
  include: () => include,
  is_node: () => is_node,
  is_x86_feature_detected: () => is_x86_feature_detected,
  isize: () => isize,
  line: () => line,
  match: () => match,
  module_path: () => module_path,
  once: () => once,
  once_with: () => once_with,
  option_env: () => option_env,
  panic: () => panic,
  print: () => print,
  println: () => println,
  repeat: () => repeat,
  repeat_with: () => repeat_with,
  result_from: () => result_from,
  slice: () => slice,
  str: () => str,
  stringify: () => stringify,
  successors: () => successors,
  todo: () => todo,
  tuple: () => tuple,
  u128: () => u128,
  u16: () => u16,
  u32: () => u32,
  u64: () => u64,
  u8: () => u8,
  unimplemented: () => unimplemented,
  unit: () => unit,
  unreachable: () => unreachable,
  usize: () => usize,
  vec: () => vec,
  zip: () => zip
});

// src/std/array.ts
var ArrayImpl = class {
  alloc = [];
  constructor(alloc) {
    this.alloc = Object.freeze(alloc);
  }
  static new(value) {
    return new this(value);
  }
  static with_length(value, len) {
    len = size(len);
    const o = [];
    for (let i = 0n; i < len.valueOf(); i++) {
      o.push(value);
    }
    return new this(o);
  }
  *[Symbol.iterator]() {
    for (const value of this.alloc) {
      yield value;
    }
  }
  map(f) {
    return Array2(this.alloc.map(f));
  }
  zip(rhs) {
    return Array2(globalThis.Array.from(Iterator(this).zip(rhs)));
  }
  as_slice() {
    return slice(this.alloc);
  }
  get(index) {
    index = Number(index);
    assert(index >= 0 && index < this.alloc.length);
    return this.alloc[index];
  }
  get_slice(start, end) {
    return new ArrayImpl(
      globalThis.Array.from(
        this.as_slice().get_slice(start, end).unwrap_unchecked()
      )
    );
  }
  len() {
    return usize(this.alloc.length);
  }
};
var Array2 = staticify(ArrayImpl);

// src/std/match.ts
var Match = class {
  constructor(val) {
    this.val = val;
  }
  static new(value) {
    return new this(value);
  }
  arms = [];
  value(val, result) {
    this.arms.push([val, result]);
    return this;
  }
  union(val, result) {
    this.arms.push([val, result]);
    return this;
  }
  wildcard(result) {
    this.arms.push([_, result]);
    return this;
  }
  output() {
    for (const [arm, result] of this.arms) {
      const r = typeof result !== "function" ? () => result : result;
      if (compare_hash(this.val, arm)) {
        return r(this.val);
      }
      if (Array.isArray(arm)) {
        for (const value of arm) {
          if (compare_hash(this.val, value)) {
            return r(this.val);
          }
        }
      }
      if (arm === _) {
        return r(this.val);
      }
    }
    throw new Error(`missing match arm: ${this.val}`);
  }
};
var match = staticify(Match);
var _ = Symbol("_");

// src/std/str/bytes.ts
var BytesImpl = class extends IteratorImpl {
  constructor(str2) {
    super(
      function* () {
        for (const c of str2.as_bytes()) {
          yield u8(c);
        }
      }()
    );
  }
  static new(str2) {
    return new this(str2);
  }
};
var Bytes = staticify(BytesImpl);

// src/std/str/char_indices.ts
var CharIndicesImpl = class extends IteratorImpl {
  constructor(str2) {
    super(
      function* () {
        let i = 0n;
        for (const c of str2.alloc) {
          yield [usize(i++), char(c)];
        }
      }()
    );
  }
  static new(str2) {
    return new this(str2);
  }
};
var CharIndices = staticify(CharIndicesImpl);

// src/std/str/chars.ts
var CharsImpl = class extends IteratorImpl {
  constructor(str2) {
    super(
      function* () {
        for (const c of str2.alloc) {
          yield char(c);
        }
      }()
    );
  }
  static new(str2) {
    return new this(str2);
  }
};
var Chars = staticify(CharsImpl);

// src/std/str/encode_utf16.ts
var EncodeUtf16Impl = class extends IteratorImpl {
  constructor(chars, extra) {
    super();
    this.chars = chars;
    this.extra = extra;
  }
  next() {
    if (this.extra.ne(0)) {
      const tmp = this.extra;
      this.extra = u16(0);
      return Some(tmp);
    }
    let buf = [u16(0), u16(0)];
    return this.chars.next().map((ch) => {
      buf = ch.encode_utf16();
      if (buf.length === 2) {
        this.extra = buf[1];
      }
      return buf[0];
    });
  }
  static new(chars, extra) {
    return new this(chars, extra);
  }
};
var EncodeUtf16 = staticify(EncodeUtf16Impl);

// src/std/str/lines.ts
var LinesImpl = class extends IteratorImpl {
  constructor(p) {
    super(p.alloc.split(/\n|\r/g).map((x) => str(x)));
  }
  static new(str2) {
    return new this(str2);
  }
};
var Lines = staticify(LinesImpl);

// src/std/str/match_indices.ts
var MatchIndicesImpl = class extends IteratorImpl {
  constructor(p, pattern) {
    let n = 0;
    super(
      p.matches(pattern).map((x) => [usize(p.alloc.indexOf(x.alloc, n++)), x])
    );
  }
  static new(str2, pattern) {
    return new this(str2, pattern);
  }
};
var MatchIndices = staticify(MatchIndicesImpl);

// src/std/str/matches.ts
var MatchesImpl = class extends IteratorImpl {
  constructor(p, pattern) {
    super((p.alloc.match(str(pattern).alloc) || []).map((x) => str(x)));
  }
  static new(str2, pattern) {
    return new this(str2, pattern);
  }
};
var Matches = staticify(MatchesImpl);

// src/std/str/pattern.ts
var PatternImpl = class {
  constructor(matcher) {
    this.matcher = matcher;
  }
  static new(matcher) {
    return new this(matcher);
  }
  is_contained_in(haystack) {
    if (this.matcher instanceof RegExp) {
      return this.matcher.test(haystack);
    }
    if (this.matcher instanceof str.static) {
      return haystack.includes(this.matcher.alloc);
    }
    if (typeof this.matcher === "string") {
      return haystack.includes(this.matcher);
    }
    if (this.matcher instanceof char.static) {
      return haystack.includes(this.matcher.as_primitive());
    }
    if (is_iter(this.matcher)) {
      for (const value of this.matcher) {
        if (haystack.includes(value.toString())) {
          return true;
        }
      }
      return false;
    }
    for (const c of haystack) {
      if (this.matcher(char(c))) {
        return true;
      }
    }
    return false;
  }
  is_prefix_of(haystack) {
    if (this.matcher instanceof RegExp) {
      const [main] = haystack.match(haystack) || [];
      return main !== void 0 && haystack.indexOf(main) === 0;
    }
    if (this.matcher instanceof str.static) {
      return haystack.startsWith(this.matcher.alloc);
    }
    if (typeof this.matcher === "string") {
      return haystack.startsWith(this.matcher);
    }
    if (this.matcher instanceof char.static) {
      return haystack.startsWith(this.matcher.as_primitive());
    }
    if (is_iter(this.matcher)) {
      for (const value of this.matcher) {
        if (haystack.startsWith(value.toString())) {
          return true;
        }
      }
      return false;
    }
    for (const c of haystack) {
      if (this.matcher(char(c))) {
        if (haystack.startsWith(c)) {
          return true;
        }
      }
    }
    return false;
  }
  is_suffix_of(haystack) {
    if (this.matcher instanceof RegExp) {
      const [main] = haystack.match(haystack) || [];
      return main !== void 0 && haystack.endsWith(main);
    }
    if (this.matcher instanceof str.static) {
      return haystack.endsWith(this.matcher.alloc);
    }
    if (typeof this.matcher === "string") {
      return haystack.endsWith(this.matcher);
    }
    if (this.matcher instanceof char.static) {
      return haystack.endsWith(this.matcher.as_primitive());
    }
    if (is_iter(this.matcher)) {
      for (const value of this.matcher) {
        if (haystack.endsWith(value.toString())) {
          return true;
        }
      }
      return false;
    }
    for (const c of haystack) {
      if (this.matcher(char(c))) {
        if (haystack.endsWith(c)) {
          return true;
        }
      }
    }
    return false;
  }
  strip_prefix_of(haystack) {
    const match2 = this.is_prefix_of(haystack);
    if (!match2) {
      return None;
    }
    if (this.matcher instanceof RegExp) {
      const [main] = haystack.match(haystack) || [];
      return Some(haystack.slice(main?.length || 0));
    }
    if (this.matcher instanceof str.static) {
      return Some(haystack.slice(this.matcher.alloc.length));
    }
    if (typeof this.matcher === "string") {
      return Some(haystack.slice(this.matcher.length));
    }
    if (this.matcher instanceof char.static) {
      return Some(haystack.slice(this.matcher.toString().length));
    }
    if (is_iter(this.matcher)) {
      for (const value of this.matcher) {
        if (haystack.startsWith(value.toString())) {
          return Some(haystack.slice(value.toString().length));
        }
      }
      return None;
    }
    for (const c of haystack) {
      if (this.matcher(char(c))) {
        if (haystack.startsWith(c.toString())) {
          return Some(haystack.slice(c.toString().length));
        }
      }
    }
    return None;
  }
  strip_suffix_of(haystack) {
    const match2 = this.is_suffix_of(haystack);
    if (!match2) {
      return None;
    }
    if (this.matcher instanceof RegExp) {
      const [main] = haystack.match(haystack) || [];
      return Some(haystack.slice(0, main?.length || 0));
    }
    if (this.matcher instanceof str.static) {
      return Some(haystack.slice(0, this.matcher.alloc.length));
    }
    if (typeof this.matcher === "string") {
      return Some(haystack.slice(0, this.matcher.length));
    }
    if (this.matcher instanceof char.static) {
      return Some(haystack.slice(0, this.matcher.toString().length));
    }
    if (is_iter(this.matcher)) {
      for (const value of this.matcher) {
        if (haystack.startsWith(value.toString())) {
          return Some(haystack.slice(0, value.toString().length));
        }
      }
      return None;
    }
    for (const c of haystack) {
      if (this.matcher(char(c))) {
        if (haystack.startsWith(c.toString())) {
          return Some(haystack.slice(0, c.toString().length));
        }
      }
    }
    return None;
  }
  find_in(haystack) {
    const match2 = this.is_contained_in(haystack);
    if (!match2) {
      return None;
    }
    if (this.matcher instanceof RegExp) {
      const [main] = haystack.match(haystack) || [];
      return Some(usize(haystack.indexOf(main || "")));
    }
    if (this.matcher instanceof str.static) {
      return Some(usize(haystack.indexOf(this.matcher.alloc)));
    }
    if (typeof this.matcher === "string") {
      return Some(usize(haystack.indexOf(this.matcher)));
    }
    if (this.matcher instanceof char.static) {
      return Some(usize(haystack.indexOf(this.matcher.toString())));
    }
    if (is_iter(this.matcher)) {
      for (const value of this.matcher) {
        if (haystack.startsWith(value.toString())) {
          return Some(usize(haystack.indexOf(value.toString())));
        }
      }
      return None;
    }
    for (const c of haystack) {
      if (this.matcher(char(c))) {
        if (haystack.startsWith(c.toString())) {
          return Some(usize(haystack.indexOf(c.toString())));
        }
      }
    }
    return None;
  }
  rfind_in(haystack) {
    const match2 = this.is_contained_in(haystack);
    if (!match2) {
      return None;
    }
    if (this.matcher instanceof RegExp) {
      const [main] = haystack.match(haystack) || [];
      return Some(usize(haystack.lastIndexOf(main || "")));
    }
    if (this.matcher instanceof str.static) {
      return Some(usize(haystack.lastIndexOf(this.matcher.alloc)));
    }
    if (typeof this.matcher === "string") {
      return Some(usize(haystack.lastIndexOf(this.matcher)));
    }
    if (this.matcher instanceof char.static) {
      return Some(usize(haystack.lastIndexOf(this.matcher.toString())));
    }
    if (is_iter(this.matcher)) {
      for (const value of this.matcher) {
        if (haystack.startsWith(value.toString())) {
          return Some(usize(haystack.lastIndexOf(value.toString())));
        }
      }
      return None;
    }
    for (const c of haystack) {
      if (this.matcher(char(c))) {
        if (haystack.startsWith(c.toString())) {
          return Some(usize(haystack.lastIndexOf(c.toString())));
        }
      }
    }
    return None;
  }
};
var Pattern = staticify(PatternImpl);

// src/std/str/rmatch_indices.ts
var RMatchIndicesImpl = class extends IteratorImpl {
  constructor(p, pattern) {
    super(DoubleEndedIterator(p.match_indices(pattern)).rev());
  }
  static new(str2, pattern) {
    return new this(str2, pattern);
  }
};
var RMatchIndices = staticify(RMatchIndicesImpl);

// src/std/str/rmatches.ts
var RMatchesImpl = class extends IteratorImpl {
  constructor(p, pattern) {
    super(DoubleEndedIterator(p.matches(pattern)).rev());
  }
  static new(str2, pattern) {
    return new this(str2, pattern);
  }
};
var RMatches = staticify(RMatchesImpl);

// src/std/str/rsplit.ts
var RSplitImpl2 = class extends IteratorImpl {
  constructor(p, pattern) {
    super(DoubleEndedIterator(p.split(pattern)).rev());
  }
  static new(str2, pattern) {
    return new this(str2, pattern);
  }
};
var RSplit2 = staticify(RSplitImpl2);

// src/std/str/rsplit_inclusive.ts
var RSplitInclusiveImpl2 = class extends IteratorImpl {
  constructor(p, pattern) {
    super(DoubleEndedIterator(p.split_inclusive(pattern)).rev());
  }
  static new(str2, pattern) {
    return new this(str2, pattern);
  }
};
var RSplitInclusive2 = staticify(RSplitInclusiveImpl2);

// src/std/str/rsplit_terminator.ts
var RSplitTerminatorImpl = class extends IteratorImpl {
  constructor(p, pattern) {
    super(DoubleEndedIterator(p.split_terminator(pattern)).rev());
  }
  static new(str2, pattern) {
    return new this(str2, pattern);
  }
};
var RSplitTerminator = staticify(RSplitTerminatorImpl);

// src/std/str/rsplitn.ts
var RSplitNImpl2 = class extends IteratorImpl {
  constructor(p, n, pattern) {
    super(DoubleEndedIterator(p.splitn(n, pattern)).rev());
  }
  static new(str2, n, pattern) {
    return new this(str2, n, pattern);
  }
};
var RSplitN2 = staticify(RSplitNImpl2);

// src/std/str/split.ts
var SplitImpl2 = class extends IteratorImpl {
  constructor(p, pattern) {
    super(p.alloc.split(str(pattern).alloc).map((x) => str(x)));
  }
  static new(str2, pattern) {
    return new this(str2, pattern);
  }
};
var Split2 = staticify(SplitImpl2);

// src/std/str/split_ascii_whitespace.ts
var SplitAsciiWhitespaceImpl = class extends IteratorImpl {
  constructor(p) {
    super(p.alloc.split(/ |\t|\r|\n|\x0c/gu).map((x) => str(x)));
  }
  static new(str2) {
    return new this(str2);
  }
};
var SplitAsciiWhitespace = staticify(SplitAsciiWhitespaceImpl);

// src/std/str/split_inclusive.ts
var SplitInclusiveImpl2 = class extends IteratorImpl {
  constructor(p, pattern) {
    const n = str(pattern).alloc;
    super(
      p.alloc.split(n).map((x, i, p2) => str(x + (i === p2.length - 1 ? n : "")))
    );
  }
  static new(str2, pattern) {
    return new this(str2, pattern);
  }
};
var SplitInclusive2 = staticify(SplitInclusiveImpl2);

// src/std/str/split_terminator.ts
var SplitTerminatorImpl = class extends IteratorImpl {
  constructor(p, pattern) {
    const v = p.alloc.split(str(pattern).alloc);
    if (v[v.length - 1] === "") {
      v.pop();
    }
    super(v.map((x) => str(x)));
  }
  static new(str2, pattern) {
    return new this(str2, pattern);
  }
};
var SplitTerminator = staticify(SplitTerminatorImpl);

// src/std/str/split_whitespace.ts
var SplitWhitespaceImpl = class extends IteratorImpl {
  constructor(p) {
    super(p.alloc.split(/\s/g).map((x) => str(x)));
  }
  static new(str2) {
    return new this(str2);
  }
};
var SplitWhitespace = staticify(SplitWhitespaceImpl);

// src/std/str/splitn.ts
var SplitNImpl2 = class extends IteratorImpl {
  constructor(v, n, pattern) {
    super(
      function* () {
        let i = 0n;
        const o = [];
        for (const part of v.split(pattern)) {
          if (size(n).ge(i++)) {
            yield part;
          }
          o.push(part.alloc);
        }
        if (o.length) {
          yield str(o.join(str(pattern).alloc));
        }
      }()
    );
  }
  static new(ptr, n, pattern) {
    return new this(ptr, n, pattern);
  }
};
var SplitN2 = staticify(SplitNImpl2);

// src/std/str/str.ts
var StrImpl = class {
  alloc;
  constructor(value) {
    if (value instanceof u8.static) {
      value = char(String.fromCodePoint(Number(value.as_primitive())));
    }
    if (value instanceof char.static) {
      value = value.value;
    }
    if (Symbol.iterator in value) {
      value = String.fromCodePoint(
        ...[...value].map(
          (x) => x instanceof u8.static ? Number(x.as_primitive()) : x.as_primitive()
        )
      );
    }
    if (value instanceof StrImpl) {
      value = value.alloc;
    }
    this.alloc = value;
  }
  fmt_debug() {
    return '"' + this.escape_debug().alloc + '"';
  }
  fmt_display() {
    return this.alloc;
  }
  clone() {
    return str(this.alloc);
  }
  static new(value) {
    return new this(value);
  }
  len() {
    return usize(this.alloc.length);
  }
  is_empty() {
    return this.len().eq(0);
  }
  as_bytes() {
    const shield = this;
    return slice(
      function* () {
        for (let i = 0; i < shield.alloc.length; i++) {
          yield u8(shield.alloc.codePointAt(i));
        }
      }()
    );
  }
  is_char_boundary(index) {
    index = Number(size(index).as_primitive());
    if (index === 0) {
      return true;
    }
    const option = this.as_bytes().get(index);
    if (option.is_none()) {
      return this.len().eq(index);
    }
    return option.unwrap().is_utf8_char_boundary();
  }
  floor_char_boundary(index) {
    index = size(index);
    if (index.ge(this.len())) {
      return this.len();
    }
    const lower_bound = index.saturating_sub(3);
    const new_index = DoubleEndedIterator(
      this.as_bytes().get_slice_unchecked(lower_bound, index.add(1))
    ).rposition((b) => b.is_utf8_char_boundary());
    return usize(lower_bound.add(new_index.unwrap_unchecked()));
  }
  ceil_char_boundary(index) {
    index = size(index);
    if (index.gt(this.len())) {
      panic("Cannot check char boundary of out-of-bounds indices");
    }
    const upper_bound = min(index.add(4), this.len());
    return this.as_bytes().get_slice_unchecked(index, upper_bound).iter().position((b) => b.is_utf8_char_boundary()).map_or(upper_bound, (pos) => index.add(pos)).into(u8);
  }
  get(index) {
    return this.as_bytes().get(index);
  }
  get_unchecked(index) {
    return this.as_bytes().get_unchecked(index);
  }
  slice(start, end) {
    const slice2 = this.as_bytes().get_slice(start, end);
    return slice2.map((x) => str(x));
  }
  slice_unchecked(start, end) {
    const slice2 = this.as_bytes().get_slice_unchecked(start, end);
    return str(slice2);
  }
  split_at(mid) {
    return [
      this.slice_unchecked(0, mid),
      this.slice_unchecked(mid, this.len())
    ];
  }
  chars() {
    return Chars(this);
  }
  char_indices() {
    return CharIndices(this);
  }
  bytes() {
    return Bytes(this);
  }
  split_whitespace() {
    return SplitWhitespace(this);
  }
  split_ascii_whitespace() {
    return SplitAsciiWhitespace(this);
  }
  lines() {
    return Lines(this);
  }
  encode_utf16() {
    return EncodeUtf16(this.chars(), u16(0));
  }
  contains(pattern) {
    return Pattern(pattern).is_suffix_of(this.alloc);
  }
  starts_with(pattern) {
    return Pattern(pattern).is_prefix_of(this.alloc);
  }
  ends_with(pattern) {
    return Pattern(pattern).is_suffix_of(this.alloc);
  }
  find(pattern) {
    return Pattern(pattern).find_in(this.alloc);
  }
  rfind(pattern) {
    return Pattern(pattern).rfind_in(this.alloc);
  }
  split(pattern) {
    return Split2(this, pattern);
  }
  split_inclusive(pattern) {
    return SplitInclusive2(this, pattern);
  }
  rsplit(pattern) {
    return RSplit2(this, pattern);
  }
  rsplit_inclusive(pattern) {
    return RSplitInclusive2(this, pattern);
  }
  split_terminator(pattern) {
    return SplitTerminator(this, pattern);
  }
  rsplit_terminator(pattern) {
    return RSplitTerminator(this, pattern);
  }
  splitn(n, pattern) {
    return SplitN2(this, n, pattern);
  }
  rsplitn(n, pattern) {
    return RSplitN2(this, n, pattern);
  }
  split_once(delimiter) {
    delimiter = str(delimiter);
    const iof = this.find(delimiter);
    if (iof.is_none()) {
      return None;
    }
    return Some(this.split_at(iof.unwrap()));
  }
  rsplit_once(delimiter) {
    delimiter = str(delimiter);
    const iof = this.rfind(delimiter);
    if (iof.is_none()) {
      return None;
    }
    return Some(this.split_at(iof.unwrap()));
  }
  matches(pattern) {
    return Matches(this, pattern);
  }
  rmatches(pattern) {
    return RMatches(this, pattern);
  }
  match_indices(pattern) {
    return MatchIndices(this, pattern);
  }
  rmatch_indices(pattern) {
    return RMatchIndices(this, pattern);
  }
  trim() {
    return str(this.alloc.trim());
  }
  trim_start() {
    return str(this.alloc.trimStart());
  }
  trim_end() {
    return str(this.alloc.trimEnd());
  }
  strip_prefix(pattern) {
    const opt = Pattern(pattern).strip_prefix_of(this.alloc);
    if (opt.is_none()) {
      return this;
    }
    return str(opt.unwrap());
  }
  strip_suffix(pattern) {
    const opt = Pattern(pattern).strip_suffix_of(this.alloc);
    if (opt.is_none()) {
      return this;
    }
    return str(opt.unwrap());
  }
  trim_start_matches(pattern) {
    let self = str(this);
    while (self.starts_with(pattern)) {
      self = self.strip_prefix(pattern);
    }
    return self;
  }
  trim_end_matches(pattern) {
    let self = str(this);
    while (self.ends_with(pattern)) {
      self = self.strip_suffix(pattern);
    }
    return self;
  }
  trim_matches(pattern) {
    return this.trim_start_matches(pattern).trim_end_matches(pattern);
  }
  parse(x) {
    return x(this.alloc);
  }
  is_ascii() {
    return this.chars().all((x) => x.is_ascii());
  }
  eq_ignore_ascii_case(other) {
    return this.chars().zip(str(other).chars()).all(([a, b]) => a.eq_ignore_ascii_case(b));
  }
  make_ascii_uppercase() {
    this.alloc = str(this.chars().map((x) => x.make_ascii_uppercase())).alloc;
    return this;
  }
  make_ascii_lowercase() {
    this.alloc = str(this.chars().map((x) => x.make_ascii_lowercase())).alloc;
    return this;
  }
  escape_debug() {
    this.alloc = str(
      this.chars().map((x) => x.escape_debug()).flatten()
    ).alloc;
    return this;
  }
  escape_default() {
    this.alloc = str(
      this.chars().map((x) => x.escape_default()).flatten()
    ).alloc;
    return this;
  }
  escape_unicode() {
    this.alloc = str(
      this.chars().map((x) => x.escape_unicode()).flatten()
    ).alloc;
    return this;
  }
  replace(from, to) {
    return str(this.alloc.replace(str(from).alloc, str(to).alloc));
  }
  replacen(pattern, to, count) {
    let i = 0n;
    return str(
      this.alloc.replace(str(pattern).alloc, (g) => {
        if (size(count).lt(i++)) {
          return g;
        }
        return str(to).alloc;
      })
    );
  }
  to_lowercase() {
    return str(this.alloc.toLowerCase());
  }
  to_uppercase() {
    return str(this.alloc.toUpperCase());
  }
  repeat(n) {
    return str(this.alloc.repeat(size(n).into(Number)));
  }
  to_ascii_uppercase() {
    return this.clone().make_ascii_uppercase();
  }
  to_ascii_lowercase() {
    return this.clone().make_ascii_lowercase();
  }
};
var str = staticify(StrImpl);

// src/std/custom.ts
var custom_exports = {};

// src/std/default.ts
var default_exports = {};
__export(default_exports, {
  get_default: () => get_default
});
function get_default(type) {
  return type.default();
}

// src/std/ops/index.ts
var ops_exports = {};
__export(ops_exports, {
  Bound: () => Bound
});

// src/std/ops/traits.ts
var Bound = /* @__PURE__ */ ((Bound2) => {
  Bound2[Bound2["Included"] = 0] = "Included";
  Bound2[Bound2["Excluded"] = 1] = "Excluded";
  Bound2[Bound2["Unbounded"] = 2] = "Unbounded";
  return Bound2;
})(Bound || {});

// src/std/time/index.ts
var time_exports = {};
__export(time_exports, {
  Duration: () => Duration,
  Instant: () => Instant,
  unix_epoch: () => unix_epoch
});

// src/std/time/duration.ts
var _DurationImpl = class {
  secs;
  nanos;
  constructor(secs, nanos) {
    this.secs = u64(secs);
    this.nanos = u32(nanos);
    if (this.nanos.gt(1000000000n)) {
      this.secs.add_assign(this.nanos.div(1000000000n));
      this.nanos.rem_assign(1000000000n);
    }
    if (this.secs.gt((1n << 63n) - 1n)) {
      panic("overflowed past u64 bound");
    }
  }
  fmt_debug() {
    return this.as_secs().fmt_debug() + "s" + this.subsec_nanos().fmt_debug() + "ns";
  }
  static new(secs, nanos) {
    return new this(secs, nanos);
  }
  static from_secs(secs) {
    return new this(secs, 0);
  }
  static from_millis(millis) {
    millis = u64(millis);
    return new this(
      millis.div(this.millis_per_sec),
      millis.rem(this.millis_per_sec).into(u32).mul(this.nanos_per_milli)
    );
  }
  static from_micros(micros) {
    micros = u64(micros);
    return new this(
      micros.div(this.micros_per_sec),
      micros.rem(this.micros_per_sec).into(u32).mul(this.nanos_per_micro)
    );
  }
  static from_nanos(nanos) {
    nanos = u64(nanos);
    return new this(
      nanos.div(this.nanos_per_sec),
      nanos.rem(this.nanos_per_sec).into(u32)
    );
  }
  //
  is_zero() {
    return this.secs.eq(0) && this.nanos.eq(0);
  }
  as_secs() {
    return this.secs;
  }
  subsec_millis() {
    return this.nanos.div(_DurationImpl.nanos_per_milli);
  }
  subsec_micros() {
    return this.nanos.div(_DurationImpl.nanos_per_micro);
  }
  subsec_nanos() {
    return this.nanos;
  }
  as_millis() {
    return this.secs.into(u128).mul(_DurationImpl.millis_per_sec).add(this.nanos.div(_DurationImpl.nanos_per_milli)).into(u128);
  }
  as_micros() {
    return this.secs.into(u128).mul(_DurationImpl.micros_per_sec).add(this.nanos.div(_DurationImpl.nanos_per_micro)).into(u128);
  }
  as_nanos() {
    return this.secs.into(u128).mul(_DurationImpl.nanos_per_sec).add(this.nanos).into(u128);
  }
  checked_add(rhs) {
    const secs_option = this.secs.checked_add(rhs.secs);
    if (secs_option.is_some()) {
      let secs = secs_option.unwrap();
      const nanos = this.nanos.add(rhs.nanos);
      if (nanos.ge(_DurationImpl.nanos_per_sec)) {
        nanos.sub_assign(_DurationImpl.nanos_per_sec);
        const new_secs = secs.checked_add(1);
        if (new_secs.is_some()) {
          secs = new_secs.unwrap();
        } else {
          return None;
        }
      }
      return Some(Duration(secs, nanos));
    } else {
      return None;
    }
  }
  saturating_add(rhs) {
    const value = this.checked_add(rhs);
    if (value.is_some()) {
      return value.unwrap();
    }
    return _DurationImpl.max;
  }
  checked_sub(rhs) {
    const secs_option = this.secs.checked_sub(rhs.secs);
    if (secs_option.is_some()) {
      let secs = secs_option.unwrap();
      const sub_secs = secs.checked_sub(1);
      if (sub_secs.is_some()) {
        secs = sub_secs.unwrap();
        const nanos = this.nanos.add(_DurationImpl.nanos_per_sec).sub(rhs.nanos);
        return Some(Duration(secs, nanos));
      }
    }
    return None;
  }
  saturating_sub(rhs) {
    const value = this.checked_sub(rhs);
    if (value.is_some()) {
      return value.unwrap();
    }
    return _DurationImpl.zero;
  }
  checked_mul(rhs) {
    const total_nanos = this.nanos.into(u64).mul(u64(rhs));
    const extra_secs = total_nanos.div(_DurationImpl.nanos_per_sec.into(u64));
    const nanos = total_nanos.rem(_DurationImpl.nanos_per_sec.into(u64)).into(u32);
    const opt = this.secs.checked_mul(u64(rhs));
    if (opt.is_some()) {
      const raw = opt.unwrap();
      if (raw.checked_add(extra_secs).is_some()) {
        return Some(Duration(raw, nanos));
      }
    }
    return None;
  }
  saturating_mul(rhs) {
    const value = this.checked_mul(rhs);
    if (value.is_some()) {
      return value.unwrap();
    }
    return _DurationImpl.max;
  }
  checked_div(rhs) {
    if (u32(rhs).ne(0)) {
      rhs = u64(rhs);
      const secs = this.secs.div(rhs.into(u64));
      const carry = this.secs.sub(secs).mul(rhs.into(u64));
      const extra_nanos = carry.mul(_DurationImpl.nanos_per_sec.into(u64)).div(rhs.into(u64));
      const nanos = this.nanos.div(rhs.into(u32)).add(extra_nanos.into(u32));
      return Some(_DurationImpl.new(secs, nanos));
    } else {
      return None;
    }
  }
  as_secs_f64() {
    return this.secs.into(f64).add(this.nanos.into(f64).div(_DurationImpl.nanos_per_sec.into(f64)));
  }
  // as_secs_f32, from_secs_f64, from_secs_f32, mul_f64, mul_f32, div_f64, div_f32, div_duration_f64, div_duration_f32
  assign(other) {
    this.secs.assign(other.secs);
    this.nanos.assign(other.nanos);
    return this;
  }
  add(other) {
    return this.checked_add(other).expect("overflow when adding durations");
  }
  add_assign(other) {
    return this.assign(this.add(other));
  }
  sub(other) {
    return this.checked_sub(other).expect(
      "overflow when subtracting durations"
    );
  }
  sub_assign(other) {
    return this.assign(this.sub(other));
  }
  clone() {
    return _DurationImpl.new(this.secs, this.nanos);
  }
  div(other) {
    return this.checked_div(other).expect(
      "overflow when dividing duration by scalar"
    );
  }
  div_assign(other) {
    return this.assign(this.div(other));
  }
  mul(other) {
    return this.checked_mul(other).expect(
      "overflow when multiplying duration by scalar"
    );
  }
  mul_assign(other) {
    return this.assign(this.mul(other));
  }
};
var DurationImpl = _DurationImpl;
__publicField(DurationImpl, "nanos_per_sec", u32(1e9));
__publicField(DurationImpl, "nanos_per_milli", u32(1e6));
__publicField(DurationImpl, "nanos_per_micro", u32(1e3));
__publicField(DurationImpl, "millis_per_sec", u64(1e3));
__publicField(DurationImpl, "micros_per_sec", u64(1e6));
__publicField(DurationImpl, "max", new _DurationImpl(
  (1n << 63n) - 1n,
  _DurationImpl.nanos_per_sec
));
__publicField(DurationImpl, "zero", new _DurationImpl(0, 0));
__publicField(DurationImpl, "second", _DurationImpl.from_secs(1));
__publicField(DurationImpl, "millisecond", _DurationImpl.from_millis(1));
__publicField(DurationImpl, "microsecond", _DurationImpl.from_micros(1));
__publicField(DurationImpl, "nanosecond", _DurationImpl.from_nanos(1));
var Duration = staticify(DurationImpl);

// src/std/time/instant.ts
var InstantImpl = class {
  instant = Date.now();
  static new() {
    return new this();
  }
  static now() {
    return new this();
  }
  static on(raw) {
    const v = this.new();
    v.instant = raw;
    return v;
  }
  saturating_duration_since(earlier) {
    if (earlier.instant > this.instant) {
      return Duration.zero;
    }
    return Duration.from_millis(this.instant - earlier.instant);
  }
  checked_duration_since(earlier) {
    if (earlier.instant > this.instant) {
      return None;
    }
    return Some(Duration.from_millis(this.instant - earlier.instant));
  }
  duration_since(earlier) {
    return this.saturating_duration_since(earlier);
  }
  elapsed() {
    return InstantImpl.now().duration_since(this);
  }
  checked_add(duration) {
    const raw = duration.checked_add(Duration.from_millis(this.instant));
    if (raw.is_none()) {
      return None;
    }
    return Some(InstantImpl.on(raw.unwrap().as_millis().into(Number)));
  }
  checked_sub(duration) {
    const raw = duration.checked_sub(Duration.from_millis(this.instant));
    if (raw.is_none()) {
      return None;
    }
    return Some(InstantImpl.on(raw.unwrap().as_millis().into(Number)));
  }
  add(duration) {
    return this.checked_add(duration).expect(
      "overflow when adding duration to instant"
    );
  }
  sub(duration) {
    return this.checked_sub(duration).expect(
      "overflow when adding duration to instant"
    );
  }
  assign(other) {
    this.instant = other.instant;
    return this;
  }
  add_assign(other) {
    return this.assign(this.add(other));
  }
  sub_assign(other) {
    return this.assign(this.sub(other));
  }
};
var Instant = staticify(InstantImpl);

// src/std/time/consts.ts
var unix_epoch = Instant.on(0);

export { Array2 as Array, ArrayChunks, Chain, Chunks, ChunksExact, Cycle, DecodeUtf16, DecodeUtf16Error, DoubleEndedIterator, Empty, Enumerate, Err, EscapeDebug, EscapeDefault, EscapeUnicode, ExactSizeIterator, Filter, FilterMap, FlatMap, Flatten, FromFn, Fuse, HashMap, HashSet, Inspect, Intersperse, IntersperseWith, IntoIter, Iterator, IteratorImpl, Map2 as Map, MapWhile, None, Ok, Once, OnceWith, Option, Peekable, RChunks, RChunksExact, RSplit, RSplitInclusive, RSplitN, Repeat, RepeatWith, Scan, Skip, SkipWhile, Some, Split, SplitInclusive, SplitN, StepBy, Successors, Take, TakeWhile, types_exports as Types, Vec, Windows, Zip, _, ascii_exports as ascii, assert, assert_eq, assert_ne, bool, cfg, char, clone_exports as clone, cmp_exports as cmp, collections_exports as collections, column, compile_error, concat, consts, convert_exports as convert, core_exports as core, custom_exports as custom, dbg, debug_assert, debug_assert_eq, debug_assert_ne, default_exports as def, empty, env, eprint, eprintln, f64, file, fmt_exports as fmt, format, format_args, from_fn, hash_exports as hash, i128, i16, i32, i64, i8, include, number_exports as int, is_node, is_x86_feature_detected, isize, iter_exports as iter, line, macros_exports as macros, match, module_path, once, once_with, ops_exports as ops, option_exports as option, option_env, panic_exports as panic, print, println, repeat, repeat_with, result_exports as result, result_from, slice, bool_exports as std_bool, char_exports as std_char, str, stringify, successors, time_exports as time, todo, tuple, u128, u16, u32, u64, u8, unimplemented, unit, unreachable, usize, vec, zip };
