interface AsciiExt<Owned> {
    is_ascii(): boolean;
    to_ascii_uppercase(): Owned;
    to_ascii_lowercase(): Owned;
    eq_ignore_ascii_case(this: this, self: this): boolean;
    make_ascii_uppercase(): this;
    make_ascii_lowercase(): this;
}

type ascii_AsciiExt<Owned> = AsciiExt<Owned>;
declare namespace ascii {
  export {
    ascii_AsciiExt as AsciiExt,
  };
}

type FnConstructor = (new (...args: Array<any>) => any) & {
    'new'(...args: Array<any>): any;
};
type Get<T, P> = P extends keyof T ? T[P] : 'prototype' extends keyof T ? P extends keyof T['prototype'] ? T['prototype'][P] : never : never;
type Staticify<T extends FnConstructor> = Get<T, 'new'> & T & {
    [P in keyof InstanceType<T>]: InstanceType<T>[P] extends (...args: infer U) => unknown ? <Self extends InstanceType<T>>(self: Self, ...args: U) => ReturnType<Self[P]> : (...args: ConstructorParameters<T>) => InstanceType<T>[P];
} & {
    static: T;
};
declare const radii: "0123456789abcdefghijklmnopqrstuvwxyz";

interface Clone<T> {
    clone(): T;
}

type clone_Clone<T> = Clone<T>;
declare namespace clone {
  export {
    clone_Clone as Clone,
  };
}

type Anybool = ToBool<boolean>;
type StrToArray<T extends string, N extends Array<string> = []> = T extends `${infer F}${infer R}` ? StrToArray<R, [...N, F]> : N;
type IndexOf<T extends Array<unknown>, U, C extends Array<unknown> = []> = U extends T[number] ? T extends [infer F, ...infer R] ? [U] extends [F] ? C['length'] : C extends [...infer R1] ? IndexOf<R, U, [...R1, 1]> : C : C : -1;
type RadiiIdx = 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36;

interface LogicalOr<Rhs> {
    or(other: Rhs): Rhs | this;
}
interface LogicalAnd<Rhs> {
    and(other: Rhs): Rhs | this;
}
interface LogicalXor<Rhs> {
    xor(other: Rhs): Rhs | this;
}
type _$1 = any;
type ArrayOf<T> = T extends Array<_$1> ? T : [T];
interface ToBool<T extends Anybool = boolean> {
    valueOf(): T;
}

type custom_ArrayOf<T> = ArrayOf<T>;
type custom_LogicalAnd<Rhs> = LogicalAnd<Rhs>;
type custom_LogicalOr<Rhs> = LogicalOr<Rhs>;
type custom_LogicalXor<Rhs> = LogicalXor<Rhs>;
type custom_ToBool<T extends Anybool = boolean> = ToBool<T>;
declare namespace custom {
  export {
    custom_ArrayOf as ArrayOf,
    custom_LogicalAnd as LogicalAnd,
    custom_LogicalOr as LogicalOr,
    custom_LogicalXor as LogicalXor,
    custom_ToBool as ToBool,
    _$1 as _,
  };
}

interface Add<Rhs, Output = Rhs> {
    add(other: Rhs): Output;
}
interface AddAssign<Rhs, Output = Rhs> {
    add_assign(other: Rhs): Output;
}
interface BitAnd<Rhs, Output = Rhs> {
    bitand(other: Rhs): Output;
}
interface BitAndAssign<Rhs, Output = Rhs> {
    bitand_assign(other: Rhs): Output;
}
interface BitOr<Rhs, Output = Rhs> {
    bitor(other: Rhs): Output;
}
interface BitOrAssign<Rhs, Output = Rhs> {
    bitor_assign(other: Rhs): Output;
}
interface BitXor<Rhs, Output = Rhs> {
    bitxor(other: Rhs): Output;
}
interface BitXorAssign<Rhs, Output = Rhs> {
    bitxor_assign(other: Rhs): Output;
}
interface Deref<Target> {
    deref(): Target;
}
interface DerefMut<Target> extends Deref<Target> {
    deref_mut(): Target;
}
interface Div<Rhs, Output = Rhs> {
    div(other: Rhs): Output;
}
interface DivAssign<Rhs, Output = Rhs> {
    div_assign(other: Rhs): Output;
}
interface Drop {
    drop(): void;
}
type Fn<Args, Output = void> = (...args: ArrayOf<Args>) => Output;
type FnMut<Args, Output = void> = Fn<Args, Output>;
type FnOnce<Args, Output = void> = Fn<Args, Output>;
type Indexable<Idx, Output> = Idx extends PropertyKey ? Record<Idx, Output> : Record<never, never>;
type Index<Idx, Output> = Indexable<Idx, Output> & {
    index(index: Idx): Output;
};
type IndexMut<Idx, Output> = Index<Idx, Output> & {
    index_mut(index: Idx): Output;
};
interface Mul<Rhs, Output = Rhs> {
    mul(other: Rhs): Output;
}
interface MulAssign<Rhs, Output = Rhs> {
    mul_assign(other: Rhs): Output;
}
interface Neg<Output> {
    neg(): Output;
}
interface Not<Output> {
    not(): Output;
}
interface RangeBounds<T> {
    start_bound(): Bound$1;
    end_bound(): Bound$1;
    contains(item: T): boolean;
}
declare enum Bound$1 {
    Included = 0,
    Excluded = 1,
    Unbounded = 2
}
interface Rem<Rhs, Output = Rhs> {
    rem(other: Rhs): Output;
}
interface RemAssign<Rhs, Output = Rhs> {
    rem_assign(other: Rhs): Output;
}
interface Shl<Rhs, Output = Rhs> {
    shl(other: Rhs): Output;
}
interface ShlAssign<Rhs, Output = Rhs> {
    shl_assign(other: Rhs): Output;
}
interface Shr<Rhs, Output = Rhs> {
    shr(other: Rhs): Output;
}
interface ShrAssign<Rhs, Output = Rhs> {
    shr_assign(other: Rhs): Output;
}
interface Sub<Rhs, Output = Rhs> {
    sub(other: Rhs): Output;
}
interface SubAssign<Rhs, Output = Rhs> {
    sub_assign(other: Rhs): Output;
}
interface Assign<Rhs> {
    assign(other: Rhs): this;
}
interface Construct<Args extends Array<unknown>, Output> {
    new (...args: Args): Output;
}

type index$6_Add<Rhs, Output = Rhs> = Add<Rhs, Output>;
type index$6_AddAssign<Rhs, Output = Rhs> = AddAssign<Rhs, Output>;
type index$6_Assign<Rhs> = Assign<Rhs>;
type index$6_BitAnd<Rhs, Output = Rhs> = BitAnd<Rhs, Output>;
type index$6_BitAndAssign<Rhs, Output = Rhs> = BitAndAssign<Rhs, Output>;
type index$6_BitOr<Rhs, Output = Rhs> = BitOr<Rhs, Output>;
type index$6_BitOrAssign<Rhs, Output = Rhs> = BitOrAssign<Rhs, Output>;
type index$6_BitXor<Rhs, Output = Rhs> = BitXor<Rhs, Output>;
type index$6_BitXorAssign<Rhs, Output = Rhs> = BitXorAssign<Rhs, Output>;
type index$6_Construct<Args extends Array<unknown>, Output> = Construct<Args, Output>;
type index$6_Deref<Target> = Deref<Target>;
type index$6_DerefMut<Target> = DerefMut<Target>;
type index$6_Div<Rhs, Output = Rhs> = Div<Rhs, Output>;
type index$6_DivAssign<Rhs, Output = Rhs> = DivAssign<Rhs, Output>;
type index$6_Drop = Drop;
type index$6_Fn<Args, Output = void> = Fn<Args, Output>;
type index$6_FnMut<Args, Output = void> = FnMut<Args, Output>;
type index$6_FnOnce<Args, Output = void> = FnOnce<Args, Output>;
type index$6_Index<Idx, Output> = Index<Idx, Output>;
type index$6_IndexMut<Idx, Output> = IndexMut<Idx, Output>;
type index$6_Indexable<Idx, Output> = Indexable<Idx, Output>;
type index$6_Mul<Rhs, Output = Rhs> = Mul<Rhs, Output>;
type index$6_MulAssign<Rhs, Output = Rhs> = MulAssign<Rhs, Output>;
type index$6_Neg<Output> = Neg<Output>;
type index$6_Not<Output> = Not<Output>;
type index$6_RangeBounds<T> = RangeBounds<T>;
type index$6_Rem<Rhs, Output = Rhs> = Rem<Rhs, Output>;
type index$6_RemAssign<Rhs, Output = Rhs> = RemAssign<Rhs, Output>;
type index$6_Shl<Rhs, Output = Rhs> = Shl<Rhs, Output>;
type index$6_ShlAssign<Rhs, Output = Rhs> = ShlAssign<Rhs, Output>;
type index$6_Shr<Rhs, Output = Rhs> = Shr<Rhs, Output>;
type index$6_ShrAssign<Rhs, Output = Rhs> = ShrAssign<Rhs, Output>;
type index$6_Sub<Rhs, Output = Rhs> = Sub<Rhs, Output>;
type index$6_SubAssign<Rhs, Output = Rhs> = SubAssign<Rhs, Output>;
declare namespace index$6 {
  export {
    index$6_Add as Add,
    index$6_AddAssign as AddAssign,
    index$6_Assign as Assign,
    index$6_BitAnd as BitAnd,
    index$6_BitAndAssign as BitAndAssign,
    index$6_BitOr as BitOr,
    index$6_BitOrAssign as BitOrAssign,
    index$6_BitXor as BitXor,
    index$6_BitXorAssign as BitXorAssign,
    Bound$1 as Bound,
    index$6_Construct as Construct,
    index$6_Deref as Deref,
    index$6_DerefMut as DerefMut,
    index$6_Div as Div,
    index$6_DivAssign as DivAssign,
    index$6_Drop as Drop,
    index$6_Fn as Fn,
    index$6_FnMut as FnMut,
    index$6_FnOnce as FnOnce,
    index$6_Index as Index,
    index$6_IndexMut as IndexMut,
    index$6_Indexable as Indexable,
    index$6_Mul as Mul,
    index$6_MulAssign as MulAssign,
    index$6_Neg as Neg,
    index$6_Not as Not,
    index$6_RangeBounds as RangeBounds,
    index$6_Rem as Rem,
    index$6_RemAssign as RemAssign,
    index$6_Shl as Shl,
    index$6_ShlAssign as ShlAssign,
    index$6_Shr as Shr,
    index$6_ShrAssign as ShrAssign,
    index$6_Sub as Sub,
    index$6_SubAssign as SubAssign,
  };
}

interface PartialEq<Rhs, Output = boolean> {
    eq(other: Rhs): Output;
    ne(other: Rhs): Output;
}
type Eq<Self> = PartialEq<Self>;
interface PartialOrd<Rhs, Output = boolean> extends PartialEq<Rhs, Output> {
    partial_cmp(other: Rhs): Ordering;
    lt(other: Rhs): Output;
    le(other: Rhs): Output;
    gt(other: Rhs): Output;
    ge(other: Rhs): Output;
}
declare class Ordering implements Clone<Ordering> {
    value: Ordering.Item;
    constructor(value: Ordering.Item);
    clone(): Ordering;
    clone_from(source: this): this;
    is_eq(): boolean;
    is_ne(): boolean;
    is_lt(): boolean;
    is_gt(): boolean;
    is_le(): boolean;
    is_ge(): boolean;
    reverse(): Ordering;
    then(other: Ordering): Ordering;
    then_with<F extends FnOnce<[], Ordering>>(f: F): Ordering;
}
declare namespace Ordering {
    type Item = -1 | 0 | 1;
    const Less: Ordering;
    const Equal: Ordering;
    const Greater: Ordering;
}
interface Ord<Self> extends Eq<Self>, PartialOrd<Self> {
    cmp(other: Self): Ordering;
    max(other: Self): Self;
    min(other: Self): Self;
    clamp(min: Self, max: Self): Self;
}
declare function max<T extends Ord<T>>(v1: T, v2: T): T;
declare function max_by<T extends Ord<T>, F extends FnOnce<[T, T], Ordering>>(v1: T, v2: T, compare: F): T;
declare function max_by_key<T extends Ord<T>, F extends FnOnce<[T], K>, K extends Ord<K>>(v1: T, v2: T, f: F): T;
declare function min<T extends Ord<T>>(v1: T, v2: T): T;
declare function min_by<T extends Ord<T>, F extends FnOnce<[T, T], Ordering>>(v1: T, v2: T, compare: F): T;
declare function min_by_key<T extends Ord<T>, F extends FnOnce<[T], K>, K extends Ord<K>>(v1: T, v2: T, f: F): T;
declare function has_derivable_partial_eq<T, Rhs = T>(value: T): value is Pick<PartialEq<Rhs>, 'eq'>;
declare function default_partial_eq<T, Rhs = T>(value: T): PartialEq<Rhs>;
declare function has_derivable_partial_ord<T, Rhs = T>(value: T): value is Pick<PartialOrd<Rhs>, 'eq' | 'partial_cmp'>;
declare function default_partial_ord<T, Rhs = T>(value: T): PartialOrd<Rhs>;
declare function is_eq<T, O>(x: T): x is PartialEq<T, O>;
declare function is_cmp<T, O>(x: T): x is PartialOrd<T, O>;

type cmp_Eq<Self> = Eq<Self>;
type cmp_Ord<Self> = Ord<Self>;
declare const cmp_Ordering: typeof Ordering;
type cmp_PartialEq<Rhs, Output = boolean> = PartialEq<Rhs, Output>;
type cmp_PartialOrd<Rhs, Output = boolean> = PartialOrd<Rhs, Output>;
declare const cmp_default_partial_eq: typeof default_partial_eq;
declare const cmp_default_partial_ord: typeof default_partial_ord;
declare const cmp_has_derivable_partial_eq: typeof has_derivable_partial_eq;
declare const cmp_has_derivable_partial_ord: typeof has_derivable_partial_ord;
declare const cmp_is_cmp: typeof is_cmp;
declare const cmp_is_eq: typeof is_eq;
declare const cmp_max: typeof max;
declare const cmp_max_by: typeof max_by;
declare const cmp_max_by_key: typeof max_by_key;
declare const cmp_min: typeof min;
declare const cmp_min_by: typeof min_by;
declare const cmp_min_by_key: typeof min_by_key;
declare namespace cmp {
  export {
    cmp_Eq as Eq,
    cmp_Ord as Ord,
    cmp_Ordering as Ordering,
    cmp_PartialEq as PartialEq,
    cmp_PartialOrd as PartialOrd,
    cmp_default_partial_eq as default_partial_eq,
    cmp_default_partial_ord as default_partial_ord,
    cmp_has_derivable_partial_eq as has_derivable_partial_eq,
    cmp_has_derivable_partial_ord as has_derivable_partial_ord,
    cmp_is_cmp as is_cmp,
    cmp_is_eq as is_eq,
    cmp_max as max,
    cmp_max_by as max_by,
    cmp_max_by_key as max_by_key,
    cmp_min as min,
    cmp_min_by as min_by,
    cmp_min_by_key as min_by_key,
  };
}

interface Default<T> {
    default(this: T): T;
}
declare function get_default<U>(type: Default<U>): U;

type _default_Default<T> = Default<T>;
declare const _default_get_default: typeof get_default;
declare namespace _default {
  export {
    _default_Default as Default,
    _default_get_default as get_default,
  };
}

type Infallible = never;
declare class RefImpl<Self, Output = Self> implements Deref<Output> {
    readonly self: Self;
    value: Output;
    constructor(self: Self, value: Output);
    static new<Self, Output>(self: Self, value: Output): RefImpl<Self, Output>;
    deref(): Output;
}
type Ref<Self, T = Self> = RefImpl<Self, T>;
declare const Ref: Staticify<typeof RefImpl>;
declare class RefMutImpl<Self, Output = Self> implements DerefMut<Output> {
    readonly self: Self;
    value: Output;
    constructor(self: Self, value: Output);
    static new<Self, Output>(self: Self, value: Output): RefMutImpl<Self, Output>;
    deref(): Output;
    deref_mut(): Output;
}
type RefMut<Self, T = Self> = RefMutImpl<Self, T>;
declare const RefMut: Staticify<typeof RefMutImpl>;
interface AsRef<Output> {
    as_ref(): Ref<this, Output>;
}
interface AsMutRef<Output> {
    as_mut_ref(): Ref<this, Output>;
}
interface From<T, Into> {
    from(value: T): Into;
}
interface Into<T> {
    into<U>(f: (value: T) => U): U;
}
interface Cast {
    cast<T>(): T;
}

type convert_AsMutRef<Output> = AsMutRef<Output>;
type convert_AsRef<Output> = AsRef<Output>;
type convert_Cast = Cast;
type convert_From<T, Into> = From<T, Into>;
type convert_Infallible = Infallible;
type convert_Into<T> = Into<T>;
declare const convert_Ref: typeof Ref;
declare const convert_RefMut: typeof RefMut;
declare namespace convert {
  export {
    convert_AsMutRef as AsMutRef,
    convert_AsRef as AsRef,
    convert_Cast as Cast,
    convert_From as From,
    convert_Infallible as Infallible,
    convert_Into as Into,
    convert_Ref as Ref,
    convert_RefMut as RefMut,
  };
}

declare class SomeImpl<T> implements AsRef<T>, AsMutRef<T>, Clone<Option<T>>, PartialEq<Option<T>>, PartialOrd<Option<T>>, LogicalOr<Option<T>>, LogicalAnd<Option<T>>, LogicalXor<Option<T>>, Debug {
    value: T;
    constructor(value: T);
    fmt_debug(this: T extends Debug ? SomeImpl<T> : never): string;
    static new<T>(value: T): SomeImpl<T>;
    clone(): Option<T>;
    some(): boolean;
    none(): boolean;
    is_some(): this is SomeImpl<T>;
    is_some_and(f: FnOnce<[T], boolean>): boolean;
    is_none(): this is NoneImpl<T>;
    as_ref(): Ref<this, T>;
    as_mut_ref(): RefMut<this, T>;
    expect(message: string): T;
    unwrap(): T;
    unwrap_or(def: T): T;
    unwrap_or_else<F extends FnOnce<[], T>>(f: F): T;
    unwrap_or_default(): T;
    unwrap_unchecked(): T;
    map<U, F extends FnOnce<[T], U>>(f: F): Option<U>;
    inspect<F extends FnOnce<[T]>>(f: F): this;
    map_or<U, F extends FnOnce<[T], U>>(def: U, f: F): U;
    map_or_else<U, D extends FnOnce<[], U>, F extends FnOnce<[T], U>>(def: D, f: F): U;
    and<U>(optb: Option<U>): Option<U>;
    and_then<U, F extends FnOnce<[T], Option<U>>>(f: F): Option<U>;
    filter<P extends FnOnce<[T], boolean>>(predicate: P): Option<T>;
    or(optb: Option<T>): this;
    or_else<F extends FnOnce<[], T>>(f: F): this;
    xor(optb: Option<T>): Option<T>;
    insert(value: T): RefMut<this, T>;
    get_or_insert(value: T): RefMut<this, T>;
    get_or_insert_default(): RefMut<this, T>;
    get_or_insert_with<F extends FnOnce<[], T>>(f: F): RefMut<this, T>;
    take(): Option<T>;
    replace(value: T): Option<T>;
    contains<U extends T>(x: U): boolean;
    zip<U>(other: Option<U>): Option<[T, U]>;
    zip_with<U, F extends FnOnce<[T, U], R>, R>(other: Option<U>, f: F): Option<R>;
    eq(other: Option<T>): boolean;
    ne(other: Option<T>): boolean;
    partial_cmp(other: Option<T>): Ordering;
    ge(other: Option<T>): boolean;
    gt(other: Option<T>): boolean;
    le(other: Option<T>): boolean;
    lt(other: Option<T>): boolean;
}
declare class NoneImpl<T> implements AsRef<T>, AsMutRef<T>, Clone<Option<T>>, PartialEq<Option<T>>, PartialOrd<Option<T>>, LogicalOr<Option<T>>, LogicalAnd<Option<T>>, LogicalXor<Option<T>>, Debug {
    value: T;
    static new<T>(): NoneImpl<T>;
    fmt_debug(this: T extends Debug ? NoneImpl<T> : never): string;
    some(): boolean;
    none(): boolean;
    clone(): Option<T>;
    is_some(): this is SomeImpl<T>;
    is_some_and(f: FnOnce<[T], boolean>): false;
    is_none(): this is NoneImpl<T>;
    as_ref(): Ref<this, T>;
    as_mut_ref(): RefMut<this, T>;
    expect(message: string): never;
    unwrap(): never;
    unwrap_or(def: T): T;
    unwrap_or_else<F extends FnOnce<[], T>>(f: F): T;
    unwrap_or_default(): T;
    unwrap_unchecked(): T;
    map<U, F extends FnOnce<[T], U>>(f: F): Option<U>;
    inspect<F extends FnOnce<[T]>>(f: F): void;
    map_or<U, F extends FnOnce<[T], U>>(def: U, f: F): U;
    map_or_else<U, D extends FnOnce<[], U>, F extends FnOnce<[T], U>>(def: D, f: F): U;
    and<U>(optb: Option<U>): Option<U>;
    and_then<U, F extends FnOnce<[T], Option<U>>>(f: F): Option<U>;
    filter<P extends FnOnce<[T]>>(predicate: P): NoneImpl<T>;
    or(optb: Option<T>): Option<T>;
    or_else<F extends FnOnce<[], Option<T>>>(f: F): Option<T>;
    xor(optb: Option<T>): Option<T>;
    insert(value: T): RefMut<this, T>;
    get_or_insert(value: T): RefMut<this, T>;
    get_or_insert_default(): RefMut<T>;
    get_or_insert_with<F extends FnOnce<[], T>>(f: F): RefMut<this, T>;
    take(): this;
    replace(value: T): Option<T>;
    contains<U extends T>(x: U): false;
    zip<U>(other: Option<U>): Option<[T, U]>;
    zip_with<U, F extends FnOnce<[T, U], R>, R>(other: Option<U>, f: F): Option<R>;
    eq(other: Option<T>): boolean;
    ne(other: Option<T>): boolean;
    partial_cmp(other: Option<T>): Ordering;
    ge(other: Option<T>): boolean;
    gt(other: Option<T>): boolean;
    le(other: Option<T>): boolean;
    lt(other: Option<T>): boolean;
}
type Option<T> = None<T> | Some<T>;
declare const Option: {
    is_some<T>(value: Option<T>): boolean;
    is_none<T_1>(value: Option<T_1>): boolean;
    some<T_2>(T: T_2): SomeImpl<T_2>;
    none<T_3>(T?: T_3 | undefined): NoneImpl<T_3>;
};
declare const Some: Staticify<typeof SomeImpl>;
type Some<T> = SomeImpl<T>;
type None<T = _$1> = NoneImpl<T>;
declare const None: None<_$1>;

declare const option_None: typeof None;
declare const option_Option: typeof Option;
type option_Some<T> = Some<T>;
declare namespace option {
  export {
    option_None as None,
    option_Option as Option,
    option_Some as Some,
  };
}

interface ResultImpl<T, E> extends AsMutRef<E | T>, AsRef<E | T>, PartialEq<Result<T, E>>, PartialOrd<Result<T, E>>, Debug {
    is_ok(): boolean;
    is_err(): boolean;
    is_ok_and(f: FnOnce<[T], boolean>): boolean;
    is_err_and(f: FnOnce<[E], boolean>): boolean;
    ok(): Option<T>;
    err(): Option<E>;
    map<U>(f: FnOnce<[T], U>): Result<U, E>;
    map_or<U>(other: U, f: FnOnce<[T], U>): U;
    map_or_else<U>(other: FnOnce<[E], U>, f: FnOnce<[T], U>): U;
    map_err<F>(o: FnOnce<[E], F>): Result<T, F>;
    inspect(f: Fn<[T]>): Result<T, E>;
    inspect_err(f: Fn<[E]>): Result<T, E>;
    expect(message: string): T;
    unwrap(): T;
    expect_err(message: string): E;
    unwrap_err(): E;
    into_ok(): T;
    into_err(): E;
    and<U>(other: Result<U, E>): Result<U, E>;
    and_then<U>(f: FnOnce<[T], Result<U, E>>): Result<U, E>;
    or<F>(other: Result<T, F>): Result<T, F>;
    or_else<F>(f: FnOnce<[E], Result<T, F>>): Result<T, F>;
    unwrap_or(other: T): T;
    unwrap_or_else(f: FnOnce<[E], T>): T;
    unwrap_unchecked(): T;
    unwrap_err_unchecked(): E;
    contains(value: T): boolean;
    contains_err(error: E): boolean;
}
declare class OkImpl<T = void> implements ResultImpl<T, unknown> {
    private value;
    constructor(value?: T);
    fmt_debug(this: T extends Debug ? OkImpl<T> : never): string;
    as_ref(): Ref<this, unknown>;
    as_mut_ref(): RefMut<this, unknown>;
    is_ok(): this is OkImpl<T>;
    is_ok_and(f: FnOnce<[T], boolean>): boolean;
    is_err(): false;
    is_err_and(f: FnOnce<[unknown], boolean>): false;
    ok(): Option<T>;
    err(): None;
    map<U>(f: FnOnce<[T], U>): OkImpl<U>;
    map_or<U>(other: U, f: FnOnce<[T], U>): U;
    map_or_else<U>(other: FnOnce<[unknown], U>, f: FnOnce<[T], U>): U;
    map_err<F>(f: FnOnce<[unknown], F>): this;
    inspect(f: FnOnce<[T]>): this;
    inspect_err(f: FnOnce<[unknown]>): this;
    expect(message: string): T;
    unwrap(): T;
    expect_err(message: string): never;
    unwrap_err(): never;
    into_ok(): T;
    into_err(): never;
    and<U, E>(other: Result<U, E>): Result<U, E>;
    and_then<U, E>(f: FnOnce<[T], Result<U, E>>): Result<U, E>;
    or<F>(other: Result<T, F>): Result<T, F>;
    or_else<F>(f: FnOnce<[unknown], Result<T, F>>): Result<T, F>;
    unwrap_or(other: T): T;
    unwrap_or_else(f: FnOnce<[unknown], T>): T;
    unwrap_unchecked(): T;
    unwrap_err_unchecked(): never;
    contains(value: T): boolean;
    contains_err(error: unknown): boolean;
    static new<T = void>(value?: T): OkImpl<T>;
    eq(other: Result<T, unknown>): boolean;
    ne(other: Result<T, unknown>): boolean;
    partial_cmp(other: Result<T, unknown>): Ordering;
    ge(other: Result<T, unknown>): boolean;
    gt(other: Result<T, unknown>): boolean;
    le(other: Result<T, unknown>): boolean;
    lt(other: Result<T, unknown>): boolean;
}
declare class ErrImpl<E = void> implements ResultImpl<unknown, E> {
    private value;
    constructor(value?: E);
    fmt_debug(this: E extends Debug ? ErrImpl<E> : never): string;
    as_ref(): Ref<this, unknown>;
    as_mut_ref(): RefMut<this, unknown>;
    is_ok(): false;
    is_ok_and(f: FnOnce<[unknown], boolean>): false;
    is_err(): true;
    is_err_and(f: FnOnce<[E], boolean>): boolean;
    ok(): Option<unknown>;
    err(): Option<E>;
    map<U>(f: FnOnce<[unknown], U>): this;
    map_or<U>(other: U, f: FnOnce<[unknown], U>): U;
    map_or_else<U>(other: FnOnce<[E], U>, f: FnOnce<[unknown], U>): U;
    map_err<F>(f: FnOnce<[E], F>): ErrImpl<F>;
    inspect(f: FnOnce<[unknown]>): this;
    inspect_err(f: FnOnce<[E]>): this;
    expect(message: string): never;
    unwrap(): never;
    expect_err(message: string): E;
    unwrap_err(): E;
    into_ok(): never;
    into_err(): E;
    and<U>(other: Result<U, E>): this;
    and_then<U>(f: FnOnce<[unknown], Result<U, E>>): this;
    or<T, F>(other: Result<T, F>): Result<T, F>;
    or_else<T, F>(f: FnOnce<[E], Result<T, F>>): Result<T, F>;
    unwrap_or<T>(other: T): T;
    unwrap_or_else<T>(f: FnOnce<[E], T>): T;
    unwrap_unchecked(): never;
    unwrap_err_unchecked(): E;
    contains(value: never): false;
    contains_err(error: E): boolean;
    static new<E = void>(value?: E): ErrImpl<E>;
    eq(other: Result<unknown, E>): boolean;
    ne(other: Result<unknown, E>): boolean;
    partial_cmp(other: Result<unknown, E>): Ordering;
    ge(other: Result<unknown, E>): boolean;
    gt(other: Result<unknown, E>): boolean;
    le(other: Result<unknown, E>): boolean;
    lt(other: Result<unknown, E>): boolean;
}
type Result<T, E> = Err<E> | Ok<T>;
type Ok<T> = OkImpl<T>;
declare const Ok: Staticify<typeof OkImpl>;
type Err<E> = ErrImpl<E>;
declare const Err: Staticify<typeof ErrImpl>;
declare function result_from<T, E>(f: () => T): Result<T, E>;

declare const result_Err: typeof Err;
declare const result_Ok: typeof Ok;
type result_Result<T, E> = Result<T, E>;
declare const result_result_from: typeof result_from;
declare namespace result {
  export {
    result_Err as Err,
    result_Ok as Ok,
    result_Result as Result,
    result_result_from as result_from,
  };
}

declare class TupleImpl<T extends Array<unknown>> implements Into<T> {
    private readonly alloc;
    constructor(alloc: T);
    static new<T extends Array<unknown>>(alloc: T): TupleImpl<T>;
    get<U extends number>(index: U): T[U];
    into<U>(f: (value: T) => U): U;
    as_primitive(): T;
    [Symbol.iterator](): Generator<T[number], void, undefined>;
}
type tuple<T extends Array<unknown>> = TupleImpl<T>;
declare const tuple: Staticify<typeof TupleImpl>;
declare class UnitImpl extends TupleImpl<[]> {
    constructor();
    static new(): UnitImpl;
    get<U extends number>(index: U): never;
}
type unit = UnitImpl;
declare const unit: Staticify<typeof UnitImpl>;

type R$1 = Result<unit, Error$1>;
interface Binary {
    fmt_binary(): string;
}
interface Debug {
    fmt_debug(): string;
}
interface DebugAlternate {
    fmt_debug_alternate(): string;
}
interface Display {
    fmt_display(): string;
}
interface LowerExp {
    fmt_lower_exp(): string;
}
interface LowerHex {
    fmt_lower_hex(): string;
}
interface Octal {
    fmt_octal(): string;
}
interface Pointer {
    fmt_pointer(): string;
}
interface UpperExp {
    fmt_upper_exp(): string;
}
interface UpperHex {
    fmt_upper_hex(): string;
}
interface Precision {
    fmt_precision(precision: number): string;
}
interface Signed {
    fmt_signed(): '-' | '+';
}
declare class Error$1 {
    message: string;
    constructor(message: string);
}
declare enum Alignment {
    Left = "<",
    Right = ">",
    Center = "^",
    Unknown = ""
}
declare class Formatter {
    private r_buf;
    private argv;
    private result;
    constructor(buf: string);
    with(argv: Record<string, _$1>): this;
    write_fmt(str: string, ...args: Array<_$1>): R$1;
    write(str: string): R$1;
    finish(): Result<string, Error$1>;
}
declare class DebugList {
    private readonly parts;
    entry(entry: Debug): this;
    entries(entries: Iterable<Debug>): this;
    finish(): string;
}
declare class DebugMap {
    private dangling?;
    private readonly parts;
    key(key: Debug): this;
    value(value: Debug): this;
    entry(key: Debug, value: Debug): this;
    entries<K extends Debug, V extends Debug>(entries: Iterable<[K, V]>): this;
    finish(): Result<string, Error$1>;
}
declare class DebugSet {
    private readonly parts;
    entry(entry: Debug): this;
    entries(entries: Iterable<Debug>): this;
    finish(): string;
}
declare class DebugStruct {
    private readonly name;
    private readonly fields;
    constructor(name: string);
    field(name: string, value: Debug): this;
    finish_non_exhaustive(): string;
    finish(): string;
}
declare class DebugTuple {
    private readonly name;
    constructor(name?: string);
    private readonly fields;
    field(value: Debug): this;
    finish(): string;
}

type fmt_Alignment = Alignment;
declare const fmt_Alignment: typeof Alignment;
type fmt_Binary = Binary;
type fmt_Debug = Debug;
type fmt_DebugAlternate = DebugAlternate;
type fmt_DebugList = DebugList;
declare const fmt_DebugList: typeof DebugList;
type fmt_DebugMap = DebugMap;
declare const fmt_DebugMap: typeof DebugMap;
type fmt_DebugSet = DebugSet;
declare const fmt_DebugSet: typeof DebugSet;
type fmt_DebugStruct = DebugStruct;
declare const fmt_DebugStruct: typeof DebugStruct;
type fmt_DebugTuple = DebugTuple;
declare const fmt_DebugTuple: typeof DebugTuple;
type fmt_Display = Display;
type fmt_Formatter = Formatter;
declare const fmt_Formatter: typeof Formatter;
type fmt_LowerExp = LowerExp;
type fmt_LowerHex = LowerHex;
type fmt_Octal = Octal;
type fmt_Pointer = Pointer;
type fmt_Precision = Precision;
type fmt_Signed = Signed;
type fmt_UpperExp = UpperExp;
type fmt_UpperHex = UpperHex;
declare namespace fmt {
  export {
    fmt_Alignment as Alignment,
    fmt_Binary as Binary,
    fmt_Debug as Debug,
    fmt_DebugAlternate as DebugAlternate,
    fmt_DebugList as DebugList,
    fmt_DebugMap as DebugMap,
    fmt_DebugSet as DebugSet,
    fmt_DebugStruct as DebugStruct,
    fmt_DebugTuple as DebugTuple,
    fmt_Display as Display,
    Error$1 as Error,
    fmt_Formatter as Formatter,
    fmt_LowerExp as LowerExp,
    fmt_LowerHex as LowerHex,
    fmt_Octal as Octal,
    fmt_Pointer as Pointer,
    fmt_Precision as Precision,
    R$1 as R,
    fmt_Signed as Signed,
    fmt_UpperExp as UpperExp,
    fmt_UpperHex as UpperHex,
  };
}

declare class BoolImpl implements BitAnd<boolean, BoolImpl>, BitAndAssign<boolean, BoolImpl>, BitOr<boolean, BoolImpl>, BitOrAssign<boolean, BoolImpl>, BitXor<boolean, BoolImpl>, BitXorAssign<boolean, BoolImpl>, Clone<BoolImpl>, Default<BoolImpl>, Not<BoolImpl>, PartialOrd<boolean, BoolImpl>, PartialEq<boolean, BoolImpl>, Display, Debug {
    protected value: boolean;
    constructor(value: Io$1);
    static new(value: boolean): BoolImpl;
    static readonly true: BoolImpl;
    static readonly false: BoolImpl;
    fmt_debug(): string;
    fmt_display(): string;
    as_primitive(): boolean;
    valueOf(): boolean;
    then_some<U>(t: U): Option<U>;
    then<U>(f: FnOnce<[], U>): Option<U>;
    bitand(other: Io$1): BoolImpl;
    bitand_assign(other: Io$1): BoolImpl;
    bitor(other: Io$1): BoolImpl;
    bitor_assign(other: Io$1): BoolImpl;
    bitxor(other: Io$1): BoolImpl;
    bitxor_assign(other: Io$1): BoolImpl;
    not(): BoolImpl;
    clone(): BoolImpl;
    default(): BoolImpl;
    eq(other: Io$1): BoolImpl;
    ne(other: Io$1): BoolImpl;
    partial_cmp(other: Io$1): Ordering;
    ge(other: Io$1): BoolImpl;
    gt(other: Io$1): BoolImpl;
    le(other: Io$1): BoolImpl;
    lt(other: Io$1): BoolImpl;
}
type bool = BoolImpl;
declare const bool: Staticify<typeof BoolImpl>;
type Io$1 = bool | boolean;

declare const bool$1_bool: typeof bool;
declare namespace bool$1 {
  export {
    bool$1_bool as bool,
  };
}

declare enum IntErrorKind {
    Empty = "Empty",
    InvalidDigit = "InvalidDigit",
    PosOverflow = "PosOverflow",
    NegOverflow = "NegOverflow",
    Zero = "Zero"
}

declare class ParseIntErrorImpl extends Error {
    private k;
    constructor(k: IntErrorKind);
    kind(): IntErrorKind;
    static new(k: IntErrorKind): ParseIntErrorImpl;
}
type ParseIntError = ParseIntErrorImpl;
declare const ParseIntError: Staticify<typeof ParseIntErrorImpl>;

declare class SizeImpl implements Add<int, size>, AddAssign<int, size>, Clone<size>, Div<int, size>, DivAssign<int, size>, Mul<int, size>, MulAssign<int, size>, Neg<size>, Rem<int, size>, RemAssign<int, size>, Sub<int, size>, SubAssign<int, size>, BitAnd<int, size>, BitAndAssign<int, size>, BitOr<int, size>, BitOrAssign<int, size>, BitXor<int, size>, BitXorAssign<int, size>, Not<size>, PartialEq<int>, PartialOrd<int>, Eq<size>, Ord<size>, Shl<int, size>, ShlAssign<int, size>, Shr<int, size>, ShrAssign<int, size>, Assign<int>, Into<bigint>, Cast, Binary, Debug, Display, LowerExp, LowerHex, Octal, Signed, UpperExp, UpperHex, Precision {
    value: bigint;
    constructor(value: _$1);
    assign(other: int): this;
    fmt_binary(): string;
    fmt_debug(): string;
    fmt_display(): string;
    fmt_lower_exp(): string;
    fmt_lower_hex(): string;
    fmt_octal(): string;
    fmt_precision(precision: number): string;
    fmt_signed(): '-' | '+';
    fmt_upper_exp(): string;
    fmt_upper_hex(): string;
    cast<T>(): T;
    static new(value: _$1): SizeImpl;
    as_primitive(): bigint;
    valueOf(): bigint;
    static from_str(src: string): Result<size, ParseIntError>;
    count_ones(lim?: int): size;
    count_zeros(lim?: int): size;
    leading_zeros(lim?: int): size;
    trailing_zeros(lim?: int): size;
    leading_ones(lim?: int): size;
    trailing_ones(lim?: int): size;
    protected n_bit_mask(n: int): size;
    rotate_left(n?: int, lim?: int): size;
    rotate_right(n?: int, lim?: int): size;
    swap_bytes(lim?: int): size;
    reverse_bits(lim?: int): size;
    protected unchecked_op(rhs: int, x: (self: bigint, rhs: bigint) => bigint): size;
    protected checked(value: size, [min, max]?: Bound): Option<size>;
    protected checked_op(rhs: int, x: (self: bigint, rhs: bigint) => bigint, lim?: Bound): Option<size>;
    unchecked_add(rhs: int): size;
    checked_add(rhs: int, lim?: Bound): Option<size>;
    unchecked_sub(rhs: int): size;
    checked_sub(rhs: int, lim?: Bound): Option<size>;
    unchecked_mul(rhs: int): size;
    checked_mul(rhs: int, lim?: Bound): Option<size>;
    checked_div(rhs: int, lim?: Bound): Option<size>;
    checked_rem(rhs: int, lim?: Bound): Option<size>;
    protected unchecked_neg(): size;
    checked_neg(lim?: Bound): Option<size>;
    unchecked_shl(rhs: int): size;
    checked_shl(rhs: int, bits?: int): Option<size>;
    unchecked_shr(rhs: int): size;
    checked_shr(rhs: int, bits?: int): Option<size>;
    unchecked_abs(): size;
    checked_abs([min, max]?: Bound): Option<size>;
    unchecked_pow(rhs: int): size;
    checked_pow(rhs: int, lim?: Bound): Option<size>;
    protected saturate(value: size, [min, max]?: Bound): size;
    protected saturating_op(rhs: int, x: (self: bigint, rhs: bigint) => bigint, lim?: Bound): size;
    saturating_add(rhs: int, lim?: Bound): size;
    saturating_sub(rhs: int, lim?: Bound): size;
    saturating_neg(lim?: Bound): size;
    saturating_mul(rhs: int, lim?: Bound): size;
    saturating_div(rhs: int, lim?: Bound): size;
    saturating_pow(exp: int, lim?: Bound): size;
    protected wrapping(value: size, [min, max]?: Bound): size;
    protected wrapping_op(rhs: int, x: (self: bigint, rhs: bigint) => bigint, lim?: Bound): size;
    wrapping_add(rhs: int, lim?: Bound): size;
    wrapping_sub(rhs: int, lim?: Bound): size;
    wrapping_mul(rhs: int, lim?: Bound): size;
    wrapping_div(rhs: int, lim?: Bound): size;
    wrapping_rem(rhs: int, lim?: Bound): size;
    wrapping_neg(lim?: Bound): size;
    wrapping_abs(lim?: Bound): size;
    wrapping_pow(rhs: int, lim?: Bound): size;
    protected overflowing(value: size, lim?: Bound): [size, boolean];
    protected overflowing_op(rhs: int, x: (self: bigint, rhs: bigint) => bigint, lim?: Bound): [size, boolean];
    overflowing_add(rhs: int, lim?: Bound): [size, boolean];
    overflowing_sub(rhs: int, lim?: Bound): [size, boolean];
    overflowing_mul(rhs: int, lim?: Bound): [size, boolean];
    overflowing_div(rhs: int, lim?: Bound): [size, boolean];
    overflowing_rem(rhs: int, lim?: Bound): [size, boolean];
    overflowing_neg(lim?: Bound): [size, boolean];
    overflowing_abs(lim?: Bound): [size, boolean];
    overflowing_pow(exp: int, lim?: Bound): [size, boolean];
    pow(exp: int, lim?: Bound): size;
    next_multiple_of(rhs: int, lim?: Bound): size;
    checked_next_multiple_of(rhs: int, lim?: Bound): Option<size>;
    abs(max?: int): size;
    abs_diff(other: int, max?: int): size;
    signum(): size;
    is_positive(): boolean;
    is_negative(): boolean;
    protected map(f: (x: bigint) => bigint): this;
    into<T>(f: (x: bigint) => T): T;
    add(other: int): size;
    add_assign(other: int): size;
    clone(): size;
    static default(): size;
    div(other: int): size;
    div_assign(other: int): size;
    mul(other: int): size;
    mul_assign(other: int): size;
    neg(): size;
    rem(other: int): size;
    rem_assign(other: int): size;
    sub(other: int): size;
    sub_assign(other: int): size;
    bitand(other: int): SizeImpl;
    bitand_assign(other: int): SizeImpl;
    bitor(other: int): SizeImpl;
    bitor_assign(other: int): SizeImpl;
    bitxor(other: int): SizeImpl;
    bitxor_assign(other: int): SizeImpl;
    shl(other: int): SizeImpl;
    shl_assign(other: int): SizeImpl;
    shr(other: int): SizeImpl;
    shr_assign(other: int): SizeImpl;
    eq(other: int): boolean;
    ne(other: int): boolean;
    not(): size;
    partial_cmp(other: int): Ordering;
    ge(other: int): boolean;
    gt(other: int): boolean;
    le(other: int): boolean;
    lt(other: int): boolean;
    clamp(min: int, max: int): size;
    cmp(other: size): Ordering;
    max(other: size): size;
    min(other: size): size;
}
type size = SizeImpl;
declare const size: Staticify<typeof SizeImpl>;
type int = size | bigint | number;
type Bound = [int, int];

declare class F64Impl implements Ord<Num>, Add<Num, f64>, AddAssign<Num, f64>, Clone<f64>, Div<Num, f64>, DivAssign<Num, f64>, Mul<Num, f64>, MulAssign<Num, f64>, Neg<f64>, Rem<Num, f64>, RemAssign<Num, f64>, Sub<Num, f64>, SubAssign<Num, f64>, Display, Debug, LowerExp, UpperExp, Precision, Signed {
    private value;
    constructor(value: _$1);
    valueOf(): number;
    static new(value: _$1): F64Impl;
    fmt_debug(): string;
    fmt_display(): string;
    fmt_lower_exp(): string;
    fmt_upper_exp(): string;
    fmt_signed(): '-' | '+';
    fmt_precision(precision: number): string;
    private map;
    floor(): this;
    ceil(): this;
    round(): this;
    trunc(): this;
    fract(): this;
    abs(): this;
    signum(): f64;
    copysign(sign: Num): this;
    mul_add(a: Num, b: Num): this;
    div_euclid(rhs: Num): f64;
    rem_euclid(rhs: Num): f64;
    powi(n: Num): this;
    powf(n: Num): this;
    sqrt(): this;
    exp(): this;
    exp2(): f64;
    ln(): f64;
    log(base: Num): f64;
    log2(): f64;
    log10(): f64;
    cbrt(): f64;
    hypot(other: Num): this;
    sin(): this;
    cos(): this;
    tan(): this;
    asin(): this;
    acos(): this;
    atan(): this;
    atan2(other: Num): this;
    sincos(): [f64, f64];
    exp_m1(): this;
    ln1p(): this;
    sinh(): this;
    cosh(): this;
    tanh(): this;
    asinh(): this;
    acosh(): this;
    atanh(): this;
    static readonly radix: bigint;
    static readonly mantissa_digits: bigint;
    static readonly digits: bigint;
    static readonly epsilon: f64;
    static readonly min: f64;
    static readonly min_positive: f64;
    static readonly max: f64;
    static readonly min_exp: bigint;
    static readonly max_exp: bigint;
    static readonly min_10_exp: bigint;
    static readonly max_10_exp: bigint;
    static readonly nan: f64;
    static readonly infinity: f64;
    static readonly neg_infinity: f64;
    is_nan(): boolean;
    is_infinity(): boolean;
    is_finite(): boolean;
    is_normal(): boolean;
    is_sign_positive(): boolean;
    is_sign_negative(): boolean;
    recip(): this;
    to_degrees(): this;
    to_radians(): this;
    maximum(other: Num): f64;
    minimum(other: Num): f64;
    total_cmp(other: Num): Ordering;
    eq(other: Num): boolean;
    ne(other: Num): boolean;
    partial_cmp(other: Num): Ordering;
    ge(other: Num): boolean;
    gt(other: Num): boolean;
    le(other: Num): boolean;
    lt(other: Num): boolean;
    clamp(min: Num, max: Num): f64;
    cmp(other: Num): Ordering;
    max(other: Num): f64;
    min(other: Num): f64;
    add(other: Num): f64;
    add_assign(other: Num): F64Impl;
    clone(): f64;
    static default(): f64;
    div(other: Num): f64;
    div_assign(other: Num): F64Impl;
    mul(other: Num): f64;
    mul_assign(other: Num): F64Impl;
    neg(): F64Impl;
    rem(other: Num): F64Impl;
    rem_assign(other: Num): F64Impl;
    sub(other: Num): f64;
    sub_assign(other: Num): F64Impl;
}
type f64 = F64Impl;
declare const f64: Staticify<typeof F64Impl>;
declare namespace consts {
    const pi: f64;
    const tau: f64;
    const frac_pi_2: f64;
    const frac_pi_3: f64;
    const frac_pi_4: f64;
    const frac_pi_6: f64;
    const frac_pi_8: f64;
    const frac_1_pi: f64;
    const frac_2_pi: f64;
    const frac_2_sqrt_pi: f64;
    const sqrt_2: f64;
    const frac_1_sqrt_2: f64;
    const e: f64;
    const log2_10: f64;
    const log2_e: f64;
    const log10_2: f64;
    const log10_e: f64;
    const ln_2: f64;
    const ln_10: f64;
}
type Num = f64 | bigint | number;

declare class IntSizedImpl<T extends IntSizedImpl<_$1>> extends SizeImpl {
    private bits;
    private unsigned;
    readonly umin: bigint;
    readonly umax: bigint;
    get bound(): [bigint, bigint];
    constructor(value: _$1, bits: bigint, unsigned: boolean);
    static new<T extends IntSizedImpl<_$1>>(value: _$1, bits: bigint, unsigned: boolean): IntSizedImpl<T>;
    private fit;
    abs(): T;
    abs_diff(other: io<T>): T;
    add(other: io<T>): T;
    add_assign(other: io<T>): T;
    as_primitive(): bigint;
    bitand(other: io<T>): T;
    bitand_assign(other: io<T>): T;
    bitor(other: io<T>): T;
    bitor_assign(other: io<T>): T;
    bitxor(other: io<T>): T;
    bitxor_assign(other: io<T>): T;
    clamp(min: io<T>, max: io<T>): T;
    clone(): IntSizedImpl<T>;
    count_ones(): T;
    count_zeros(): T;
    div(other: io<T>): T;
    div_assign(other: io<T>): T;
    eq(other: io<T>): boolean;
    ge(other: io<T>): boolean;
    gt(other: io<T>): boolean;
    le(other: io<T>): boolean;
    lt(other: io<T>): boolean;
    leading_ones(): T;
    leading_zeros(): T;
    trailing_ones(): T;
    trailing_zeros(): T;
    protected map(f: (x: bigint) => bigint): this;
    max(other: T): T;
    min(other: T): T;
    mul(other: io<T>): T;
    mul_assign(other: io<T>): T;
    protected n_bit_mask(n: io<T>): T;
    ne(other: io<T>): boolean;
    neg(): T;
    next_multiple_of(rhs: io<T>): T;
    not(): T;
    pow(exp: io<T>): T;
    rem(other: io<T>): T;
    rem_assign(other: io<T>): T;
    reverse_bits(): T;
    rotate_left(n?: io<T>): T;
    rotate_right(n?: io<T>): T;
    protected saturate(value: T): T;
    saturating_add(rhs: io<T>): T;
    saturating_div(rhs: io<T>): T;
    saturating_mul(rhs: io<T>): T;
    saturating_neg(): T;
    saturating_op(rhs: io<T>, x: (self: bigint, rhs: bigint) => bigint): T;
    saturating_pow(rhs: io<T>): T;
    saturating_sub(rhs: io<T>): T;
    shl(other: io<T>): T;
    shl_assign(other: io<T>): T;
    shr(other: io<T>): T;
    shr_assign(other: io<T>): T;
    signum(): T;
    sub(other: io<T>): T;
    sub_assign(other: io<T>): T;
    swap_bytes(): T;
    unchecked_abs(): T;
    unchecked_add(rhs: io<T>): T;
    unchecked_mul(rhs: io<T>): T;
    unchecked_neg(): T;
    unchecked_op(rhs: io<T>, x: (self: bigint, rhs: bigint) => bigint): T;
    unchecked_pow(rhs: io<T>): T;
    unchecked_shl(rhs: io<T>): T;
    unchecked_shr(rhs: io<T>): T;
    unchecked_sub(rhs: io<T>): T;
    valueOf(): bigint;
    protected wrapping(value: T): T;
    wrapping_abs(): T;
    wrapping_add(rhs: io<T>): T;
    wrapping_div(rhs: io<T>): T;
    wrapping_mul(rhs: io<T>): T;
    wrapping_neg(): T;
    protected wrapping_op(rhs: io<T>, x: (self: bigint, rhs: bigint) => bigint): T;
    wrapping_pow(rhs: io<T>): T;
    wrapping_rem(rhs: io<T>): T;
    wrapping_sub(rhs: io<T>): T;
    protected checked(value: SizeImpl): Option<T>;
    checked_abs(): Option<T>;
    checked_add(rhs: io<T>): Option<T>;
    checked_div(rhs: io<T>): Option<T>;
    checked_mul(rhs: io<T>): Option<T>;
    checked_neg(): Option<T>;
    checked_next_multiple_of(rhs: io<T>): Option<T>;
    protected checked_op(rhs: io<T>, x: (self: bigint, rhs: bigint) => bigint): Option<T>;
    checked_pow(rhs: io<T>): Option<T>;
    checked_rem(rhs: io<T>): Option<T>;
    checked_shl(rhs: io<T>): Option<T>;
    checked_shr(rhs: io<T>): Option<T>;
    checked_sub(rhs: io<T>): Option<T>;
    cmp(other: T): Ordering;
    partial_cmp(other: io<T>): Ordering;
    is_negative(): boolean;
    is_positive(): boolean;
    protected overflowing(value: T): [T, boolean];
    private fix_overflow;
    overflowing_abs(): [T, boolean];
    overflowing_add(rhs: io<T>): [T, boolean];
    overflowing_div(rhs: io<T>): [T, boolean];
    overflowing_mul(rhs: io<T>): [T, boolean];
    overflowing_neg(): [T, boolean];
    overflowing_op(rhs: io<T>, x: (self: bigint, rhs: bigint) => bigint): [T, boolean];
    overflowing_pow(rhs: io<T>): [T, boolean];
    overflowing_rem(rhs: io<T>): [T, boolean];
    overflowing_sub(rhs: io<T>): [T, boolean];
}
type io<T extends IntSizedImpl<_$1>> = T | bigint | number;

declare class I128 extends IntSizedImpl<I128> {
    constructor(value: _$1);
    static new(value: _$1): i128;
}
type i128 = I128;
declare const i128: Staticify<typeof I128>;

declare class I16 extends IntSizedImpl<I16> {
    constructor(value: _$1);
    static new(value: _$1): i16;
}
type i16 = I16;
declare const i16: Staticify<typeof I16>;

declare class I32 extends IntSizedImpl<I32> {
    constructor(value: _$1);
    static new(value: _$1): i32;
}
type i32 = I32;
declare const i32: Staticify<typeof I32>;

declare class I64 extends IntSizedImpl<I64> {
    constructor(value: _$1);
    static new(value: _$1): i64;
}
type i64 = I64;
declare const i64: Staticify<typeof I64>;

declare class I8 extends IntSizedImpl<I8> {
    constructor(value: _$1);
    static new(value: _$1): i8;
}
type i8 = I8;
declare const i8: Staticify<typeof I8>;

declare class ISize extends IntSizedImpl<ISize> {
    constructor(value: _$1);
    static new(value: _$1): isize;
}
type isize = ISize;
declare const isize: Staticify<typeof ISize>;

declare class U128 extends IntSizedImpl<U128> {
    constructor(value: _$1);
    static new(value: _$1): u128;
}
type u128 = U128;
declare const u128: Staticify<typeof U128>;

declare class U16 extends IntSizedImpl<U16> {
    constructor(value: _$1);
    static new(value: _$1): u16;
}
type u16 = U16;
declare const u16: Staticify<typeof U16>;

declare class U32 extends IntSizedImpl<U32> {
    constructor(value: _$1);
    static new(value: _$1): u32;
}
type u32 = U32;
declare const u32: Staticify<typeof U32>;

declare class U64 extends IntSizedImpl<U64> {
    constructor(value: _$1);
    static new(value: _$1): u64;
}
type u64 = U64;
declare const u64: Staticify<typeof U64>;

declare class U8 extends IntSizedImpl<U8> {
    constructor(value: _$1);
    static new(value: _$1): u8;
    is_utf8_char_boundary(): boolean;
}
type u8 = U8;
declare const u8: Staticify<typeof U8>;

declare class USize extends IntSizedImpl<USize> {
    constructor(value: _$1);
    static new(value: _$1): usize;
}
type usize = USize;
declare const usize: Staticify<typeof USize>;

declare const index$5_consts: typeof consts;
declare const index$5_f64: typeof f64;
declare const index$5_i128: typeof i128;
declare const index$5_i16: typeof i16;
declare const index$5_i32: typeof i32;
declare const index$5_i64: typeof i64;
declare const index$5_i8: typeof i8;
declare const index$5_isize: typeof isize;
declare const index$5_u128: typeof u128;
declare const index$5_u16: typeof u16;
declare const index$5_u32: typeof u32;
declare const index$5_u64: typeof u64;
declare const index$5_u8: typeof u8;
declare const index$5_usize: typeof usize;
declare namespace index$5 {
  export {
    index$5_consts as consts,
    index$5_f64 as f64,
    index$5_i128 as i128,
    index$5_i16 as i16,
    index$5_i32 as i32,
    index$5_i64 as i64,
    index$5_i8 as i8,
    index$5_isize as isize,
    index$5_u128 as u128,
    index$5_u16 as u16,
    index$5_u32 as u32,
    index$5_u64 as u64,
    index$5_u8 as u8,
    index$5_usize as usize,
  };
}

declare class IteratorImpl<T> implements Iterable<T> {
    constructor(iter?: Iterable<T>);
    [Symbol.iterator](): Generator<T, void, unknown>;
    static new<T>(iter: Iterable<T>): IteratorImpl<T>;
    iter(): Iterator<T>;
    private dyn;
    private picker;
    next(): Option<T>;
    next_chunk<N extends number>(count: N): Result<Array<T> & {
        length: N;
    }, IteratorImpl<T>>;
    size_hint(): [number, Option<number>];
    count(): number;
    last(): Option<T>;
    advance_by(n: number): Result<void, number>;
    nth(n: number): Option<T>;
    step_by<N extends number>(step: N): StepBy<this, N>;
    chain<U extends Iterable<_$1>>(iter: U): Chain<this, U>;
    zip<U extends Iterable<_$1>>(iter: U): Zip<this, U>;
    intersperse(separator: IntoIter$3<this>): Intersperse<this>;
    intersperse_with<G extends FnMut<[], IntoIter$3<this>>>(separator: G): IntersperseWith<this, G>;
    map<B>(f: FnMut<[T], B>): Map<this, B>;
    for_each<F extends FnMut<[T]>>(f: F): this;
    filter<P extends FnMut<[T], boolean>>(f: P): Filter<this, P>;
    filter_map<B>(f: FnMut<[T], Option<B>>): FilterMap<this, B>;
    enumerate(): Enumerate<this>;
    peekable(): Peekable<this>;
    skip_while<P extends FnMut<[T], boolean>>(p: P): SkipWhile<this, P>;
    take_while<P extends FnMut<[T], boolean>>(p: P): TakeWhile<this, P>;
    map_while<B>(p: FnMut<[T], Option<B>>): MapWhile<this, B>;
    skip<N extends number>(n: N): Skip<this, N>;
    take<N extends number>(n: N): Take<this, N>;
    scan<St, B>(initial_state: St, f: FnMut<[St, T], [St, Option<B>]>): Scan<this, St, B>;
    flat_map<U>(f: FnMut<[T], Iterable<U>>): FlatMap<this, U>;
    flatten(): Flatten<this>;
    fuse(): Fuse<this>;
    inspect(f: FnMut<[T], void>): Inspect<this>;
    collect_into<B extends FromIterator<T>>(into: B): B;
    fold<B>(init: B, f: FnMut<[B, T], B>): B;
    reduce(f: FnMut<[T, T], T>): Option<T>;
    all(f: FnMut<[T], boolean>): boolean;
    any(f: FnMut<[T], boolean>): boolean;
    find(predicate: FnMut<[T], boolean>): Option<T>;
    find_map<B>(f: FnMut<[T], Option<B>>): Option<B>;
    position(predicate: FnMut<[T], boolean>): Option<number>;
    cycle(): Cycle<this>;
    array_chunks<N extends number>(size: N): ArrayChunks<this, N>;
    sum<U>(): T extends Add<U, T> ? Option<T> : None;
    product<U>(): T extends Mul<U, T> ? Option<T> : None;
}
type Iterator<T> = IteratorImpl<T>;
declare const Iterator: Staticify<typeof IteratorImpl>;
interface FromIterator<T> {
    from_iter(iter: Iterable<T>): this;
}
type IntoIter$3<T> = T extends Iterable<infer U> ? U : T;
declare class ArrayChunksImpl<U extends Iterable<_$1>, N extends number> extends IteratorImpl<IteratorImpl<IntoIter$3<U>>> {
    constructor(iter: U, size: N);
    static new<U extends Iterable<_$1>, N extends number>(iter: U, size: N): ArrayChunksImpl<U, N>;
}
type ArrayChunks<U extends Iterable<_$1>, N extends number> = ArrayChunksImpl<U, N>;
declare const ArrayChunks: Staticify<typeof ArrayChunksImpl>;
declare class ChainImpl<T extends Iterable<_$1>, U extends Iterable<_$1>> extends IteratorImpl<IntoIter$3<T> | IntoIter$3<U>> {
    constructor(start: T, end: U);
    next(): Option<IntoIter$3<T> | IntoIter$3<U>>;
    static new<T extends Iterable<_$1>, U extends Iterable<_$1>>(start: T, end: U): Chain<T, U>;
}
type Chain<T extends Iterable<_$1>, U extends Iterable<_$1>> = ChainImpl<T, U>;
declare const Chain: Staticify<typeof ChainImpl>;
declare class CycleImpl<T extends Iterable<_$1>> extends IteratorImpl<IntoIter$3<T>> {
    constructor(iter: T);
    static new<T extends Iterable<_$1>>(iter: T): CycleImpl<T>;
}
type Cycle<T extends Iterable<_$1>> = CycleImpl<T>;
declare const Cycle: Staticify<typeof CycleImpl>;
declare class DoubleEndedIteratorImpl<T extends Iterable<_$1>> extends IteratorImpl<IntoIter$3<T>> {
    constructor(iter: T);
    rev(): DoubleEndedIteratorImpl<Iterable<IntoIter$3<T>>>;
    next_back(): Option<IntoIter$3<T>>;
    advance_back_by(n: number): Result<_$1, number>;
    nth_back(n: number): Option<T>;
    rfold<B>(init: B, f: FnMut<[B, IntoIter$3<T>], B>): B;
    rfind(predicate: FnMut<[IntoIter$3<T>], boolean>): Option<T>;
    rposition(predicate: FnMut<[IntoIter$3<T>], boolean>): Option<number>;
    static new<T extends Iterable<_$1>>(iter: T): DoubleEndedIteratorImpl<T>;
}
type DoubleEndedIterator<T extends Iterable<_$1>> = DoubleEndedIteratorImpl<T>;
declare const DoubleEndedIterator: Staticify<typeof DoubleEndedIteratorImpl>;
declare class EmptyImpl<T> extends IteratorImpl<T> {
    constructor();
    static new<T>(): EmptyImpl<T>;
}
type Empty<T> = EmptyImpl<T>;
declare const Empty: Staticify<typeof EmptyImpl>;
declare class EnumerateImpl<T extends Iterable<_$1>> extends IteratorImpl<[
    number,
    IntoIter$3<T>
]> {
    constructor(iter: T);
    static new<T extends Iterable<_$1>>(iter: T): EnumerateImpl<T>;
}
type Enumerate<T extends Iterable<_$1>> = EnumerateImpl<T>;
declare const Enumerate: Staticify<typeof EnumerateImpl>;
declare class ExactSizeIteratorImpl<T extends Iterable<_$1>, N extends number> extends IteratorImpl<IntoIter$3<T>> {
    private size;
    constructor(iter: T, size: N);
    len(): N;
    is_empty(): N extends 0 ? true : false;
    static new<T extends Iterable<_$1>, N extends number>(iter: T, size: N): ExactSizeIteratorImpl<T, N>;
}
type ExactSizeIterator<T extends Iterable<_$1>, N extends number> = ExactSizeIteratorImpl<T, N>;
declare const ExactSizeIterator: Staticify<typeof ExactSizeIteratorImpl>;
declare class FilterMapImpl<T extends Iterable<_$1>, B> extends IteratorImpl<B> {
    constructor(iter: T, f: FnMut<[IntoIter$3<T>], Option<B>>);
    static new<T extends Iterable<_$1>, B>(iter: T, f: FnMut<[IntoIter$3<T>], Option<B>>): FilterMapImpl<T, B>;
}
type FilterMap<T extends Iterable<_$1>, B> = FilterMapImpl<T, B>;
declare const FilterMap: Staticify<typeof FilterMapImpl>;
declare class FilterImpl<T extends Iterable<_$1>, P extends FnMut<[IntoIter$3<T>], boolean>> extends IteratorImpl<IntoIter$3<T>> {
    constructor(iter: T, f: P);
    static new<T extends Iterable<_$1>, P extends FnMut<[IntoIter$3<T>], boolean>>(iter: T, f: P): FilterImpl<T, P>;
}
type Filter<T extends Iterable<_$1>, P extends FnMut<[IntoIter$3<T>], boolean>> = FilterImpl<T, P>;
declare const Filter: Staticify<typeof FilterImpl>;
declare class FlatMapImpl<T extends Iterable<_$1>, U> extends IteratorImpl<U> {
    constructor(iter: T, f: FnMut<[IntoIter$3<T>], Iterable<U>>);
    static new<T extends Iterable<_$1>, U>(iter: T, f: FnMut<[IntoIter$3<T>], Iterable<U>>): FlatMapImpl<T, U>;
}
type FlatMap<T extends Iterable<_$1>, U> = FlatMapImpl<T, U>;
declare const FlatMap: Staticify<typeof FlatMapImpl>;
declare class FlattenImpl<T extends Iterable<_$1>> extends IteratorImpl<IntoIter$3<T>> {
    constructor(iter: Iterable<IntoIter$3<T> | Iterable<IntoIter$3<T>>>);
    static new<T extends Iterable<_$1>>(iter: T): FlattenImpl<T>;
}
type Flatten<T extends Iterable<_$1>> = FlattenImpl<T>;
declare const Flatten: Staticify<typeof FlattenImpl>;
declare function empty<T>(): Empty<T>;
declare function from_fn<T>(F: FnMut<[], Option<T>>): FromFn<T>;
declare function once<T>(T: T): Once<T>;
declare function once_with<T>(F: FnMut<[], T>): OnceWith<T>;
declare function repeat<T>(T: T): Repeat<T>;
declare function repeat_with<T>(F: FnMut<[], T>): RepeatWith<T>;
declare function successors<T>(first: Option<T>, F: FnMut<[T], Option<T>>): Successors<T>;
declare function zip<A extends Iterable<_$1>, B extends Iterable<_$1>>(A: A, B: B): Zip<A, B>;
declare class FromFnImpl<T> extends IteratorImpl<T> {
    constructor(fn: FnMut<[], Option<T>>);
    static new<T>(fn: FnMut<[], Option<T>>): FromFnImpl<T>;
}
type FromFn<T> = FromFnImpl<T>;
declare const FromFn: Staticify<typeof FromFnImpl>;
declare class FuseImpl<T extends Iterable<_$1>> extends IteratorImpl<IntoIter$3<T>> {
    constructor(iter: T);
    private hit_none;
    next(): Option<IntoIter$3<T>>;
    static new<T extends Iterable<_$1>>(iter: T): FuseImpl<T>;
}
type Fuse<T extends Iterable<_$1>> = FuseImpl<T>;
declare const Fuse: Staticify<typeof FuseImpl>;
declare class InspectImpl<T extends Iterable<_$1>> extends IteratorImpl<IntoIter$3<T>> {
    constructor(iter: T, f: FnMut<[IntoIter$3<T>]>);
    static new<T extends Iterable<_$1>>(iter: T, f: FnMut<[IntoIter$3<T>]>): InspectImpl<T>;
}
type Inspect<T extends Iterable<_$1>> = InspectImpl<T>;
declare const Inspect: Staticify<typeof InspectImpl>;
declare class IntersperseWithImpl<T extends Iterable<_$1>, G extends FnMut<[], IntoIter$3<T>>> extends IteratorImpl<IntoIter$3<T>> {
    constructor(iter: T, separator: G);
    static new<T extends Iterable<_$1>, G extends FnMut<[], IntoIter$3<T>>>(iter: T, separator: G): IntersperseWithImpl<T, G>;
}
type IntersperseWith<T extends Iterable<_$1>, G extends FnMut<[], IntoIter$3<T>>> = IntersperseWithImpl<T, G>;
declare const IntersperseWith: Staticify<typeof IntersperseWithImpl>;
declare class IntersperseImpl<T extends Iterable<_$1>> extends IteratorImpl<IntoIter$3<T>> {
    constructor(iter: T, separator: IntoIter$3<T>);
    static new<T extends Iterable<_$1>>(iter: T, separator: IntoIter$3<T>): IntersperseImpl<T>;
}
type Intersperse<T extends Iterable<_$1>> = IntersperseImpl<T>;
declare const Intersperse: Staticify<typeof IntersperseImpl>;
interface IntoIterator<T, I extends Iterator<T> = Iterator<T>> {
    into_iter(): I;
}
declare class MapWhileImpl<T extends Iterable<_$1>, B> extends IteratorImpl<B> {
    constructor(iter: T, predicate: FnMut<[IntoIter$3<T>], Option<B>>);
    static new<T extends Iterable<_$1>, B>(iter: T, predicate: FnMut<[IntoIter$3<T>], Option<B>>): MapWhileImpl<T, B>;
}
type MapWhile<T extends Iterable<_$1>, B> = MapWhileImpl<T, B>;
declare const MapWhile: Staticify<typeof MapWhileImpl>;
declare class MapImpl<T extends Iterable<_$1>, B> extends IteratorImpl<B> {
    constructor(iter: T, f: FnMut<[IntoIter$3<T>], B>);
    static new<T extends Iterable<_$1>, B>(iter: T, f: FnMut<[IntoIter$3<T>], B>): MapImpl<T, B>;
}
type Map<T extends Iterable<_$1>, B> = MapImpl<T, B>;
declare const Map: Staticify<typeof MapImpl>;
declare class OnceImpl<T> extends IteratorImpl<T> {
    constructor(value: T);
    static new<T>(value: T): OnceImpl<T>;
}
type Once<T> = OnceImpl<T>;
declare const Once: Staticify<typeof OnceImpl>;
declare class OnceWithImpl<T> extends OnceImpl<T> {
    constructor(fn: FnMut<[], T>);
    static new<T>(fn: FnMut<[], T>): OnceWithImpl<T>;
}
type OnceWith<T> = OnceWithImpl<T>;
declare const OnceWith: Staticify<typeof OnceWithImpl>;
declare class PeekableImpl<T extends Iterable<_$1>> extends IteratorImpl<IntoIter$3<T>> {
    constructor(iter: T);
    peek(): Option<IntoIter$3<T>>;
    static new<T extends Iterable<_$1>>(iter: T): PeekableImpl<T>;
}
type Peekable<T extends Iterable<_$1>> = PeekableImpl<T>;
declare const Peekable: Staticify<typeof PeekableImpl>;
declare class RepeatImpl<T> extends IteratorImpl<T> {
    constructor(value: T);
    static new<T>(value: T): RepeatImpl<T>;
}
type Repeat<T> = RepeatImpl<T>;
declare const Repeat: Staticify<typeof RepeatImpl>;
declare class RepeatWithImpl<T> extends RepeatImpl<T> {
    constructor(fn: FnMut<[], T>);
    static new<T>(fn: FnMut<[], T>): RepeatWithImpl<T>;
}
type RepeatWith<T> = RepeatWithImpl<T>;
declare const RepeatWith: Staticify<typeof RepeatWithImpl>;
declare class ScanImpl<T extends Iterable<_$1>, St, B> extends IteratorImpl<[St, B]> {
    private state;
    private f;
    private i;
    constructor(iter: T, state: St, f: FnMut<[St, IntoIter$3<T>], [St, Option<B>]>);
    next(): Option<[St, B]>;
    static new<T extends Iterable<_$1>, St, B>(iter: T, initial_state: St, f: FnMut<[St, IntoIter$3<T>], [St, Option<B>]>): ScanImpl<T, St, B>;
}
type Scan<T extends Iterable<_$1>, St, B> = ScanImpl<T, St, B>;
declare const Scan: Staticify<typeof ScanImpl>;
declare class SkipWhileImpl<T extends Iterable<_$1>, P extends FnMut<[IntoIter$3<T>], boolean>> extends IteratorImpl<IntoIter$3<T>> {
    private predicate;
    constructor(iter: T, predicate: P);
    private hit_true;
    next(): Option<IntoIter$3<T>>;
    static new<T extends Iterable<_$1>, P extends FnMut<[IntoIter$3<T>], boolean>>(iter: T, predicate: P): SkipWhileImpl<T, P>;
}
type SkipWhile<T extends Iterable<_$1>, P extends FnMut<[IntoIter$3<T>], boolean>> = SkipWhileImpl<T, P>;
declare const SkipWhile: Staticify<typeof SkipWhileImpl>;
declare class SkipImpl<T extends Iterable<_$1>, N extends number> extends IteratorImpl<IntoIter$3<T>> {
    constructor(iter: T, n: N);
    static new<T extends Iterable<_$1>, N extends number>(iter: T, n: N): SkipImpl<T, N>;
}
type Skip<T extends Iterable<_$1>, N extends number> = SkipImpl<T, N>;
declare const Skip: Staticify<typeof SkipImpl>;
declare class StepByImpl<T extends Iterable<_$1>, N extends number> extends IteratorImpl<IntoIter$3<T>> {
    private readonly step;
    constructor(step: N, iter: T);
    next(): Option<IntoIter$3<T>>;
    static new<T extends Iterable<_$1>, N extends number>(step: N, iter: T): StepByImpl<T, N>;
}
type StepBy<T extends Iterable<_$1>, N extends number> = StepByImpl<T, N>;
declare const StepBy: Staticify<typeof StepByImpl>;
declare class SuccessorsImpl<T> extends IteratorImpl<T> {
    constructor(first: Option<T>, fn: FnMut<[T], Option<T>>);
    static new<T>(first: Option<T>, fn: FnMut<[T], Option<T>>): SuccessorsImpl<T>;
}
type Successors<T> = SuccessorsImpl<T>;
declare const Successors: Staticify<typeof SuccessorsImpl>;
declare class TakeWhileImpl<T extends Iterable<_$1>, P extends FnMut<[IntoIter$3<T>], boolean>> extends IteratorImpl<IntoIter$3<T>> {
    private predicate;
    constructor(iter: T, predicate: P);
    private hit_false;
    next(): Option<IntoIter$3<T>>;
    static new<T extends Iterable<_$1>, P extends FnMut<[IntoIter$3<T>], boolean>>(iter: T, predicate: P): TakeWhileImpl<T, P>;
}
type TakeWhile<T extends Iterable<_$1>, P extends FnMut<[IntoIter$3<T>], boolean>> = TakeWhileImpl<T, P>;
declare const TakeWhile: Staticify<typeof TakeWhileImpl>;
declare class TakeImpl<T extends Iterable<_$1>, N extends number> extends IteratorImpl<IntoIter$3<T>> {
    constructor(iter: T, n: N);
    static new<T extends Iterable<_$1>, N extends number>(iter: T, n: N): TakeImpl<T, N>;
}
type Take<T extends Iterable<_$1>, N extends number> = TakeImpl<T, N>;
declare const Take: Staticify<typeof TakeImpl>;
declare class ZipImpl<T extends Iterable<_$1>, U extends Iterable<_$1>> extends IteratorImpl<[IntoIter$3<T>, IntoIter$3<U>]> {
    private t;
    private u;
    constructor(T: T, U: U);
    next(): Option<[IntoIter$3<T>, IntoIter$3<U>]>;
    unzip(): [Iterator<IntoIter$3<T>>, Iterator<IntoIter$3<U>>];
    static new<T extends Iterable<_$1>, U extends Iterable<_$1>>(start: T, end: U): ZipImpl<T, U>;
}
type Zip<T extends Iterable<_$1>, U extends Iterable<_$1>> = ZipImpl<T, U>;
declare const Zip: Staticify<typeof ZipImpl>;

declare class DecodeUtf16ErrorImpl<T extends u16> extends Error {
    private surrogate;
    constructor(surrogate: T);
    unpaired_surrogate(): T;
    static new<T extends u16>(surrogate: T): DecodeUtf16ErrorImpl<T>;
}
type DecodeUtf16Error<T extends u16> = DecodeUtf16ErrorImpl<T>;
declare const DecodeUtf16Error: Staticify<typeof DecodeUtf16ErrorImpl>;

declare class DecodeUtf16Impl extends IteratorImpl<Result<char<_$1>, DecodeUtf16Error<_$1>>> {
    constructor(iter: Iterable<io<u16>>);
    static new(iter: Iterable<io<u16>>): DecodeUtf16Impl;
}
type DecodeUtf16 = DecodeUtf16Impl;
declare const DecodeUtf16: Staticify<typeof DecodeUtf16Impl>;

declare class EscapeDebugImpl<T extends string> extends IteratorImpl<char<_$1>> {
    constructor(value: char<T>);
    static new<T extends string>(value: char<T>): EscapeDebugImpl<T>;
}
type EscapeDebug<T extends string> = EscapeDebugImpl<T>;
declare const EscapeDebug: Staticify<typeof EscapeDebugImpl>;

declare class EscapeDefaultImpl<T extends string> extends IteratorImpl<char<_$1>> {
    constructor(value: char<T>);
    static new<T extends string>(value: char<T>): EscapeDefaultImpl<T>;
}
type EscapeDefault<T extends string> = EscapeDefaultImpl<T>;
declare const EscapeDefault: Staticify<typeof EscapeDefaultImpl>;

declare class EscapeUnicodeImpl<T extends string> extends IteratorImpl<char<_$1>> {
    constructor(value: char<T>);
    static new<T extends string>(value: char<T>): EscapeUnicodeImpl<T>;
}
type EscapeUnicode<T extends string> = EscapeUnicodeImpl<T>;
declare const EscapeUnicode: Staticify<typeof EscapeUnicodeImpl>;

type Ascii = AsciiAlphabetic | AsciiControl | AsciiDigit | AsciiPunctuation | AsciiUnrenderables | AsciiWhitespace | ' ' | '¡' | '¿' | '·' | '­' | '"' | '«' | '»' | '§' | '¶' | '\\' | '´' | '¯' | '¨' | '¸' | '°' | '©' | '®' | '±' | '÷' | '×' | '¬' | '¦' | '¤' | '¢' | '£' | '¥' | '¹' | '½' | '¼' | '²' | '³' | '¾' | 'ª' | 'À' | 'Á' | 'Â' | 'Ã' | 'Ä' | 'Å' | 'à' | 'á' | 'â' | 'ã' | 'ä' | 'å' | 'Æ' | 'æ' | 'Ç' | 'ç' | 'Ð' | 'ð' | 'È' | 'É' | 'Ê' | 'Ë' | 'è' | 'é' | 'ê' | 'ë' | 'Ì' | 'Í' | 'Î' | 'Ï' | 'ì' | 'í' | 'î' | 'ï' | 'Ñ' | 'ñ' | 'º' | 'Ò' | 'Ó' | 'Ô' | 'Õ' | 'Ö' | 'Ø' | 'ò' | 'ó' | 'ô' | 'õ' | 'ö' | 'ø' | 'ß' | 'Ù' | 'Ú' | 'Û' | 'Ü' | 'ù' | 'ú' | 'û' | 'ü' | 'Ý' | 'ý' | 'ÿ' | 'Þ' | 'þ' | 'µ';
type E = Extract<AsciiUnrenderables, AsciiControl>;
type AsciiUnrenderables = '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099';
type AsciiUppercase<T extends string, P extends string = ''> = T extends `${infer F}${infer R}` ? F extends Ascii ? AsciiUppercase<R, `${P}${Uppercase<F>}`> : AsciiUppercase<R, `${P}${F}`> : P;
type AsciiLowercase<T extends string, P extends string = ''> = T extends `${infer F}${infer R}` ? F extends Ascii ? AsciiLowercase<R, `${P}${Lowercase<F>}`> : AsciiLowercase<R, `${P}${F}`> : P;
type ToAsciiUppercase<T> = T extends char<infer U> ? char<AsciiUppercase<U>> : never;
type ToAsciiLowercase<T> = T extends char<infer U> ? char<AsciiLowercase<U>> : never;
type AsciiDigit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
type AsciiAlphabetic = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z';
type AsciiHexDigit = AsciiDigit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f';
type AsciiPunctuation = '_' | '-' | ',' | ';' | ':' | '!' | '?' | '.' | '"' | '(' | ')' | '[' | ']' | '{' | '}' | '@' | '*' | '/' | '\'' | '\\' | '&' | '#' | '%' | '`' | '^' | '+' | '<' | '=' | '>' | '|' | '~' | '$';
type AsciiGraphic = Exclude<Ascii, AsciiUnrenderables>;
type AsciiWhitespace = ' ' | '\n' | '\t' | '\u000c' | '\u000d';
type AsciiControl = '\u0000' | '\u000a' | '\u000b' | '\u000c' | '\u000d' | '\u000e' | '\u000f' | '\u0001' | '\u001a' | '\u001b' | '\u001c' | '\u001d' | '\u001e' | '\u001f' | '\u0002' | '\u0003' | '\u0004' | '\u0005' | '\u0006' | '\u0007' | '\u007f' | '\u0008' | '\u0009' | '\u0010' | '\u0011' | '\u0012' | '\u0013' | '\u0014' | '\u0015' | '\u0016' | '\u0017' | '\u0018' | '\u0019';

type types_Ascii = Ascii;
type types_AsciiAlphabetic = AsciiAlphabetic;
type types_AsciiControl = AsciiControl;
type types_AsciiDigit = AsciiDigit;
type types_AsciiGraphic = AsciiGraphic;
type types_AsciiHexDigit = AsciiHexDigit;
type types_AsciiLowercase<T extends string, P extends string = ''> = AsciiLowercase<T, P>;
type types_AsciiPunctuation = AsciiPunctuation;
type types_AsciiUnrenderables = AsciiUnrenderables;
type types_AsciiUppercase<T extends string, P extends string = ''> = AsciiUppercase<T, P>;
type types_AsciiWhitespace = AsciiWhitespace;
type types_E = E;
type types_ToAsciiLowercase<T> = ToAsciiLowercase<T>;
type types_ToAsciiUppercase<T> = ToAsciiUppercase<T>;
declare namespace types {
  export {
    types_Ascii as Ascii,
    types_AsciiAlphabetic as AsciiAlphabetic,
    types_AsciiControl as AsciiControl,
    types_AsciiDigit as AsciiDigit,
    types_AsciiGraphic as AsciiGraphic,
    types_AsciiHexDigit as AsciiHexDigit,
    types_AsciiLowercase as AsciiLowercase,
    types_AsciiPunctuation as AsciiPunctuation,
    types_AsciiUnrenderables as AsciiUnrenderables,
    types_AsciiUppercase as AsciiUppercase,
    types_AsciiWhitespace as AsciiWhitespace,
    types_E as E,
    types_ToAsciiLowercase as ToAsciiLowercase,
    types_ToAsciiUppercase as ToAsciiUppercase,
  };
}

declare class CharImpl<T extends string> implements Ord<char<_$1>>, Display, Debug {
    value: T;
    constructor(value: int | T);
    fmt_debug(): string;
    fmt_display(): string;
    static readonly max: char<'\u{10ffff}'>;
    static readonly replacement_char: char<'\u{fffd}'>;
    static new<T extends string>(value: int | T): CharImpl<T>;
    static decode_utf16(iter: Iterable<io<u16>>): DecodeUtf16;
    static from_u32(u32: number): Option<CharImpl<_$1>>;
    static from_u32_unchecked(u32: number): CharImpl<_$1>;
    static from_digit<U extends RadiiIdx | 0 | 1>(u32: U, radix: RadiiIdx): Option<CharImpl<StrToArray<typeof radii>[U]>>;
    clamp(min: char<_$1>, max: char<_$1>): char<_$1>;
    eq<U extends string>(other: char<U>): T extends U ? true : false;
    ne<U extends string>(other: char<U>): T extends U ? false : true;
    partial_cmp<U extends string>(other: char<U>): Ordering;
    cmp(other: char<_$1>): Ordering;
    ge(other: char<_$1>): boolean;
    gt(other: char<_$1>): boolean;
    le(other: char<_$1>): boolean;
    lt(other: char<_$1>): boolean;
    max<U extends string>(other: char<U>): char<T> | char<U>;
    min<U extends string>(other: char<U>): char<T> | char<U>;
    is_digit(radix: RadiiIdx): boolean;
    to_digit(radix: RadiiIdx): Option<IndexOf<StrToArray<typeof radii>, Lowercase<T>>>;
    codepoint(): number;
    as_primitive(): T;
    escape_unicode(): EscapeUnicode<T>;
    escape_debug(): EscapeDebug<T>;
    escape_default(): EscapeDefault<T>;
    len_utf8(): number;
    len_utf16(): number;
    encode_utf8(): Array<u8>;
    encode_utf16(): Array<u16>;
    private is_category;
    is_alphabetic(): boolean;
    is_lowercase(): boolean;
    is_uppercase(): boolean;
    is_whitespace(): boolean;
    is_alphanumeric(): boolean;
    is_control(): boolean;
    is_numeric(): boolean;
    to_lowercase(): CharImpl<Lowercase<T>>;
    to_uppercase(): CharImpl<Uppercase<T>>;
    is_ascii(): boolean;
    to_ascii_uppercase(): ToAsciiUppercase<this>;
    to_ascii_lowercase(): ToAsciiLowercase<this>;
    eq_ignore_ascii_case<U extends string>(other: char<U>): boolean;
    make_ascii_uppercase(): ToAsciiUppercase<this>;
    make_ascii_lowercase(): ToAsciiLowercase<this>;
    is_ascii_alphabetic(): boolean;
    is_ascii_uppercase(): boolean;
    is_ascii_lowercase(): boolean;
    is_ascii_digit(): boolean;
    is_ascii_alphanumeric(): boolean;
    is_ascii_hexdigit(): boolean;
    is_ascii_punctuation(): boolean;
    is_ascii_graphic(): boolean;
    is_ascii_whitespace(): boolean;
    is_ascii_control(): boolean;
    toString(): string;
}
type char<T extends string = string> = CharImpl<T>;
declare const char: Staticify<typeof CharImpl>;

declare const index$4_DecodeUtf16: typeof DecodeUtf16;
declare const index$4_DecodeUtf16Error: typeof DecodeUtf16Error;
declare const index$4_EscapeDebug: typeof EscapeDebug;
declare const index$4_EscapeDefault: typeof EscapeDefault;
declare const index$4_EscapeUnicode: typeof EscapeUnicode;
declare const index$4_char: typeof char;
declare namespace index$4 {
  export {
    index$4_DecodeUtf16 as DecodeUtf16,
    index$4_DecodeUtf16Error as DecodeUtf16Error,
    index$4_EscapeDebug as EscapeDebug,
    index$4_EscapeDefault as EscapeDefault,
    index$4_EscapeUnicode as EscapeUnicode,
    types as Types,
    index$4_char as char,
  };
}

declare const index$3_ArrayChunks: typeof ArrayChunks;
declare const index$3_Chain: typeof Chain;
declare const index$3_Cycle: typeof Cycle;
declare const index$3_DoubleEndedIterator: typeof DoubleEndedIterator;
declare const index$3_Empty: typeof Empty;
declare const index$3_Enumerate: typeof Enumerate;
declare const index$3_ExactSizeIterator: typeof ExactSizeIterator;
declare const index$3_Filter: typeof Filter;
declare const index$3_FilterMap: typeof FilterMap;
declare const index$3_FlatMap: typeof FlatMap;
declare const index$3_Flatten: typeof Flatten;
declare const index$3_FromFn: typeof FromFn;
type index$3_FromIterator<T> = FromIterator<T>;
declare const index$3_Fuse: typeof Fuse;
declare const index$3_Inspect: typeof Inspect;
declare const index$3_Intersperse: typeof Intersperse;
declare const index$3_IntersperseWith: typeof IntersperseWith;
type index$3_IntoIterator<T, I extends Iterator<T> = Iterator<T>> = IntoIterator<T, I>;
declare const index$3_Iterator: typeof Iterator;
type index$3_IteratorImpl<T> = IteratorImpl<T>;
declare const index$3_IteratorImpl: typeof IteratorImpl;
declare const index$3_Map: typeof Map;
declare const index$3_MapWhile: typeof MapWhile;
declare const index$3_Once: typeof Once;
declare const index$3_OnceWith: typeof OnceWith;
declare const index$3_Peekable: typeof Peekable;
declare const index$3_Repeat: typeof Repeat;
declare const index$3_RepeatWith: typeof RepeatWith;
declare const index$3_Scan: typeof Scan;
declare const index$3_Skip: typeof Skip;
declare const index$3_SkipWhile: typeof SkipWhile;
declare const index$3_StepBy: typeof StepBy;
declare const index$3_Successors: typeof Successors;
declare const index$3_Take: typeof Take;
declare const index$3_TakeWhile: typeof TakeWhile;
declare const index$3_Zip: typeof Zip;
declare const index$3_empty: typeof empty;
declare const index$3_from_fn: typeof from_fn;
declare const index$3_once: typeof once;
declare const index$3_once_with: typeof once_with;
declare const index$3_repeat: typeof repeat;
declare const index$3_repeat_with: typeof repeat_with;
declare const index$3_successors: typeof successors;
declare const index$3_zip: typeof zip;
declare namespace index$3 {
  export {
    index$3_ArrayChunks as ArrayChunks,
    index$3_Chain as Chain,
    index$3_Cycle as Cycle,
    index$3_DoubleEndedIterator as DoubleEndedIterator,
    index$3_Empty as Empty,
    index$3_Enumerate as Enumerate,
    index$3_ExactSizeIterator as ExactSizeIterator,
    index$3_Filter as Filter,
    index$3_FilterMap as FilterMap,
    index$3_FlatMap as FlatMap,
    index$3_Flatten as Flatten,
    index$3_FromFn as FromFn,
    index$3_FromIterator as FromIterator,
    index$3_Fuse as Fuse,
    index$3_Inspect as Inspect,
    index$3_Intersperse as Intersperse,
    index$3_IntersperseWith as IntersperseWith,
    index$3_IntoIterator as IntoIterator,
    index$3_Iterator as Iterator,
    index$3_IteratorImpl as IteratorImpl,
    index$3_Map as Map,
    index$3_MapWhile as MapWhile,
    index$3_Once as Once,
    index$3_OnceWith as OnceWith,
    index$3_Peekable as Peekable,
    index$3_Repeat as Repeat,
    index$3_RepeatWith as RepeatWith,
    index$3_Scan as Scan,
    index$3_Skip as Skip,
    index$3_SkipWhile as SkipWhile,
    index$3_StepBy as StepBy,
    index$3_Successors as Successors,
    index$3_Take as Take,
    index$3_TakeWhile as TakeWhile,
    index$3_Zip as Zip,
    index$3_empty as empty,
    index$3_from_fn as from_fn,
    index$3_once as once,
    index$3_once_with as once_with,
    index$3_repeat as repeat,
    index$3_repeat_with as repeat_with,
    index$3_successors as successors,
    index$3_zip as zip,
  };
}

declare class ChunksExactImpl<T, N extends int> extends IteratorImpl<IteratorImpl<T>> {
    constructor(n: N, v: slice<T>);
    static new<T, N extends int>(n: N, ptr: slice<T>): ChunksExact<T, N>;
}
type ChunksExact<T, N extends int> = ChunksExactImpl<T, N>;
declare const ChunksExact: Staticify<typeof ChunksExactImpl>;

declare class RChunksImpl<T, N extends int> extends IteratorImpl<IteratorImpl<T>> {
    constructor(n: N, v: slice<T>);
    static new<T, N extends int>(n: N, ptr: slice<T>): RChunks<T, N>;
}
type RChunks<T, N extends int> = RChunksImpl<T, N>;
declare const RChunks: Staticify<typeof RChunksImpl>;

declare class RChunksExactImpl<T, N extends int> extends IteratorImpl<IteratorImpl<T>> {
    constructor(n: N, v: slice<T>);
    static new<T, N extends int>(n: N, ptr: slice<T>): RChunksExact<T, N>;
}
type RChunksExact<T, N extends int> = RChunksExactImpl<T, N>;
declare const RChunksExact: Staticify<typeof RChunksExactImpl>;

declare class RSplitImpl$1<T> extends IteratorImpl<IteratorImpl<T>> {
    constructor(v: slice<T>, f: FnMut<[T], boolean>);
    static new<T>(ptr: slice<T>, f: FnMut<[T], boolean>): RSplit$1<T>;
}
type RSplit$1<T> = RSplitImpl$1<T>;
declare const RSplit$1: Staticify<typeof RSplitImpl$1>;

declare class RSplitInclusiveImpl$1<T> extends IteratorImpl<IteratorImpl<T>> {
    constructor(v: slice<T>, f: FnMut<[T], boolean>);
    static new<T>(ptr: slice<T>, f: FnMut<[T], boolean>): RSplitInclusive$1<T>;
}
type RSplitInclusive$1<T> = RSplitInclusiveImpl$1<T>;
declare const RSplitInclusive$1: Staticify<typeof RSplitInclusiveImpl$1>;

declare class RSplitNImpl$1<T> extends IteratorImpl<IteratorImpl<T>> {
    constructor(v: slice<T>, n: int, f: FnMut<[T], boolean>);
    static new<T>(ptr: slice<T>, n: int, f: FnMut<[T], boolean>): RSplitN$1<T>;
}
type RSplitN$1<T> = RSplitNImpl$1<T>;
declare const RSplitN$1: Staticify<typeof RSplitNImpl$1>;

declare class SplitImpl$1<T> extends IteratorImpl<IteratorImpl<T>> {
    constructor(v: slice<T>, f: FnMut<[T], boolean>);
    static new<T>(ptr: slice<T>, f: FnMut<[T], boolean>): Split$1<T>;
}
type Split$1<T> = SplitImpl$1<T>;
declare const Split$1: Staticify<typeof SplitImpl$1>;

declare class SplitInclusiveImpl$1<T> extends IteratorImpl<IteratorImpl<T>> {
    constructor(v: slice<T>, f: FnMut<[T], boolean>);
    static new<T>(ptr: slice<T>, f: FnMut<[T], boolean>): SplitInclusive$1<T>;
}
type SplitInclusive$1<T> = SplitInclusiveImpl$1<T>;
declare const SplitInclusive$1: Staticify<typeof SplitInclusiveImpl$1>;

declare class SplitNImpl$1<T> extends IteratorImpl<IteratorImpl<T>> {
    constructor(v: slice<T>, n: int, f: FnMut<[T], boolean>);
    static new<T>(ptr: slice<T>, n: int, f: FnMut<[T], boolean>): SplitN$1<T>;
}
type SplitN$1<T> = SplitNImpl$1<T>;
declare const SplitN$1: Staticify<typeof SplitNImpl$1>;

declare class WindowsImpl<T, N extends int> extends IteratorImpl<IteratorImpl<T>> {
    constructor(n: N, v: slice<T>);
    static new<T, N extends int>(n: N, ptr: slice<T>): Windows<T, N>;
}
type Windows<T, N extends int> = WindowsImpl<T, N>;
declare const Windows: Staticify<typeof WindowsImpl>;

declare class SliceImpl<T> implements PartialEq<Iterable<T>>, Eq<Iterable<T>>, PartialOrd<Iterable<T>> {
    ptr: Array<T>;
    constructor(slice: Iterable<T>);
    static default<T>(): SliceImpl<T>;
    static new<T>(slice: Iterable<T>): slice<T>;
    len(): usize;
    is_empty(): boolean;
    first(): Option<T>;
    split_first(): Option<[T, SliceImpl<T>]>;
    last(): Option<T>;
    split_last(): Option<[T, SliceImpl<T>]>;
    get(index: int): Option<T>;
    get_unchecked(index: int): T;
    get_slice(start: int, end: int): Option<SliceImpl<T>>;
    get_slice_unchecked(start: int, end: int): SliceImpl<T>;
    swap(a: int, b: int): this;
    swap_unchecked(a: int, b: int): this;
    reverse(): this;
    [Symbol.iterator](): Generator<T, void, unknown>;
    iter(): Iterator<T>;
    windows<N extends int>(n: N): Windows<T, N>;
    chunks<N extends int>(n: N): Chunks<T, N>;
    chunks_exact<N extends int>(n: N): ChunksExact<T, N>;
    rchunks<N extends int>(n: N): RChunks<T, N>;
    rchunks_exact<N extends int>(n: N): RChunksExact<T, N>;
    split_at(n: int): [SliceImpl<T>, SliceImpl<T>];
    split_at_unchecked(n: int): [SliceImpl<T>, SliceImpl<T>];
    split(p: FnMut<[T], boolean>): Split$1<T>;
    split_inclusive(p: FnMut<[T], boolean>): SplitInclusive$1<T>;
    rsplit(p: FnMut<[T], boolean>): RSplit$1<T>;
    rsplit_inclusive(p: FnMut<[T], boolean>): RSplitInclusive$1<T>;
    splitn(n: int, f: FnMut<[T], boolean>): SplitN$1<T>;
    rsplitn(n: int, f: FnMut<[T], boolean>): RSplitN$1<T>;
    contains(x: T): boolean;
    starts_with(needle: Iterable<T>): boolean;
    ends_with(needle: Iterable<T>): boolean;
    strip_prefix(prefix: Iterable<T>): Option<SliceImpl<T>>;
    strip_suffix(suffix: Iterable<T>): Option<SliceImpl<T>>;
    sort(): this;
    sort_by(compare: FnMut<[T, T], Ordering>): this;
    concat(i: Iterable<T>): this;
    rotate_left(mid: io<u8>): this;
    rotate_right(mid: io<u8>): this;
    fill(value: T): this;
    fill_with(f: FnMut<[], T>): this;
    eq(other: Iterable<T>): boolean;
    ne(other: Iterable<T>): boolean;
    partial_cmp(other: Iterable<T>): Ordering;
    lt(other: Iterable<T>): boolean;
    le(other: Iterable<T>): boolean;
    gt(other: Iterable<T>): boolean;
    ge(other: Iterable<T>): boolean;
}
type slice<T> = SliceImpl<T>;
declare const slice: Staticify<typeof SliceImpl>;

declare class ChunksImpl<T, N extends int> extends IteratorImpl<IteratorImpl<T>> {
    constructor(n: N, v: slice<T>);
    static new<T, N extends int>(n: N, ptr: slice<T>): Chunks<T, N>;
}
type Chunks<T, N extends int> = ChunksImpl<T, N>;
declare const Chunks: Staticify<typeof ChunksImpl>;

declare class IntoIterImpl$2<T> extends IteratorImpl<T> {
    constructor(value: Vec<T>);
    static new<T>(vec: Vec<T>): IntoIterImpl$2<T>;
}
type IntoIter$2<T> = IntoIterImpl$2<T>;
declare const IntoIter$2: Staticify<typeof IntoIterImpl$2>;

declare class VecImpl<T> {
    readonly alloc: Array<Option<T>>;
    static new<T>(): VecImpl<T>;
    static with_capacity<T>(capacity: io<usize>): VecImpl<T>;
    [Symbol.iterator](): Generator<T, void, unknown>;
    capacity(): usize;
    private capacity_extension;
    reserve(additional: io<usize>): this;
    reserve_exact(additional: io<usize>): this;
    private has_none_tail;
    shrink_to_fit(): this;
    shrink_to(to: io<usize>): this;
    len(): usize;
    truncate(len: io<usize>): this;
    as_slice(): slice<T>;
    get(index: io<usize>): Option<T>;
    private last;
    private oob;
    swap_remove(index: number): Option<T>;
    insert(index: io<usize>, element: T): this;
    remove(index: io<usize>): Option<T>;
    retain(f: FnOnce<[T], boolean>): this;
    push(element: T): this;
    push_within_capacity(element: T): Result<null, T>;
    pop(): Option<T>;
    append(other: Vec<T>): this;
    drain([range_min, range_max]: [io<usize>, io<usize>]): Vec<T>;
    clear(): this;
    is_empty(): boolean;
    split_off(at: io<usize>): Vec<T>;
    resize_with(new_len: io<usize>, f: FnOnce<[], T>): this;
    resize(newLen: io<usize>, t: T): this;
    extend(iter: Iterable<T>): this;
    join(str: string): string;
    into_iter(): IntoIter$2<T>;
    iter(): Iterator<T>;
    clone(): Vec<T>;
    static from_iter<T>(i: Iterable<T>): Vec<T>;
    index_of(value: T): usize;
}
type Vec<T> = VecImpl<T>;
declare const Vec: Staticify<typeof VecImpl>;

declare class IntoIterImpl$1<K, V> extends IteratorImpl<[K, V]> {
    constructor(source: HashMap<K, V>);
    static new<K, V>(source: HashMap<K, V>): IntoIterImpl$1<K, V>;
}
type IntoIter$1<K, V> = IntoIterImpl$1<K, V>;
declare const IntoIter$1: Staticify<typeof IntoIterImpl$1>;

declare class IntoKeysImpl<K, V> extends IteratorImpl<K> {
    constructor(source: HashMap<K, V>);
    static new<K, V>(source: HashMap<K, V>): IntoKeysImpl<K, V>;
}
type IntoKeys<K, V> = IntoKeysImpl<K, V>;
declare const IntoKeys: Staticify<typeof IntoKeysImpl>;

declare class IntoValuesImpl<K, V> extends IteratorImpl<V> {
    constructor(source: HashMap<K, V>);
    static new<K, V>(source: HashMap<K, V>): IntoValuesImpl<K, V>;
}
type IntoValues<K, V> = IntoValuesImpl<K, V>;
declare const IntoValues: Staticify<typeof IntoValuesImpl>;

declare class IterImpl$1<K, V> extends IteratorImpl<[K, V]> {
    constructor(source: HashMap<K, V>);
    static new<K, V>(source: HashMap<K, V>): IterImpl$1<K, V>;
}
type Iter$1<K, V> = IterImpl$1<K, V>;
declare const Iter$1: Staticify<typeof IterImpl$1>;

declare class KeysImpl<K, V> extends IteratorImpl<K> {
    constructor(source: HashMap<K, V>);
    static new<K, V>(source: HashMap<K, V>): KeysImpl<K, V>;
}
type Keys<K, V> = KeysImpl<K, V>;
declare const Keys: Staticify<typeof KeysImpl>;

declare class ValuesImpl<K, V> extends IteratorImpl<V> {
    constructor(source: HashMap<K, V>);
    static new<K, V>(source: HashMap<K, V>): ValuesImpl<K, V>;
}
type Values<K, V> = ValuesImpl<K, V>;
declare const Values: Staticify<typeof ValuesImpl>;

declare class HashMapImpl<K, V> implements Debug {
    vec: Vec<[K, V]>;
    fmt_debug(this: K extends Debug ? V extends Debug ? HashMapImpl<K, V> : never : never): string;
    static new<K, V>(): HashMapImpl<K, V>;
    static with_capacity<K, V>(capacity: io<usize>): HashMapImpl<K, V>;
    capacity(): usize;
    keys(): Keys<K, V>;
    into_keys(): IntoKeys<K, V>;
    values(): Values<K, V>;
    into_values(): IntoValues<K, V>;
    iter(): Iter$1<K, V>;
    into_iter(): IntoIter$1<K, V>;
    len(): usize;
    is_empty(): boolean;
    drain(): IntoIter$1<K, V>;
    retain(f: FnMut<[K, V], boolean>): this;
    clear(): this;
    reserve(additional: io<usize>): this;
    shrink_to_fit(): this;
    shrink_to(min_capacity: io<usize>): this;
    entry(key: K): Option<[K, V]>;
    private entry_index;
    get(k: K): Option<V>;
    get_key_value(k: K): Option<[K, V]>;
    get_many(keys: Iterable<K>): Option<Vec<V>>;
    contains_key(k: K): boolean;
    insert(k: K, v: V): Option<V>;
    remove(k: K): Option<V>;
    remove_entry(k: K): Option<[K, V]>;
    static from_iter<K, V>(i: Iterable<[K, V]>): HashMapImpl<K, V>;
}
type HashMap<K, V> = HashMapImpl<K, V>;
declare const HashMap: Staticify<typeof HashMapImpl>;

declare class IntersectionImpl<T> extends IteratorImpl<T> {
    constructor(source: HashSet<T>, target: HashSet<T>);
    static new<T>(source: HashSet<T>, target: HashSet<T>): IntersectionImpl<T>;
}
type Intersection<T> = IntersectionImpl<T>;
declare const Intersection: Staticify<typeof IntersectionImpl>;

declare class IntoIterImpl<T> extends IteratorImpl<T> {
    constructor(source: HashSet<T>);
    static new<T>(source: HashSet<T>): IntoIterImpl<T>;
}
type IntoIter<T> = IntoIterImpl<T>;
declare const IntoIter: Staticify<typeof IntoIterImpl>;

declare class IterImpl<T> extends IteratorImpl<T> {
    constructor(source: HashSet<T>);
    static new<T>(source: HashSet<T>): IterImpl<T>;
}
type Iter<T> = IterImpl<T>;
declare const Iter: Staticify<typeof IterImpl>;

declare class SymmetricDifferenceImpl<T> extends IteratorImpl<T> {
    constructor(source: HashSet<T>, target: HashSet<T>);
    static new<T>(source: HashSet<T>, target: HashSet<T>): SymmetricDifferenceImpl<T>;
}
type SymmetricDifference<T> = SymmetricDifferenceImpl<T>;
declare const SymmetricDifference: Staticify<typeof SymmetricDifferenceImpl>;

declare class UnionImpl<T> extends IteratorImpl<T> {
    constructor(source: HashSet<T>, target: HashSet<T>);
    static new<T>(source: HashSet<T>, target: HashSet<T>): UnionImpl<T>;
}
type Union<T> = UnionImpl<T>;
declare const Union: Staticify<typeof UnionImpl>;

declare class HashSetImpl<T> implements IntoIterator<T> {
    vec: Vec<T>;
    static new<T>(): HashSetImpl<T>;
    static with_capacity<T>(capacity: io<usize>): HashSetImpl<T>;
    iter(): Iter<T>;
    len(): usize;
    is_empty(): boolean;
    retain(f: FnOnce<[T], boolean>): this;
    clear(): this;
    reserve(additional: io<usize>): this;
    shrink_to_fit(): this;
    shrink_to(min_capacity: io<usize>): this;
    difference(other: HashSet<T>): Difference<T>;
    symmetric_difference(other: HashSet<T>): SymmetricDifference<T>;
    intersection(other: HashSet<T>): Intersection<T>;
    union(other: HashSet<T>): Union<T>;
    get(key: T): Option<T>;
    contains(key: T): boolean;
    get_or_insert(value: T): T;
    get_or_insert_with(value: T, f: FnOnce<[T], T>): T;
    is_disjoint(other: HashSet<T>): boolean;
    is_subset(other: HashSet<T>): boolean;
    is_superset(other: HashSet<T>): boolean;
    insert(value: T): this;
    replace(value: T): this;
    remove(T: T): this;
    take(T: T): Option<T>;
    into_iter(): IntoIter<T>;
    static from_iter<T>(iter: Iterable<T>): HashSetImpl<T>;
}
type HashSet<T> = HashSetImpl<T>;
declare const HashSet: Staticify<typeof HashSetImpl>;

declare class DifferenceImpl<T> extends IteratorImpl<T> {
    constructor(source: HashSet<T>, target: HashSet<T>);
    static new<T>(source: HashSet<T>, target: HashSet<T>): DifferenceImpl<T>;
}
type Difference<T> = DifferenceImpl<T>;
declare const Difference: Staticify<typeof DifferenceImpl>;

declare const index$2_HashMap: typeof HashMap;
declare const index$2_HashSet: typeof HashSet;
declare namespace index$2 {
  export {
    index$2_HashMap as HashMap,
    index$2_HashSet as HashSet,
  };
}

type Rw<T> = globalThis.Array<T>;
declare class ArrayImpl<T> {
    private alloc;
    constructor(alloc: Rw<T>);
    static new<T>(value: Rw<T>): ArrayImpl<T>;
    static with_length<T>(value: T, len: int): ArrayImpl<T>;
    [Symbol.iterator](): Generator<T, void, unknown>;
    map<U>(f: FnMut<[T], U>): Array$1<U>;
    zip<U>(rhs: Iterable<U>): ArrayImpl<[T, U]>;
    as_slice(): slice<T>;
    get(index: int): T;
    get_slice(start: int, end: int): ArrayImpl<T>;
    len(): usize;
}
type Array$1<T> = ArrayImpl<T>;
declare const Array$1: Staticify<typeof ArrayImpl>;

declare class Match<T, U> {
    private val;
    constructor(val: T);
    static new<T, U>(value: T): Match<T, U>;
    private readonly arms;
    value(val: T, result: Resolve<T, U>): this;
    union(val: Array<T>, result: Resolve<T, U>): this;
    wildcard(result: Resolve<T, U>): this;
    output(): U;
}
type Arm<T> = Array<T> | T | typeof _;
type Resolve<T, U> = U | ((T: T) => U);
declare const match: Staticify<typeof Match>;
declare const _: unique symbol;

declare class BytesImpl extends IteratorImpl<u8> {
    constructor(str: str);
    static new(str: str): BytesImpl;
}
type Bytes = BytesImpl;
declare const Bytes: Staticify<typeof BytesImpl>;

declare class CharIndicesImpl extends IteratorImpl<[usize, char<_$1>]> {
    constructor(str: str);
    static new(str: str): CharIndicesImpl;
}
type CharIndices = CharIndicesImpl;
declare const CharIndices: Staticify<typeof CharIndicesImpl>;

declare class CharsImpl extends IteratorImpl<char<_$1>> {
    constructor(str: str);
    static new(str: str): CharsImpl;
}
type Chars = CharsImpl;
declare const Chars: Staticify<typeof CharsImpl>;

declare class EncodeUtf16Impl extends IteratorImpl<u16> {
    private chars;
    private extra;
    constructor(chars: Chars, extra: u16);
    next(): Option<u16>;
    static new(chars: Chars, extra: u16): EncodeUtf16Impl;
}
type EncodeUtf16 = EncodeUtf16Impl;
declare const EncodeUtf16: Staticify<typeof EncodeUtf16Impl>;

declare class LinesImpl extends IteratorImpl<str> {
    constructor(p: str);
    static new(str: str): LinesImpl;
}
type Lines = LinesImpl;
declare const Lines: Staticify<typeof LinesImpl>;

declare class MatchIndicesImpl extends IteratorImpl<[usize, str]> {
    constructor(p: str, pattern: Io);
    static new(str: str, pattern: Io): MatchIndicesImpl;
}
type MatchIndices = MatchIndicesImpl;
declare const MatchIndices: Staticify<typeof MatchIndicesImpl>;

declare class MatchesImpl extends IteratorImpl<str> {
    constructor(p: str, pattern: Io);
    static new(str: str, pattern: Io): MatchesImpl;
}
type Matches = MatchesImpl;
declare const Matches: Staticify<typeof MatchesImpl>;

type Matcher = char<_$1> | Iterable<char<_$1> | string> | RegExp | str | string | ((char: char<_$1>) => boolean);

declare class RMatchIndicesImpl extends IteratorImpl<[usize, str]> {
    constructor(p: str, pattern: Io);
    static new(str: str, pattern: Io): RMatchIndicesImpl;
}
type RMatchIndices = RMatchIndicesImpl;
declare const RMatchIndices: Staticify<typeof RMatchIndicesImpl>;

declare class RMatchesImpl extends IteratorImpl<str> {
    constructor(p: str, pattern: Io);
    static new(str: str, pattern: Io): RMatchesImpl;
}
type RMatches = RMatchesImpl;
declare const RMatches: Staticify<typeof RMatchesImpl>;

declare class RSplitImpl extends IteratorImpl<str> {
    constructor(p: str, pattern: Io);
    static new(str: str, pattern: Io): RSplitImpl;
}
type RSplit = RSplitImpl;
declare const RSplit: Staticify<typeof RSplitImpl>;

declare class RSplitInclusiveImpl extends IteratorImpl<str> {
    constructor(p: str, pattern: Io);
    static new(str: str, pattern: Io): RSplitInclusiveImpl;
}
type RSplitInclusive = RSplitInclusiveImpl;
declare const RSplitInclusive: Staticify<typeof RSplitInclusiveImpl>;

declare class RSplitTerminatorImpl extends IteratorImpl<str> {
    constructor(p: str, pattern: Io);
    static new(str: str, pattern: Io): RSplitTerminatorImpl;
}
type RSplitTerminator = RSplitTerminatorImpl;
declare const RSplitTerminator: Staticify<typeof RSplitTerminatorImpl>;

declare class RSplitNImpl extends IteratorImpl<str> {
    constructor(p: str, n: int, pattern: Io);
    static new(str: str, n: int, pattern: Io): RSplitNImpl;
}
type RSplitN = RSplitNImpl;
declare const RSplitN: Staticify<typeof RSplitNImpl>;

declare class SplitImpl extends IteratorImpl<str> {
    constructor(p: str, pattern: Io);
    static new(str: str, pattern: Io): SplitImpl;
}
type Split = SplitImpl;
declare const Split: Staticify<typeof SplitImpl>;

declare class SplitAsciiWhitespaceImpl extends IteratorImpl<str> {
    constructor(p: str);
    static new(str: str): SplitAsciiWhitespaceImpl;
}
type SplitAsciiWhitespace = SplitAsciiWhitespaceImpl;
declare const SplitAsciiWhitespace: Staticify<typeof SplitAsciiWhitespaceImpl>;

declare class SplitInclusiveImpl extends IteratorImpl<str> {
    constructor(p: str, pattern: Io);
    static new(str: str, pattern: Io): SplitInclusiveImpl;
}
type SplitInclusive = SplitInclusiveImpl;
declare const SplitInclusive: Staticify<typeof SplitInclusiveImpl>;

declare class SplitTerminatorImpl extends IteratorImpl<str> {
    constructor(p: str, pattern: Io);
    static new(str: str, pattern: Io): SplitTerminatorImpl;
}
type SplitTerminator = SplitTerminatorImpl;
declare const SplitTerminator: Staticify<typeof SplitTerminatorImpl>;

declare class SplitWhitespaceImpl extends IteratorImpl<str> {
    constructor(p: str);
    static new(str: str): SplitWhitespaceImpl;
}
type SplitWhitespace = SplitWhitespaceImpl;
declare const SplitWhitespace: Staticify<typeof SplitWhitespaceImpl>;

declare class SplitNImpl extends IteratorImpl<str> {
    constructor(v: str, n: int, pattern: Io);
    static new(ptr: str, n: int, pattern: Io): SplitN;
}
type SplitN = SplitNImpl;
declare const SplitN: Staticify<typeof SplitNImpl>;

declare class StrImpl implements Debug, Display {
    alloc: string;
    constructor(value: Io);
    fmt_debug(): string;
    fmt_display(): string;
    clone(): str;
    static new(value: Io): StrImpl;
    len(): usize;
    is_empty(): boolean;
    as_bytes(): slice<u8>;
    is_char_boundary(index: int): boolean;
    floor_char_boundary(index: int): usize;
    ceil_char_boundary(index: int): usize;
    get(index: int): Option<u8>;
    get_unchecked(index: int): u8;
    slice(start: int, end: int): Option<str>;
    slice_unchecked(start: int, end: int): str;
    split_at(mid: int): [str, str];
    chars(): Chars;
    char_indices(): CharIndices;
    bytes(): Bytes;
    split_whitespace(): SplitWhitespace;
    split_ascii_whitespace(): SplitAsciiWhitespace;
    lines(): Lines;
    encode_utf16(): EncodeUtf16;
    contains(pattern: Matcher): boolean;
    starts_with(pattern: Matcher): boolean;
    ends_with(pattern: Matcher): boolean;
    find(pattern: Matcher): Option<usize>;
    rfind(pattern: Matcher): Option<usize>;
    split(pattern: Io): Split;
    split_inclusive(pattern: Io): SplitInclusive;
    rsplit(pattern: Io): RSplit;
    rsplit_inclusive(pattern: Io): RSplitInclusive;
    split_terminator(pattern: Io): SplitTerminator;
    rsplit_terminator(pattern: Io): RSplitTerminator;
    splitn(n: int, pattern: Io): SplitN;
    rsplitn(n: int, pattern: Io): RSplitN;
    split_once(delimiter: Io): Option<[str, str]>;
    rsplit_once(delimiter: Io): Option<[str, str]>;
    matches(pattern: Io): Matches;
    rmatches(pattern: Io): RMatches;
    match_indices(pattern: Io): MatchIndices;
    rmatch_indices(pattern: Io): RMatchIndices;
    trim(): str;
    trim_start(): str;
    trim_end(): str;
    strip_prefix(pattern: Matcher): str;
    strip_suffix(pattern: Matcher): str;
    trim_start_matches(pattern: Matcher): str;
    trim_end_matches(pattern: Matcher): str;
    trim_matches(pattern: Matcher): str;
    parse<T>(x: (s: string) => T): T;
    is_ascii(): boolean;
    eq_ignore_ascii_case(other: Io): boolean;
    make_ascii_uppercase(): this;
    make_ascii_lowercase(): this;
    escape_debug(): this;
    escape_default(): this;
    escape_unicode(): this;
    replace(from: Io, to: Io): str;
    replacen(pattern: Io, to: Io, count: int): str;
    to_lowercase(): str;
    to_uppercase(): str;
    repeat(n: int): str;
    to_ascii_uppercase(): str;
    to_ascii_lowercase(): str;
}
type str = StrImpl;
declare const str: Staticify<typeof StrImpl>;
type Io = char<_$1> | Iterable<char<_$1>> | Iterable<u8> | str | u8 | string;

declare class Panic extends Error {
    message: string;
    constructor(message: string);
}
declare function panic(message: string): never;

type panic$1_Panic = Panic;
declare const panic$1_Panic: typeof Panic;
declare const panic$1_panic: typeof panic;
declare namespace panic$1 {
  export {
    panic$1_Panic as Panic,
    panic$1_panic as panic,
  };
}

declare function assert(x: unknown, label?: string): asserts x;
declare function assert_eq(x: unknown, y: unknown, label_x?: string, label_y?: string): asserts x is typeof y;
declare function assert_ne(x: unknown, y: unknown, label_x?: string, label_y?: string): void;
declare function is_node(): boolean;
declare function cfg(flag: keyof NodeJS.Process['config']['variables']): boolean;
declare function column(): usize;
declare function compile_error(msg: unknown): void;
declare function concat(...values: Array<unknown>): string;
declare function dbg(value: unknown): void;
declare function debug_assert(x: unknown, label?: string): asserts x;
declare function debug_assert_eq(x: unknown, y: unknown, label_x?: string, label_y?: string): asserts x is typeof y;
declare function debug_assert_ne(x: unknown, y: unknown, label_x?: string, label_y?: string): void;
declare function env(variable: string, message?: string): string;
declare function eprint(msg: string): void;
declare function eprintln(msg: string): void;
declare function file(): string;
declare function format(literal: string, ...argv: Array<unknown>): string;
declare function format_args(literal: string, ...argv: Array<unknown>): string;
declare function include<T>(path: string): T;
type X86Feature = 'abm' | 'adx' | 'aes' | 'avx' | 'avx2' | 'avx512bf16' | 'avx512bitalg' | 'avx512bw' | 'avx512cd' | 'avx512dq' | 'avx512er' | 'avx512f' | 'avx512gfni' | 'avx512ifma' | 'avx512pf' | 'avx512vaes' | 'avx512vbmi' | 'avx512vbmi2' | 'avx512vl' | 'avx512vnni' | 'avx512vp2intersect' | 'avx512vpclmulqdq' | 'avx512vpopcntdq' | 'bmi1' | 'bmi2' | 'cmpxchg16b' | 'f16c' | 'fma' | 'fxsr' | 'lzcnt' | 'mmx' | 'pclmulqdq' | 'popcnt' | 'rdrand' | 'rdseed' | 'rtm' | 'sha' | 'sse' | 'sse2' | 'sse3' | 'sse4.1' | 'sse4.2' | 'sse4a' | 'ssse3' | 'tbm' | 'tsc' | 'xsave' | 'xsavec' | 'xsaveopt' | 'xsaves';
declare function is_x86_feature_detected(feature: X86Feature): boolean;
declare function line(): usize;
declare function module_path(): string;
declare function option_env(variable: string, message?: string): Option<string>;

declare function print(msg: string): void;
declare function println(msg: string): void;
declare function stringify(x: unknown): string;
declare function todo(message?: string): never;
declare function unimplemented(message?: string): never;
declare function unreachable(message?: string): never;
declare function vec<T>(...argv: Array<T>): Vec<T>;

type macros_X86Feature = X86Feature;
declare const macros_assert: typeof assert;
declare const macros_assert_eq: typeof assert_eq;
declare const macros_assert_ne: typeof assert_ne;
declare const macros_cfg: typeof cfg;
declare const macros_column: typeof column;
declare const macros_compile_error: typeof compile_error;
declare const macros_concat: typeof concat;
declare const macros_dbg: typeof dbg;
declare const macros_debug_assert: typeof debug_assert;
declare const macros_debug_assert_eq: typeof debug_assert_eq;
declare const macros_debug_assert_ne: typeof debug_assert_ne;
declare const macros_env: typeof env;
declare const macros_eprint: typeof eprint;
declare const macros_eprintln: typeof eprintln;
declare const macros_file: typeof file;
declare const macros_format: typeof format;
declare const macros_format_args: typeof format_args;
declare const macros_include: typeof include;
declare const macros_is_node: typeof is_node;
declare const macros_is_x86_feature_detected: typeof is_x86_feature_detected;
declare const macros_line: typeof line;
declare const macros_module_path: typeof module_path;
declare const macros_option_env: typeof option_env;
declare const macros_panic: typeof panic;
declare const macros_print: typeof print;
declare const macros_println: typeof println;
declare const macros_stringify: typeof stringify;
declare const macros_todo: typeof todo;
declare const macros_unimplemented: typeof unimplemented;
declare const macros_unreachable: typeof unreachable;
declare const macros_vec: typeof vec;
declare namespace macros {
  export {
    macros_X86Feature as X86Feature,
    macros_assert as assert,
    macros_assert_eq as assert_eq,
    macros_assert_ne as assert_ne,
    macros_cfg as cfg,
    macros_column as column,
    macros_compile_error as compile_error,
    macros_concat as concat,
    macros_dbg as dbg,
    macros_debug_assert as debug_assert,
    macros_debug_assert_eq as debug_assert_eq,
    macros_debug_assert_ne as debug_assert_ne,
    macros_env as env,
    macros_eprint as eprint,
    macros_eprintln as eprintln,
    macros_file as file,
    macros_format as format,
    macros_format_args as format_args,
    macros_include as include,
    macros_is_node as is_node,
    macros_is_x86_feature_detected as is_x86_feature_detected,
    macros_line as line,
    macros_module_path as module_path,
    macros_option_env as option_env,
    macros_panic as panic,
    macros_print as print,
    macros_println as println,
    macros_stringify as stringify,
    macros_todo as todo,
    macros_unimplemented as unimplemented,
    macros_unreachable as unreachable,
    macros_vec as vec,
  };
}

type index$1_Arm<T> = Arm<T>;
declare const index$1_ArrayChunks: typeof ArrayChunks;
declare const index$1_Chain: typeof Chain;
declare const index$1_Chunks: typeof Chunks;
declare const index$1_ChunksExact: typeof ChunksExact;
declare const index$1_Cycle: typeof Cycle;
declare const index$1_DecodeUtf16: typeof DecodeUtf16;
declare const index$1_DecodeUtf16Error: typeof DecodeUtf16Error;
declare const index$1_DoubleEndedIterator: typeof DoubleEndedIterator;
declare const index$1_Empty: typeof Empty;
declare const index$1_Enumerate: typeof Enumerate;
declare const index$1_Err: typeof Err;
declare const index$1_EscapeDebug: typeof EscapeDebug;
declare const index$1_EscapeDefault: typeof EscapeDefault;
declare const index$1_EscapeUnicode: typeof EscapeUnicode;
declare const index$1_ExactSizeIterator: typeof ExactSizeIterator;
declare const index$1_Filter: typeof Filter;
declare const index$1_FilterMap: typeof FilterMap;
declare const index$1_FlatMap: typeof FlatMap;
declare const index$1_Flatten: typeof Flatten;
declare const index$1_FromFn: typeof FromFn;
type index$1_FromIterator<T> = FromIterator<T>;
declare const index$1_Fuse: typeof Fuse;
declare const index$1_HashMap: typeof HashMap;
declare const index$1_HashSet: typeof HashSet;
declare const index$1_Inspect: typeof Inspect;
declare const index$1_Intersperse: typeof Intersperse;
declare const index$1_IntersperseWith: typeof IntersperseWith;
type index$1_IntoIterator<T, I extends Iterator<T> = Iterator<T>> = IntoIterator<T, I>;
declare const index$1_Iterator: typeof Iterator;
type index$1_IteratorImpl<T> = IteratorImpl<T>;
declare const index$1_IteratorImpl: typeof IteratorImpl;
declare const index$1_Map: typeof Map;
declare const index$1_MapWhile: typeof MapWhile;
declare const index$1_None: typeof None;
declare const index$1_Ok: typeof Ok;
declare const index$1_Once: typeof Once;
declare const index$1_OnceWith: typeof OnceWith;
declare const index$1_Option: typeof Option;
declare const index$1_Peekable: typeof Peekable;
declare const index$1_RChunks: typeof RChunks;
declare const index$1_RChunksExact: typeof RChunksExact;
declare const index$1_Repeat: typeof Repeat;
declare const index$1_RepeatWith: typeof RepeatWith;
type index$1_Resolve<T, U> = Resolve<T, U>;
type index$1_Result<T, E> = Result<T, E>;
declare const index$1_Scan: typeof Scan;
declare const index$1_Skip: typeof Skip;
declare const index$1_SkipWhile: typeof SkipWhile;
type index$1_Some<T> = Some<T>;
declare const index$1_StepBy: typeof StepBy;
declare const index$1_Successors: typeof Successors;
declare const index$1_Take: typeof Take;
declare const index$1_TakeWhile: typeof TakeWhile;
declare const index$1_Vec: typeof Vec;
declare const index$1_Windows: typeof Windows;
type index$1_X86Feature = X86Feature;
declare const index$1_Zip: typeof Zip;
declare const index$1__: typeof _;
declare const index$1_assert: typeof assert;
declare const index$1_assert_eq: typeof assert_eq;
declare const index$1_assert_ne: typeof assert_ne;
declare const index$1_bool: typeof bool;
declare const index$1_cfg: typeof cfg;
declare const index$1_char: typeof char;
declare const index$1_column: typeof column;
declare const index$1_compile_error: typeof compile_error;
declare const index$1_concat: typeof concat;
declare const index$1_consts: typeof consts;
declare const index$1_dbg: typeof dbg;
declare const index$1_debug_assert: typeof debug_assert;
declare const index$1_debug_assert_eq: typeof debug_assert_eq;
declare const index$1_debug_assert_ne: typeof debug_assert_ne;
declare const index$1_empty: typeof empty;
declare const index$1_env: typeof env;
declare const index$1_eprint: typeof eprint;
declare const index$1_eprintln: typeof eprintln;
declare const index$1_f64: typeof f64;
declare const index$1_file: typeof file;
declare const index$1_format: typeof format;
declare const index$1_format_args: typeof format_args;
declare const index$1_from_fn: typeof from_fn;
declare const index$1_i128: typeof i128;
declare const index$1_i16: typeof i16;
declare const index$1_i32: typeof i32;
declare const index$1_i64: typeof i64;
declare const index$1_i8: typeof i8;
declare const index$1_include: typeof include;
declare const index$1_is_node: typeof is_node;
declare const index$1_is_x86_feature_detected: typeof is_x86_feature_detected;
declare const index$1_isize: typeof isize;
declare const index$1_line: typeof line;
declare const index$1_match: typeof match;
declare const index$1_module_path: typeof module_path;
declare const index$1_once: typeof once;
declare const index$1_once_with: typeof once_with;
declare const index$1_option_env: typeof option_env;
declare const index$1_panic: typeof panic;
declare const index$1_print: typeof print;
declare const index$1_println: typeof println;
declare const index$1_repeat: typeof repeat;
declare const index$1_repeat_with: typeof repeat_with;
declare const index$1_result_from: typeof result_from;
declare const index$1_slice: typeof slice;
declare const index$1_str: typeof str;
declare const index$1_stringify: typeof stringify;
declare const index$1_successors: typeof successors;
declare const index$1_todo: typeof todo;
declare const index$1_tuple: typeof tuple;
declare const index$1_u128: typeof u128;
declare const index$1_u16: typeof u16;
declare const index$1_u32: typeof u32;
declare const index$1_u64: typeof u64;
declare const index$1_u8: typeof u8;
declare const index$1_unimplemented: typeof unimplemented;
declare const index$1_unit: typeof unit;
declare const index$1_unreachable: typeof unreachable;
declare const index$1_usize: typeof usize;
declare const index$1_vec: typeof vec;
declare const index$1_zip: typeof zip;
declare namespace index$1 {
  export {
    index$1_Arm as Arm,
    Array$1 as Array,
    index$1_ArrayChunks as ArrayChunks,
    index$1_Chain as Chain,
    index$1_Chunks as Chunks,
    index$1_ChunksExact as ChunksExact,
    index$1_Cycle as Cycle,
    index$1_DecodeUtf16 as DecodeUtf16,
    index$1_DecodeUtf16Error as DecodeUtf16Error,
    index$1_DoubleEndedIterator as DoubleEndedIterator,
    index$1_Empty as Empty,
    index$1_Enumerate as Enumerate,
    index$1_Err as Err,
    index$1_EscapeDebug as EscapeDebug,
    index$1_EscapeDefault as EscapeDefault,
    index$1_EscapeUnicode as EscapeUnicode,
    index$1_ExactSizeIterator as ExactSizeIterator,
    index$1_Filter as Filter,
    index$1_FilterMap as FilterMap,
    index$1_FlatMap as FlatMap,
    index$1_Flatten as Flatten,
    index$1_FromFn as FromFn,
    index$1_FromIterator as FromIterator,
    index$1_Fuse as Fuse,
    index$1_HashMap as HashMap,
    index$1_HashSet as HashSet,
    index$1_Inspect as Inspect,
    index$1_Intersperse as Intersperse,
    index$1_IntersperseWith as IntersperseWith,
    IntoIter$2 as IntoIter,
    index$1_IntoIterator as IntoIterator,
    index$1_Iterator as Iterator,
    index$1_IteratorImpl as IteratorImpl,
    index$1_Map as Map,
    index$1_MapWhile as MapWhile,
    index$1_None as None,
    index$1_Ok as Ok,
    index$1_Once as Once,
    index$1_OnceWith as OnceWith,
    index$1_Option as Option,
    index$1_Peekable as Peekable,
    index$1_RChunks as RChunks,
    index$1_RChunksExact as RChunksExact,
    RSplit$1 as RSplit,
    RSplitInclusive$1 as RSplitInclusive,
    RSplitN$1 as RSplitN,
    index$1_Repeat as Repeat,
    index$1_RepeatWith as RepeatWith,
    index$1_Resolve as Resolve,
    index$1_Result as Result,
    index$1_Scan as Scan,
    index$1_Skip as Skip,
    index$1_SkipWhile as SkipWhile,
    index$1_Some as Some,
    Split$1 as Split,
    SplitInclusive$1 as SplitInclusive,
    SplitN$1 as SplitN,
    index$1_StepBy as StepBy,
    index$1_Successors as Successors,
    index$1_Take as Take,
    index$1_TakeWhile as TakeWhile,
    types as Types,
    index$1_Vec as Vec,
    index$1_Windows as Windows,
    index$1_X86Feature as X86Feature,
    index$1_Zip as Zip,
    index$1__ as _,
    index$1_assert as assert,
    index$1_assert_eq as assert_eq,
    index$1_assert_ne as assert_ne,
    index$1_bool as bool,
    index$1_cfg as cfg,
    index$1_char as char,
    index$1_column as column,
    index$1_compile_error as compile_error,
    index$1_concat as concat,
    index$1_consts as consts,
    index$1_dbg as dbg,
    index$1_debug_assert as debug_assert,
    index$1_debug_assert_eq as debug_assert_eq,
    index$1_debug_assert_ne as debug_assert_ne,
    index$1_empty as empty,
    index$1_env as env,
    index$1_eprint as eprint,
    index$1_eprintln as eprintln,
    index$1_f64 as f64,
    index$1_file as file,
    index$1_format as format,
    index$1_format_args as format_args,
    index$1_from_fn as from_fn,
    index$1_i128 as i128,
    index$1_i16 as i16,
    index$1_i32 as i32,
    index$1_i64 as i64,
    index$1_i8 as i8,
    index$1_include as include,
    index$1_is_node as is_node,
    index$1_is_x86_feature_detected as is_x86_feature_detected,
    index$1_isize as isize,
    index$1_line as line,
    index$1_match as match,
    index$1_module_path as module_path,
    index$1_once as once,
    index$1_once_with as once_with,
    index$1_option_env as option_env,
    index$1_panic as panic,
    index$1_print as print,
    index$1_println as println,
    index$1_repeat as repeat,
    index$1_repeat_with as repeat_with,
    index$1_result_from as result_from,
    index$1_slice as slice,
    index$1_str as str,
    index$1_stringify as stringify,
    index$1_successors as successors,
    index$1_todo as todo,
    index$1_tuple as tuple,
    index$1_u128 as u128,
    index$1_u16 as u16,
    index$1_u32 as u32,
    index$1_u64 as u64,
    index$1_u8 as u8,
    index$1_unimplemented as unimplemented,
    index$1_unit as unit,
    index$1_unreachable as unreachable,
    index$1_usize as usize,
    index$1_vec as vec,
    index$1_zip as zip,
  };
}

interface Hash {
    hash(): bigint;
}
declare function compare_hash(t: unknown, u: unknown): boolean;

type hash_Hash = Hash;
declare const hash_compare_hash: typeof compare_hash;
declare namespace hash {
  export {
    hash_Hash as Hash,
    hash_compare_hash as compare_hash,
  };
}

declare class DurationImpl implements Add<Duration>, AddAssign<Duration>, Sub<Duration>, SubAssign<Duration>, Mul<int, Duration>, MulAssign<int, Duration>, Div<int, Duration>, DivAssign<int, Duration>, Clone<Duration>, Assign<Duration>, Debug {
    private readonly secs;
    private readonly nanos;
    private static readonly nanos_per_sec;
    private static readonly nanos_per_milli;
    private static readonly nanos_per_micro;
    private static readonly millis_per_sec;
    private static readonly micros_per_sec;
    static readonly max: Duration;
    static readonly zero: Duration;
    static readonly second: Duration;
    static readonly millisecond: Duration;
    static readonly microsecond: Duration;
    static readonly nanosecond: Duration;
    constructor(secs: int, nanos: int);
    fmt_debug(): string;
    static new(secs: int, nanos: int): DurationImpl;
    static from_secs(secs: int): DurationImpl;
    static from_millis(millis: int): DurationImpl;
    static from_micros(micros: int): DurationImpl;
    static from_nanos(nanos: int): DurationImpl;
    is_zero(): boolean;
    as_secs(): u64;
    subsec_millis(): u32;
    subsec_micros(): u32;
    subsec_nanos(): u32;
    as_millis(): u128;
    as_micros(): u128;
    as_nanos(): u128;
    checked_add(rhs: Duration): Option<Duration>;
    saturating_add(rhs: Duration): Duration;
    checked_sub(rhs: Duration): Option<Duration>;
    saturating_sub(rhs: Duration): Duration;
    checked_mul(rhs: int): Option<DurationImpl>;
    saturating_mul(rhs: int): DurationImpl;
    checked_div(rhs: int): Option<Duration>;
    as_secs_f64(): f64;
    assign(other: DurationImpl): this;
    add(other: DurationImpl): DurationImpl;
    add_assign(other: DurationImpl): DurationImpl;
    sub(other: DurationImpl): DurationImpl;
    sub_assign(other: DurationImpl): DurationImpl;
    clone(): DurationImpl;
    div(other: int): DurationImpl;
    div_assign(other: int): DurationImpl;
    mul(other: int): DurationImpl;
    mul_assign(other: int): DurationImpl;
}
type Duration = DurationImpl;
declare const Duration: Staticify<typeof DurationImpl>;

declare class InstantImpl implements Add<Duration, InstantImpl>, Sub<Duration, InstantImpl>, AddAssign<Duration, InstantImpl>, SubAssign<Duration, InstantImpl>, Assign<InstantImpl> {
    private instant;
    static new(): InstantImpl;
    static now(): InstantImpl;
    static on(raw: number): InstantImpl;
    saturating_duration_since(earlier: InstantImpl): Duration;
    checked_duration_since(earlier: InstantImpl): Option<Duration>;
    duration_since(earlier: InstantImpl): Duration;
    elapsed(): Duration;
    checked_add(duration: Duration): Option<InstantImpl>;
    checked_sub(duration: Duration): Option<InstantImpl>;
    add(duration: Duration): InstantImpl;
    sub(duration: Duration): InstantImpl;
    assign(other: InstantImpl): this;
    add_assign(other: Duration): InstantImpl;
    sub_assign(other: Duration): InstantImpl;
}
type Instant = InstantImpl;
declare const Instant: Staticify<typeof InstantImpl>;

declare const unix_epoch: Instant;

declare const index_Duration: typeof Duration;
declare const index_Instant: typeof Instant;
declare const index_unix_epoch: typeof unix_epoch;
declare namespace index {
  export {
    index_Duration as Duration,
    index_Instant as Instant,
    index_unix_epoch as unix_epoch,
  };
}

export { Arm, Array$1 as Array, ArrayChunks, Chain, Chunks, ChunksExact, Cycle, DecodeUtf16, DecodeUtf16Error, DoubleEndedIterator, Empty, Enumerate, Err, EscapeDebug, EscapeDefault, EscapeUnicode, ExactSizeIterator, Filter, FilterMap, FlatMap, Flatten, FromFn, FromIterator, Fuse, HashMap, HashSet, Inspect, Intersperse, IntersperseWith, IntoIter$2 as IntoIter, IntoIterator, Iterator, IteratorImpl, Map, MapWhile, None, Ok, Once, OnceWith, Option, Peekable, RChunks, RChunksExact, RSplit$1 as RSplit, RSplitInclusive$1 as RSplitInclusive, RSplitN$1 as RSplitN, Repeat, RepeatWith, Resolve, Result, Scan, Skip, SkipWhile, Some, Split$1 as Split, SplitInclusive$1 as SplitInclusive, SplitN$1 as SplitN, StepBy, Successors, Take, TakeWhile, types as Types, Vec, Windows, X86Feature, Zip, _, ascii, assert, assert_eq, assert_ne, bool, cfg, char, clone, cmp, index$2 as collections, column, compile_error, concat, consts, convert, index$1 as core, custom, dbg, debug_assert, debug_assert_eq, debug_assert_ne, _default as def, empty, env, eprint, eprintln, f64, file, fmt, format, format_args, from_fn, hash, i128, i16, i32, i64, i8, include, index$5 as int, is_node, is_x86_feature_detected, isize, index$3 as iter, line, macros, match, module_path, once, once_with, index$6 as ops, option, option_env, panic$1 as panic, print, println, repeat, repeat_with, result, result_from, slice, bool$1 as std_bool, index$4 as std_char, str, stringify, successors, index as time, todo, tuple, u128, u16, u32, u64, u8, unimplemented, unit, unreachable, usize, vec, zip };
